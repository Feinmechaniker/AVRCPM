
AVRASM ver. 2.2.7  \\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm Thu Aug 01 11:39:28 2019

[builtin](6): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.2.209\avrasm\inc\m328pdef.inc'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(33): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.2.209\avrasm\inc\m328Pdef.inc'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(35): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\config.inc'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\config.inc(448): warning: Register r8 already defined by the .DEF directive
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(35): '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\config.inc' included form here
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\config.inc(449): warning: Register r9 already defined by the .DEF directive
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(35): '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\config.inc' included form here
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\config.inc(452): warning: Register r10 already defined by the .DEF directive
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(35): '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\config.inc' included form here
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\config.inc(453): warning: Register r11 already defined by the .DEF directive
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(35): '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\config.inc' included form here
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\config.inc(456): warning: Register r12 already defined by the .DEF directive
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(35): '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\config.inc' included form here
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\config.inc(457): warning: Register r13 already defined by the .DEF directive
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(35): '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\config.inc' included form here
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(36): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\svnrev.inc'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(37): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\macros.inc'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(39): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\dram-8bit.inc'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(65): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\sw-uart.asm'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(70): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\utils.asm'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(71): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\init.asm'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(72): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\timer.asm'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(73): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\heap.asm'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(74): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\mmc.asm'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(77): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\dram-8bit.asm'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(82): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\i2c.asm'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(85): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\dsk_cpm.asm'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(86): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\dsk_fat16.asm'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(87): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\dsk_ram.asm'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(88): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\dsk_mgr.asm'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(89): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\dsk_fsys.asm'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(98): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\Z80int-jmp.asm'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(100): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\virt_ports.asm'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(101): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\dram-refresh.asm'
[builtin](6): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.2.209\avrasm\inc\m328pdef.inc'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(33): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.2.209\avrasm\inc\m328Pdef.inc'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(35): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\config.inc'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(36): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\svnrev.inc'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(37): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\macros.inc'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(39): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\dram-8bit.inc'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(65): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\sw-uart.asm'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(70): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\utils.asm'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(71): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\init.asm'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(72): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\timer.asm'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(73): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\heap.asm'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(74): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\mmc.asm'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(77): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\dram-8bit.asm'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(82): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\i2c.asm'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(85): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\dsk_cpm.asm'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(86): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\dsk_fat16.asm'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(87): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\dsk_ram.asm'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(88): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\dsk_mgr.asm'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(89): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\dsk_fsys.asm'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(98): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\Z80int-jmp.asm'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(100): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\virt_ports.asm'
\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\avrcpm.asm(101): Including file '\\AMESYS_SYN\Projekte\Projekte\02 AVR CPM\avr_7\avrcpm\dram-refresh.asm'
                                 
                                 ;    This is the main file, glueing all parts together.
                                 
                                 ;    Copyright (C) 2010 Sprite_tm
                                 ;    Copyright (C) 2010,2012,2013 Leo C.
                                 ;
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega328P.xml **********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m328Pdef.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega328P
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega328P
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M328PDEF_INC_
                                 #define _M328PDEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega328P
                                 #pragma AVRPART ADMIN PART_NAME ATmega328P
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x95
                                 .equ	SIGNATURE_002	= 0x0f
                                 
                                 #pragma AVRPART CORE CORE_VERSION V2E
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	UDR0	= 0xc6	; MEMORY MAPPED
                                 .equ	UBRR0L	= 0xc4	; MEMORY MAPPED
                                 .equ	UBRR0H	= 0xc5	; MEMORY MAPPED
                                 .equ	UCSR0C	= 0xc2	; MEMORY MAPPED
                                 .equ	UCSR0B	= 0xc1	; MEMORY MAPPED
                                 .equ	UCSR0A	= 0xc0	; MEMORY MAPPED
                                 .equ	TWAMR	= 0xbd	; MEMORY MAPPED
                                 .equ	TWCR	= 0xbc	; MEMORY MAPPED
                                 .equ	TWDR	= 0xbb	; MEMORY MAPPED
                                 .equ	TWAR	= 0xba	; MEMORY MAPPED
                                 .equ	TWSR	= 0xb9	; MEMORY MAPPED
                                 .equ	TWBR	= 0xb8	; MEMORY MAPPED
                                 .equ	ASSR	= 0xb6	; MEMORY MAPPED
                                 .equ	OCR2B	= 0xb4	; MEMORY MAPPED
                                 .equ	OCR2A	= 0xb3	; MEMORY MAPPED
                                 .equ	TCNT2	= 0xb2	; MEMORY MAPPED
                                 .equ	TCCR2B	= 0xb1	; MEMORY MAPPED
                                 .equ	TCCR2A	= 0xb0	; MEMORY MAPPED
                                 .equ	OCR1BL	= 0x8a	; MEMORY MAPPED
                                 .equ	OCR1BH	= 0x8b	; MEMORY MAPPED
                                 .equ	OCR1AL	= 0x88	; MEMORY MAPPED
                                 .equ	OCR1AH	= 0x89	; MEMORY MAPPED
                                 .equ	ICR1L	= 0x86	; MEMORY MAPPED
                                 .equ	ICR1H	= 0x87	; MEMORY MAPPED
                                 .equ	TCNT1L	= 0x84	; MEMORY MAPPED
                                 .equ	TCNT1H	= 0x85	; MEMORY MAPPED
                                 .equ	TCCR1C	= 0x82	; MEMORY MAPPED
                                 .equ	TCCR1B	= 0x81	; MEMORY MAPPED
                                 .equ	TCCR1A	= 0x80	; MEMORY MAPPED
                                 .equ	DIDR1	= 0x7f	; MEMORY MAPPED
                                 .equ	DIDR0	= 0x7e	; MEMORY MAPPED
                                 .equ	ADMUX	= 0x7c	; MEMORY MAPPED
                                 .equ	ADCSRB	= 0x7b	; MEMORY MAPPED
                                 .equ	ADCSRA	= 0x7a	; MEMORY MAPPED
                                 .equ	ADCH	= 0x79	; MEMORY MAPPED
                                 .equ	ADCL	= 0x78	; MEMORY MAPPED
                                 .equ	TIMSK2	= 0x70	; MEMORY MAPPED
                                 .equ	TIMSK1	= 0x6f	; MEMORY MAPPED
                                 .equ	TIMSK0	= 0x6e	; MEMORY MAPPED
                                 .equ	PCMSK1	= 0x6c	; MEMORY MAPPED
                                 .equ	PCMSK2	= 0x6d	; MEMORY MAPPED
                                 .equ	PCMSK0	= 0x6b	; MEMORY MAPPED
                                 .equ	EICRA	= 0x69	; MEMORY MAPPED
                                 .equ	PCICR	= 0x68	; MEMORY MAPPED
                                 .equ	OSCCAL	= 0x66	; MEMORY MAPPED
                                 .equ	PRR	= 0x64	; MEMORY MAPPED
                                 .equ	CLKPR	= 0x61	; MEMORY MAPPED
                                 .equ	WDTCSR	= 0x60	; MEMORY MAPPED
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	SPMCSR	= 0x37
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUSR	= 0x34
                                 .equ	SMCR	= 0x33
                                 .equ	ACSR	= 0x30
                                 .equ	SPDR	= 0x2e
                                 .equ	SPSR	= 0x2d
                                 .equ	SPCR	= 0x2c
                                 .equ	GPIOR2	= 0x2b
                                 .equ	GPIOR1	= 0x2a
                                 .equ	OCR0B	= 0x28
                                 .equ	OCR0A	= 0x27
                                 .equ	TCNT0	= 0x26
                                 .equ	TCCR0B	= 0x25
                                 .equ	TCCR0A	= 0x24
                                 .equ	GTCCR	= 0x23
                                 .equ	EEARH	= 0x22
                                 .equ	EEARL	= 0x21
                                 .equ	EEDR	= 0x20
                                 .equ	EECR	= 0x1f
                                 .equ	GPIOR0	= 0x1e
                                 .equ	EIMSK	= 0x1d
                                 .equ	EIFR	= 0x1c
                                 .equ	PCIFR	= 0x1b
                                 .equ	TIFR2	= 0x17
                                 .equ	TIFR1	= 0x16
                                 .equ	TIFR0	= 0x15
                                 .equ	PORTD	= 0x0b
                                 .equ	DDRD	= 0x0a
                                 .equ	PIND	= 0x09
                                 .equ	PORTC	= 0x08
                                 .equ	DDRC	= 0x07
                                 .equ	PINC	= 0x06
                                 .equ	PORTB	= 0x05
                                 .equ	DDRB	= 0x04
                                 .equ	PINB	= 0x03
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** USART0 ***********************
                                 ; UDR0 - USART I/O Data Register
                                 .equ	UDR0_0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR0_1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR0_2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR0_3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR0_4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR0_5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR0_6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR0_7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR0A - USART Control and Status Register A
                                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                                 .equ	U2X0	= 1	; Double the USART transmission speed
                                 .equ	UPE0	= 2	; Parity Error
                                 .equ	DOR0	= 3	; Data overRun
                                 .equ	FE0	= 4	; Framing Error
                                 .equ	UDRE0	= 5	; USART Data Register Empty
                                 .equ	TXC0	= 6	; USART Transmitt Complete
                                 .equ	RXC0	= 7	; USART Receive Complete
                                 
                                 ; UCSR0B - USART Control and Status Register B
                                 .equ	TXB80	= 0	; Transmit Data Bit 8
                                 .equ	RXB80	= 1	; Receive Data Bit 8
                                 .equ	UCSZ02	= 2	; Character Size
                                 .equ	TXEN0	= 3	; Transmitter Enable
                                 .equ	RXEN0	= 4	; Receiver Enable
                                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR0C - USART Control and Status Register C
                                 .equ	UCPOL0	= 0	; Clock Polarity
                                 .equ	UCSZ00	= 1	; Character Size
                                 .equ	UCPHA0	= UCSZ00	; For compatibility
                                 .equ	UCSZ01	= 2	; Character Size
                                 .equ	UDORD0	= UCSZ01	; For compatibility
                                 .equ	USBS0	= 3	; Stop Bit Select
                                 .equ	UPM00	= 4	; Parity Mode Bit 0
                                 .equ	UPM01	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL00	= 6	; USART Mode Select
                                 .equ	UMSEL0	= UMSEL00	; For compatibility
                                 .equ	UMSEL01	= 7	; USART Mode Select
                                 .equ	UMSEL1	= UMSEL01	; For compatibility
                                 
                                 ; UBRR0H - USART Baud Rate Register High Byte
                                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR0L - USART Baud Rate Register Low Byte
                                 .equ	_UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	_UBRR1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** TWI **************************
                                 ; TWAMR - TWI (Slave) Address Mask Register
                                 .equ	TWAM0	= 1	; 
                                 .equ	TWAMR0	= TWAM0	; For compatibility
                                 .equ	TWAM1	= 2	; 
                                 .equ	TWAMR1	= TWAM1	; For compatibility
                                 .equ	TWAM2	= 3	; 
                                 .equ	TWAMR2	= TWAM2	; For compatibility
                                 .equ	TWAM3	= 4	; 
                                 .equ	TWAMR3	= TWAM3	; For compatibility
                                 .equ	TWAM4	= 5	; 
                                 .equ	TWAMR4	= TWAM4	; For compatibility
                                 .equ	TWAM5	= 6	; 
                                 .equ	TWAMR5	= TWAM5	; For compatibility
                                 .equ	TWAM6	= 7	; 
                                 .equ	TWAMR6	= TWAM6	; For compatibility
                                 
                                 ; TWBR - TWI Bit Rate register
                                 .equ	TWBR0	= 0	; 
                                 .equ	TWBR1	= 1	; 
                                 .equ	TWBR2	= 2	; 
                                 .equ	TWBR3	= 3	; 
                                 .equ	TWBR4	= 4	; 
                                 .equ	TWBR5	= 5	; 
                                 .equ	TWBR6	= 6	; 
                                 .equ	TWBR7	= 7	; 
                                 
                                 ; TWCR - TWI Control Register
                                 .equ	TWIE	= 0	; TWI Interrupt Enable
                                 .equ	TWEN	= 2	; TWI Enable Bit
                                 .equ	TWWC	= 3	; TWI Write Collition Flag
                                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                                 .equ	TWINT	= 7	; TWI Interrupt Flag
                                 
                                 ; TWSR - TWI Status Register
                                 .equ	TWPS0	= 0	; TWI Prescaler
                                 .equ	TWPS1	= 1	; TWI Prescaler
                                 .equ	TWS3	= 3	; TWI Status
                                 .equ	TWS4	= 4	; TWI Status
                                 .equ	TWS5	= 5	; TWI Status
                                 .equ	TWS6	= 6	; TWI Status
                                 .equ	TWS7	= 7	; TWI Status
                                 
                                 ; TWDR - TWI Data register
                                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                                 
                                 ; TWAR - TWI (Slave) Address register
                                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK1 - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE1	= 0	; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1A	= 1	; Timer/Counter1 Output CompareA Match Interrupt Enable
                                 .equ	OCIE1B	= 2	; Timer/Counter1 Output CompareB Match Interrupt Enable
                                 .equ	ICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                                 
                                 ; TIFR1 - Timer/Counter Interrupt Flag register
                                 .equ	TOV1	= 0	; Timer/Counter1 Overflow Flag
                                 .equ	OCF1A	= 1	; Output Compare Flag 1A
                                 .equ	OCF1B	= 2	; Output Compare Flag 1B
                                 .equ	ICF1	= 5	; Input Capture Flag 1
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Waveform Generation Mode
                                 .equ	WGM11	= 1	; Waveform Generation Mode
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Comparet Ouput Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                                 .equ	WGM12	= 3	; Waveform Generation Mode
                                 .equ	WGM13	= 4	; Waveform Generation Mode
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 ; TCCR1C - Timer/Counter1 Control Register C
                                 .equ	FOC1B	= 6	; 
                                 .equ	FOC1A	= 7	; 
                                 
                                 ; GTCCR - General Timer/Counter Control Register
                                 .equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** TIMER_COUNTER_2 **************
                                 ; TIMSK2 - Timer/Counter Interrupt Mask register
                                 .equ	TOIE2	= 0	; Timer/Counter2 Overflow Interrupt Enable
                                 .equ	TOIE2A	= TOIE2	; For compatibility
                                 .equ	OCIE2A	= 1	; Timer/Counter2 Output Compare Match A Interrupt Enable
                                 .equ	OCIE2B	= 2	; Timer/Counter2 Output Compare Match B Interrupt Enable
                                 
                                 ; TIFR2 - Timer/Counter Interrupt Flag Register
                                 .equ	TOV2	= 0	; Timer/Counter2 Overflow Flag
                                 .equ	OCF2A	= 1	; Output Compare Flag 2A
                                 .equ	OCF2B	= 2	; Output Compare Flag 2B
                                 
                                 ; TCCR2A - Timer/Counter2 Control Register A
                                 .equ	WGM20	= 0	; Waveform Genration Mode
                                 .equ	WGM21	= 1	; Waveform Genration Mode
                                 .equ	COM2B0	= 4	; Compare Output Mode bit 0
                                 .equ	COM2B1	= 5	; Compare Output Mode bit 1
                                 .equ	COM2A0	= 6	; Compare Output Mode bit 1
                                 .equ	COM2A1	= 7	; Compare Output Mode bit 1
                                 
                                 ; TCCR2B - Timer/Counter2 Control Register B
                                 .equ	CS20	= 0	; Clock Select bit 0
                                 .equ	CS21	= 1	; Clock Select bit 1
                                 .equ	CS22	= 2	; Clock Select bit 2
                                 .equ	WGM22	= 3	; Waveform Generation Mode
                                 .equ	FOC2B	= 6	; Force Output Compare B
                                 .equ	FOC2A	= 7	; Force Output Compare A
                                 
                                 ; TCNT2 - Timer/Counter2
                                 .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
                                 .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
                                 .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
                                 .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
                                 .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
                                 .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
                                 .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
                                 .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
                                 
                                 ; OCR2A - Timer/Counter2 Output Compare Register A
                                 .equ	OCR2A_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                                 .equ	OCR2A_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                                 .equ	OCR2A_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                                 .equ	OCR2A_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                                 .equ	OCR2A_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                                 .equ	OCR2A_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                                 .equ	OCR2A_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                                 .equ	OCR2A_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                                 
                                 ; OCR2B - Timer/Counter2 Output Compare Register B
                                 .equ	OCR2B_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                                 .equ	OCR2B_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                                 .equ	OCR2B_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                                 .equ	OCR2B_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                                 .equ	OCR2B_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                                 .equ	OCR2B_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                                 .equ	OCR2B_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                                 .equ	OCR2B_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                                 
                                 ; ASSR - Asynchronous Status Register
                                 .equ	TCR2BUB	= 0	; Timer/Counter Control Register2 Update Busy
                                 .equ	TCR2AUB	= 1	; Timer/Counter Control Register2 Update Busy
                                 .equ	OCR2BUB	= 2	; Output Compare Register 2 Update Busy
                                 .equ	OCR2AUB	= 3	; Output Compare Register2 Update Busy
                                 .equ	TCN2UB	= 4	; Timer/Counter2 Update Busy
                                 .equ	AS2	= 5	; Asynchronous Timer/Counter2
                                 .equ	EXCLK	= 6	; Enable External Clock Input
                                 
                                 ; GTCCR - General Timer Counter Control register
                                 .equ	PSRASY	= 1	; Prescaler Reset Timer/Counter2
                                 .equ	PSR2	= PSRASY	; For compatibility
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 .equ	REFS1	= 7	; Reference Selection Bit 1
                                 
                                 ; ADCSRA - The ADC Control and Status register A
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADATE	= 5	; ADC  Auto Trigger Enable
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCSRB - The ADC Control and Status register B
                                 .equ	ADTS0	= 0	; ADC Auto Trigger Source bit 0
                                 .equ	ADTS1	= 1	; ADC Auto Trigger Source bit 1
                                 .equ	ADTS2	= 2	; ADC Auto Trigger Source bit 2
                                 .equ	ACME	= 6	; 
                                 
                                 ; ADCH - ADC Data Register High Byte
                                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                                 
                                 ; ADCL - ADC Data Register Low Byte
                                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                                 
                                 ; DIDR0 - Digital Input Disable Register
                                 .equ	ADC0D	= 0	; 
                                 .equ	ADC1D	= 1	; 
                                 .equ	ADC2D	= 2	; 
                                 .equ	ADC3D	= 3	; 
                                 .equ	ADC4D	= 4	; 
                                 .equ	ADC5D	= 5	; 
                                 
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 ; DIDR1 - Digital Input Disable Register 1
                                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                                 .equ	PC0	= 0	; For compatibility
                                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                                 .equ	PC1	= 1	; For compatibility
                                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                                 .equ	PC2	= 2	; For compatibility
                                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                                 .equ	PC3	= 3	; For compatibility
                                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                                 .equ	PC4	= 4	; For compatibility
                                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                                 .equ	PC5	= 5	; For compatibility
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TIMSK0 - Timer/Counter0 Interrupt Mask Register
                                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0A	= 1	; Timer/Counter0 Output Compare Match A Interrupt Enable
                                 .equ	OCIE0B	= 2	; Timer/Counter0 Output Compare Match B Interrupt Enable
                                 
                                 ; TIFR0 - Timer/Counter0 Interrupt Flag register
                                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0A	= 1	; Timer/Counter0 Output Compare Flag 0A
                                 .equ	OCF0B	= 2	; Timer/Counter0 Output Compare Flag 0B
                                 
                                 ; TCCR0A - Timer/Counter  Control Register A
                                 .equ	WGM00	= 0	; Waveform Generation Mode
                                 .equ	WGM01	= 1	; Waveform Generation Mode
                                 .equ	COM0B0	= 4	; Compare Output Mode, Fast PWm
                                 .equ	COM0B1	= 5	; Compare Output Mode, Fast PWm
                                 .equ	COM0A0	= 6	; Compare Output Mode, Phase Correct PWM Mode
                                 .equ	COM0A1	= 7	; Compare Output Mode, Phase Correct PWM Mode
                                 
                                 ; TCCR0B - Timer/Counter Control Register B
                                 .equ	CS00	= 0	; Clock Select
                                 .equ	CS01	= 1	; Clock Select
                                 .equ	CS02	= 2	; Clock Select
                                 .equ	WGM02	= 3	; 
                                 .equ	FOC0B	= 6	; Force Output Compare B
                                 .equ	FOC0A	= 7	; Force Output Compare A
                                 
                                 ; TCNT0 - Timer/Counter0
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0A - Timer/Counter0 Output Compare Register
                                 .equ	OCR0A_0	= 0	; 
                                 .equ	OCR0A_1	= 1	; 
                                 .equ	OCR0A_2	= 2	; 
                                 .equ	OCR0A_3	= 3	; 
                                 .equ	OCR0A_4	= 4	; 
                                 .equ	OCR0A_5	= 5	; 
                                 .equ	OCR0A_6	= 6	; 
                                 .equ	OCR0A_7	= 7	; 
                                 
                                 ; OCR0B - Timer/Counter0 Output Compare Register
                                 .equ	OCR0B_0	= 0	; 
                                 .equ	OCR0B_1	= 1	; 
                                 .equ	OCR0B_2	= 2	; 
                                 .equ	OCR0B_3	= 3	; 
                                 .equ	OCR0B_4	= 4	; 
                                 .equ	OCR0B_5	= 5	; 
                                 .equ	OCR0B_6	= 6	; 
                                 .equ	OCR0B_7	= 7	; 
                                 
                                 ; GTCCR - General Timer/Counter Control Register
                                 ;.equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                                 .equ	PSR10	= PSRSYNC	; For compatibility
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; EICRA - External Interrupt Control Register
                                 .equ	ISC00	= 0	; External Interrupt Sense Control 0 Bit 0
                                 .equ	ISC01	= 1	; External Interrupt Sense Control 0 Bit 1
                                 .equ	ISC10	= 2	; External Interrupt Sense Control 1 Bit 0
                                 .equ	ISC11	= 3	; External Interrupt Sense Control 1 Bit 1
                                 
                                 ; EIMSK - External Interrupt Mask Register
                                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                                 
                                 ; EIFR - External Interrupt Flag Register
                                 .equ	INTF0	= 0	; External Interrupt Flag 0
                                 .equ	INTF1	= 1	; External Interrupt Flag 1
                                 
                                 ; PCICR - Pin Change Interrupt Control Register
                                 .equ	PCIE0	= 0	; Pin Change Interrupt Enable 0
                                 .equ	PCIE1	= 1	; Pin Change Interrupt Enable 1
                                 .equ	PCIE2	= 2	; Pin Change Interrupt Enable 2
                                 
                                 ; PCMSK2 - Pin Change Mask Register 2
                                 .equ	PCINT16	= 0	; Pin Change Enable Mask 16
                                 .equ	PCINT17	= 1	; Pin Change Enable Mask 17
                                 .equ	PCINT18	= 2	; Pin Change Enable Mask 18
                                 .equ	PCINT19	= 3	; Pin Change Enable Mask 19
                                 .equ	PCINT20	= 4	; Pin Change Enable Mask 20
                                 .equ	PCINT21	= 5	; Pin Change Enable Mask 21
                                 .equ	PCINT22	= 6	; Pin Change Enable Mask 22
                                 .equ	PCINT23	= 7	; Pin Change Enable Mask 23
                                 
                                 ; PCMSK1 - Pin Change Mask Register 1
                                 .equ	PCINT8	= 0	; Pin Change Enable Mask 8
                                 .equ	PCINT9	= 1	; Pin Change Enable Mask 9
                                 .equ	PCINT10	= 2	; Pin Change Enable Mask 10
                                 .equ	PCINT11	= 3	; Pin Change Enable Mask 11
                                 .equ	PCINT12	= 4	; Pin Change Enable Mask 12
                                 .equ	PCINT13	= 5	; Pin Change Enable Mask 13
                                 .equ	PCINT14	= 6	; Pin Change Enable Mask 14
                                 
                                 ; PCMSK0 - Pin Change Mask Register 0
                                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                                 .equ	PCINT4	= 4	; Pin Change Enable Mask 4
                                 .equ	PCINT5	= 5	; Pin Change Enable Mask 5
                                 .equ	PCINT6	= 6	; Pin Change Enable Mask 6
                                 .equ	PCINT7	= 7	; Pin Change Enable Mask 7
                                 
                                 ; PCIFR - Pin Change Interrupt Flag Register
                                 .equ	PCIF0	= 0	; Pin Change Interrupt Flag 0
                                 .equ	PCIF1	= 1	; Pin Change Interrupt Flag 1
                                 .equ	PCIF2	= 2	; Pin Change Interrupt Flag 2
                                 
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCSR - Watchdog Timer Control Register
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                                 .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
                                 .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                                 
                                 ; CLKPR - Clock Prescale Register
                                 .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
                                 .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
                                 .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
                                 .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
                                 .equ	CLKPCE	= 7	; Clock Prescaler Change Enable
                                 
                                 ; SPMCSR - Store Program Memory Control and Status Register
                                 .equ    SELFPRGEN = 0; Added for backwards compatibility
                                 .equ	SPMEN	= 0	; Store Program Memory
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read-While-Write section read enable
                                 .equ    SIGRD   = 5 ; Signature Row Read
                                 .equ	RWWSB	= 6	; Read-While-Write Section Busy
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	IVCE	= 0	; 
                                 .equ	IVSEL	= 1	; 
                                 .equ	PUD	= 4	; 
                                 .equ	BODSE	= 5	; BOD Sleep Enable
                                 .equ	BODS	= 6	; BOD Sleep
                                 
                                 ; MCUSR - MCU Status Register
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	EXTREF	= EXTRF	; For compatibility
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 
                                 ; SMCR - Sleep Mode Control Register
                                 .equ	SE	= 0	; Sleep Enable
                                 .equ	SM0	= 1	; Sleep Mode Select Bit 0
                                 .equ	SM1	= 2	; Sleep Mode Select Bit 1
                                 .equ	SM2	= 3	; Sleep Mode Select Bit 2
                                 
                                 ; GPIOR2 - General Purpose I/O Register 2
                                 .equ	GPIOR20	= 0	; 
                                 .equ	GPIOR21	= 1	; 
                                 .equ	GPIOR22	= 2	; 
                                 .equ	GPIOR23	= 3	; 
                                 .equ	GPIOR24	= 4	; 
                                 .equ	GPIOR25	= 5	; 
                                 .equ	GPIOR26	= 6	; 
                                 .equ	GPIOR27	= 7	; 
                                 
                                 ; GPIOR1 - General Purpose I/O Register 1
                                 .equ	GPIOR10	= 0	; 
                                 .equ	GPIOR11	= 1	; 
                                 .equ	GPIOR12	= 2	; 
                                 .equ	GPIOR13	= 3	; 
                                 .equ	GPIOR14	= 4	; 
                                 .equ	GPIOR15	= 5	; 
                                 .equ	GPIOR16	= 6	; 
                                 .equ	GPIOR17	= 7	; 
                                 
                                 ; GPIOR0 - General Purpose I/O Register 0
                                 .equ	GPIOR00	= 0	; 
                                 .equ	GPIOR01	= 1	; 
                                 .equ	GPIOR02	= 2	; 
                                 .equ	GPIOR03	= 3	; 
                                 .equ	GPIOR04	= 4	; 
                                 .equ	GPIOR05	= 5	; 
                                 .equ	GPIOR06	= 6	; 
                                 .equ	GPIOR07	= 7	; 
                                 
                                 ; PRR - Power Reduction Register
                                 .equ	PRADC	= 0	; Power Reduction ADC
                                 .equ	PRUSART0	= 1	; Power Reduction USART
                                 .equ	PRSPI	= 2	; Power Reduction Serial Peripheral Interface
                                 .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
                                 .equ	PRTIM0	= 5	; Power Reduction Timer/Counter0
                                 .equ	PRTIM2	= 6	; Power Reduction Timer/Counter2
                                 .equ	PRTWI	= 7	; Power Reduction TWI
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEARL - EEPROM Address Register Low Byte
                                 .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
                                 .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
                                 .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
                                 .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
                                 .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
                                 .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
                                 .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
                                 .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
                                 
                                 ; EEARH - EEPROM Address Register High Byte
                                 .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 8
                                 .equ	EEAR9	= 1	; EEPROM Read/Write Access Bit 9
                                 
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEPE	= 1	; EEPROM Write Enable
                                 .equ	EEMPE	= 2	; EEPROM Master Write Enable
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
                                 .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	CKOUT	= 6	; Clock output
                                 .equ	CKDIV8	= 7	; Divide clock by 8
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select reset vector
                                 .equ	BOOTSZ0	= 1	; Select boot size
                                 .equ	BOOTSZ1	= 2	; Select boot size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	WDTON	= 4	; Watchdog Timer Always On
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	DWEN	= 6	; debugWIRE Enable
                                 .equ	RSTDISBL	= 7	; External reset disable
                                 
                                 ; EXTENDED fuse bits
                                 .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
                                 .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
                                 .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0x3fff	; Note: Word address
                                 .equ	IOEND	= 0x00ff
                                 .equ	SRAM_START	= 0x0100
                                 .equ	SRAM_SIZE	= 2048
                                 .equ	RAMEND	= 0x08ff
                                 .equ	XRAMEND	= 0x0000
                                 .equ	E2END	= 0x03ff
                                 .equ	EEPROMEND	= 0x03ff
                                 .equ	EEADRBITS	= 10
                                 #pragma AVRPART MEMORY PROG_FLASH 32768
                                 #pragma AVRPART MEMORY EEPROM 1024
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 2048
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0x3800
                                 .equ	NRWW_STOP_ADDR	= 0x3fff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0x37ff
                                 .equ	PAGESIZE	= 64
                                 .equ	FIRSTBOOTSTART	= 0x3f00
                                 .equ	SECONDBOOTSTART	= 0x3e00
                                 .equ	THIRDBOOTSTART	= 0x3c00
                                 .equ	FOURTHBOOTSTART	= 0x3800
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                                 .equ	PCI0addr	= 0x0006	; Pin Change Interrupt Request 0
                                 .equ	PCI1addr	= 0x0008	; Pin Change Interrupt Request 0
                                 .equ	PCI2addr	= 0x000a	; Pin Change Interrupt Request 1
                                 .equ	WDTaddr	= 0x000c	; Watchdog Time-out Interrupt
                                 .equ	OC2Aaddr	= 0x000e	; Timer/Counter2 Compare Match A
                                 .equ	OC2Baddr	= 0x0010	; Timer/Counter2 Compare Match A
                                 .equ	OVF2addr	= 0x0012	; Timer/Counter2 Overflow
                                 .equ	ICP1addr	= 0x0014	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x0016	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x0018	; Timer/Counter1 Compare Match B
                                 .equ	OVF1addr	= 0x001a	; Timer/Counter1 Overflow
                                 .equ	OC0Aaddr	= 0x001c	; TimerCounter0 Compare Match A
                                 .equ	OC0Baddr	= 0x001e	; TimerCounter0 Compare Match B
                                 .equ	OVF0addr	= 0x0020	; Timer/Couner0 Overflow
                                 .equ	SPIaddr	= 0x0022	; SPI Serial Transfer Complete
                                 .equ	URXCaddr	= 0x0024	; USART Rx Complete
                                 .equ	UDREaddr	= 0x0026	; USART, Data Register Empty
                                 .equ	UTXCaddr	= 0x0028	; USART Tx Complete
                                 .equ	ADCCaddr	= 0x002a	; ADC Conversion Complete
                                 .equ	ERDYaddr	= 0x002c	; EEPROM Ready
                                 .equ	ACIaddr	= 0x002e	; Analog Comparator
                                 .equ	TWIaddr	= 0x0030	; Two-wire Serial Interface
                                 .equ	SPMRaddr	= 0x0032	; Store Program Memory Read
                                 
                                 .equ	INT_VECTORS_SIZE	= 52	; size in words
                                 
                                 #endif  /* _M328PDEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 
                                 ;    Copyright (C) 2010 Sprite_tm
                                 ;    Copyright (C) 2010,2012,2013 Leo C.
                                 ;
                                 ;    This file is part of avrcpm.
                                 ;
                                 ;    avrcpm is free software: you can redistribute it and/or modify it
                                 ;    under the terms of the GNU General Public License as published by
                                 ;    the Free Software Foundation, either version 3 of the License, or
                                 ;    (at your option) any later version.
                                 ;
                                 ;    avrcpm is distributed in the hope that it will be useful,
                                 ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
                                 ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                                 ;    GNU General Public License for more details.
                                 ;
                                 ;    You should have received a copy of the GNU General Public License
                                 ;    along with avrcpm.  If not, see <http://www.gnu.org/licenses/>.
                                 ;
                                 ;    $Id: avrcpm.asm 93 2014-01-03 16:32:32Z rapid $
                                 ;
                                 
                                 	.list
                                 
                                 #if MMCBOOTLOADER
                                 	.cseg
                                 	.org FLASHEND-3 - BOOTLDRSIZE/2	;
003bfc 4341
003bfd 4d50                      	.db	DEVID_S			;
                                   #if TESTVERSION
                                   #else
003bfe 0305                      	.db	VMINOR, VMAJOR		;
                                   #endif
003bff 0000                      	.dw	0			;placeholder for crc
                                 #endif /* MMCBOOTLOADER */
                                 
                                 	.cseg
                                 	.org 0
000000 940c 0349                 	ljmp start		; reset vector
                                     	
                                 	.org INT_VECTORS_SIZE
                                 
                                 #if DRAM_8BIT			/* Implies software uart */
                                 	.include "sw-uart.asm"
                                 
                                 ; This is part of the Z80-CP/M emulator written by Sprite_tm.
                                 ;
                                 ;    Copyright (C) 2010 Leo C.
                                 ;
                                 ;    This file is part of avrcpm.
                                 ;
                                 ;    avrcpm is free software: you can redistribute it and/or modify it
                                 ;    under the terms of the GNU General Public License as published by
                                 ;    the Free Software Foundation, either version 3 of the License, or
                                 ;    (at your option) any later version.
                                 ;
                                 ;    avrcpm is distributed in the hope that it will be useful,
                                 ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
                                 ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                                 ;    GNU General Public License for more details.
                                 ;
                                 ;    You should have received a copy of the GNU General Public License
                                 ;    along with avrcpm.  If not, see <http://www.gnu.org/licenses/>.
                                 ;
                                 ;    $Id: sw-uart.asm 93 2014-01-03 16:32:32Z rapid $
                                 ;
                                 
                                 #ifdef  __ATmega8__
                                 #endif
                                 
                                 #define SSER_BIT_TC	(F_CPU+BAUD/2) / BAUD 
                                 #define SSER_CHAR_TC	(10 * 1000 / BAUD) + 2
                                 
                                 #define RXBUFMASK  	RXBUFSIZE-1
                                 #define TXBUFMASK  	TXBUFSIZE-1
                                 
                                 	.dseg
                                 	
                                 srx_state:
000100                           	.byte	1
                                 srx_char_to:
000101                           	.byte	1
                                 srx_char_time:
000102                           	.byte	1
                                 srx_dr:
000103                           	.byte	1
                                 srx_lastedge:
000104                           	.byte	2
                                 stx_bitcount:
000106                           	.byte	1
                                 stx_dr:
000107                           	.byte	1
                                 rxcount:
000108                           	.byte	1
                                 rxidx_w:
000109                           	.byte	1
                                 rxidx_r:
00010a                           	.byte	1
                                 txcount:
00010b                           	.byte	1
                                 txidx_w:
00010c                           	.byte	1
                                 txidx_r:
00010d                           	.byte	1
                                 rxfifo:
00010e                           	.byte	RXBUFSIZE
                                 txfifo:
00018e                           	.byte	TXBUFSIZE
                                 
                                 
                                 	.cseg
                                 
                                 ; Init 
                                 uart_init:
                                 
                                 ; - Init clock/timer system and serial port
                                 
                                 ; Init timer 1 as 
                                 ; - Soft UART TX (OC1A/OCR1A).
                                 ; - Soft UART RX (ICP1/ICR1).
                                 ; - 1ms System timer is already configured at this point.
                                 
                                 
000034 9821                      	cbi	P_TXD-1,TXD			;TXD pin as input
000035 ec00                      	ldi	temp,(1<<COM1A1)|(1<<COM1A0)	;OC1A high on compare match (UART TX)
000036 e810                      	ldi	temp2,(1<<FOC1A)		;force compare match
000037 9300 0080                 	outm8	TCCR1A,temp
000039 9310 0082                 	outm8	TCCR1C,temp2
00003b 9a21                      	sbi	P_TXD-1,TXD			;TXD pin now output (OC1A)
                                 
00003c e200                      	ldi	temp,(1<<ICF1)			;clear pending input capture int
00003d bb06                      	out	TIFR1,temp			;
00003e 9100 006f                 	inm8	temp,TIMSK1			;
000040 6200                      	ori	temp,(1<<ICIE1)			;Enable input capture int.  (UART RX)
000041 9300 006f                 	outm8	TIMSK1,temp			;
                                 
000043 e002                      	ldi	temp,SSER_CHAR_TC		;Character TO
000044 9300 0102                 	sts	srx_char_time,temp
                                 
000046 9508                      	ret
                                 	
                                 ;------------------------------------------------------------------
                                 
                                 	.cseg
                                 
                                 ; Timer/Counter1 Input Capture interrupt
                                 	
000014 c032                      	INTERRUPT ICP1addr
                                 	
000047 930f                      	push	temp
000048 b70f                      	in	temp,sreg
000049 930f                      	push	temp
00004a 93ff                      	push	zh
00004b 93ef                      	push	zl
00004c 91e0 0086                 	inm8	zl,ICR1L
00004e 91f0 0087                 	inm8	zh,ICR1H
000050 931f                      	push	temp2
000051 e410                      	ldi	temp2,(1<<ICES1)
000052 9100 0081                 	inm8	temp,TCCR1B
000054 2701                      	eor	temp,temp2			;toggle edge
000055 9300 0081                 	outm8	TCCR1B,temp
000057 e200                      	ldi	temp,(1<<ICF1)			;clear pending int
000058 bb06                      	out	TIFR1,temp
                                 	
                                 #if 0
                                 #endif	
000059 9100 0100                 	lds	temp,srx_state
00005b 3000                      	cpi	temp,0
00005c f4c9                      	brne	srxi_S1		
                                 
                                 ; State 0: Wait for start bit
                                 
00005d 93e0 0104                 	sts	srx_lastedge,zl			;save beginning of start bit
00005f 93f0 0105                 	sts	srx_lastedge+1,zh
                                 ;	movw	srx_lastedgel,zl
000061 9270 0103                 	sts	srx_dr,_0
000063 e001                      	ldi	temp,1
000064 9300 0100                 	sts	srx_state,temp
000066 9100 0102                 	lds	temp,srx_char_time
000068 9300 0101                 	sts	srx_char_to,temp
00006a 9b18                      	sbis	P_RXD-2,RXD			;RXD still low?
00006b c0a1                      	rjmp	srxi_end
00006c e8e1                      	ldi	zl,(1<<ICNC1)|(1<<CS10)		;next edge is falling edge
00006d 93e0 0081                 	outm8	TCCR1B,zl
00006f e2f0                      	ldi	zh,(1<<ICF1)			;clear pending int
000070 bbf6                      	out	TIFR1,zh
000071 9270 0100                 	sts	srx_state,_0
000073 9270 0101                 	sts	srx_char_to,_0
000075 c097                      	rjmp	srxi_end
                                 
                                 srxi_S1:
000076 3001                      	cpi	temp,1
000077 f5c9                      	brne	srxi_S2
                                 
                                 ; State 1: Check start bit (and collect 0-bits)
                                 
000078 9100 0104                 	lds	temp,srx_lastedge
00007a 9110 0105                 	lds	temp2,srx_lastedge+1
00007c 93e0 0104                 	sts	srx_lastedge,zl
00007e 93f0 0105                 	sts	srx_lastedge+1,zh
                                 
                                 ;	movw	temp,srx_lastedgel
                                 ;	movw	srx_lastedgel,zl
                                 
000080 1be0                      	sub	zl,temp
000081 0bf1                      	sbc	zh,temp2
000082 55e7                      	subi	zl,low ((SSER_BIT_TC+1)/2)
000083 40f0                      	sbci	zh,high((SSER_BIT_TC+1)/2)
000084 f0e0                      	brcs	srxi_sberr
                                 
                                 ;	mov	temp,zh	
                                 ;	rcall	printhex
                                 ;	mov	temp,zl
                                 ;	rcall	printhex
                                 
000085 e800                      	ldi	temp,0x80
                                 srxi_1l:
000086 5aee                      	subi	zl,low(SSER_BIT_TC)
000087 40f0                      	sbci	zh,high(SSER_BIT_TC)
000088 f090                      	brcs	srxi_1be
000089 9506                      	lsr	temp
00008a f7d8                      	brcc	srxi_1l
                                 
00008b 5aee                      	subi	zl,low(SSER_BIT_TC)		; stop bit?
00008c 40f0                      	sbci	zh,high(SSER_BIT_TC)
00008d f408                      	brcc	srxi_1fe
00008e c068                      	rjmp	srxi_complete0			; ok, x00 (^@) received
                                 srxi_1fe:
00008f 9270 0101                 	sts	srx_char_to,_0			; no stop bit --> framing error --> break
000091 9270 0100                 	sts	srx_state,_0
000093 6031                      	sbr	intstat,(1<<i_break)		;
000094 9270 0108                 	sts	rxcount,_0			;clear rx buffer
000096 9270 0109                 	sts	rxidx_w,_0
000098 9270 010a                 	sts	rxidx_r,_0
                                 
00009a c072                      	rjmp	srxi_end
                                 
                                 srxi_1be:
00009b 9300 0103                 	sts	srx_dr,temp
00009d e002                      	ldi	temp,2
00009e 9300 0100                 	sts	srx_state,temp
0000a0 c06c                      	rjmp	srxi_end
                                 
                                 srxi_sberr:
0000a1 e801                      	ldi	temp,(1<<ICNC1)|(1<<CS10)	;next edge is falling edge
0000a2 9300 0081                 	outm8	TCCR1B,temp
0000a4 e200                      	ldi	temp,(1<<ICF1)		;clear pending int
0000a5 bb06                      	out	TIFR1,temp
0000a6 9270 0100                 	sts	srx_state,_0		;next state
                                 #if 1
0000a8 e30f                      	ldi	temp,'?'
0000a9 d0f9                      	rcall	uartputc
0000aa 5ae9                      	subi	zl,low (-(SSER_BIT_TC+1)/2)
0000ab 4fff                      	sbci	zh,high(-(SSER_BIT_TC+1)/2)
0000ac 2f0f                      	mov	temp,zh
0000ad d164                      	rcall	printhex
0000ae 2f0e                      	mov	temp,zl
0000af d162                      	rcall	printhex
                                 #endif
0000b0 c05c                      	rjmp	srxi_end
                                 
                                 srxi_S2:
0000b1 3002                      	cpi	temp,2
0000b2 f511                      	brne	srxi_S3
                                 
                                 ; State 2: collect 1-bits
                                 
0000b3 9100 0104                 	lds	temp,srx_lastedge
0000b5 9110 0105                 	lds	temp2,srx_lastedge+1
0000b7 93e0 0104                 	sts	srx_lastedge,zl
0000b9 93f0 0105                 	sts	srx_lastedge+1,zh
                                 
                                 ;	movw	temp,srx_lastedgel
                                 ;	movw	srx_lastedgel,zl
                                 
0000bb 1be0                      	sub	zl,temp
0000bc 0bf1                      	sbc	zh,temp2
0000bd 55e7                      	subi	zl,low ((SSER_BIT_TC+1)/2)
0000be 40f0                      	sbci	zh,high((SSER_BIT_TC+1)/2)
                                 
0000bf 9100 0103                 	lds	temp,srx_dr
                                 srxi_2l:
0000c1 9408                      	sec				;one more 1 bit
0000c2 9507                      	ror	temp
0000c3 f048                      	brcs	srxi_complete1		;8 bits recieved
0000c4 5aee                      	subi	zl,low(SSER_BIT_TC)
0000c5 40f0                      	sbci	zh,high(SSER_BIT_TC)
0000c6 f7d0                      	brcc	srxi_2l
                                 	
0000c7 9300 0103                 	sts	srx_dr,temp
0000c9 e003                      	ldi	temp,3
0000ca 9300 0100                 	sts	srx_state,temp
0000cc c040                      	rjmp	srxi_end
                                 	
                                 srxi_complete1:
0000cd e011                      	ldi	temp2,1			;We are in start bit now.
0000ce 9310 0100                 	sts	srx_state,temp2
0000d0 9110 0102                 	lds	temp2,srx_char_time
0000d2 9310 0101                 	sts	srx_char_to,temp2
0000d4 c026                      	rjmp	srxi_complete
                                 	
                                 srxi_S3:
0000d5 3003                      	cpi	temp,3
0000d6 f4c9                      	brne	srxi_S4
                                 
                                 ; State 3: collect 0-bits
                                 
0000d7 9100 0104                 	lds	temp,srx_lastedge
0000d9 9110 0105                 	lds	temp2,srx_lastedge+1
0000db 93e0 0104                 	sts	srx_lastedge,zl
0000dd 93f0 0105                 	sts	srx_lastedge+1,zh
                                 
                                 ;	movw	temp,srx_lastedgel
                                 ;	movw	srx_lastedgel,zl
                                 
0000df 1be0                      	sub	zl,temp
0000e0 0bf1                      	sbc	zh,temp2
0000e1 55e7                      	subi	zl,low ((SSER_BIT_TC+1)/2)
0000e2 40f0                      	sbci	zh,high((SSER_BIT_TC+1)/2)
                                 
0000e3 9100 0103                 	lds	temp,srx_dr
                                 srxi_3l:
                                 					;one more 0 bit
0000e5 9506                      	lsr	temp
0000e6 f080                      	brcs	srxi_complete0		;8 bits recieved
0000e7 5aee                      	subi	zl,low(SSER_BIT_TC)
0000e8 40f0                      	sbci	zh,high(SSER_BIT_TC)
0000e9 f7d8                      	brcc	srxi_3l
                                 	
0000ea 9300 0103                 	sts	srx_dr,temp
0000ec e002                      	ldi	temp,2
0000ed 9300 0100                 	sts	srx_state,temp
0000ef c01d                      	rjmp	srxi_end
                                 
                                 srxi_S4:
0000f0 e8e1                      	ldi	zl,(1<<ICNC1)|(1<<CS10)	;next edge is falling edge
0000f1 93e0 0081                 	outm8	TCCR1B,zl
0000f3 e2e0                      	ldi	zl,(1<<ICF1)		;clear pending int
0000f4 9270 0100                 	sts	srx_state,_0		;next state
0000f6 c016                      	rjmp	srxi_end
                                 
                                 srxi_complete0:	
0000f7 9270 0101                 	sts	srx_char_to,_0		;clear timeout
0000f9 9270 0100                 	sts	srx_state,_0		;next state
                                 srxi_complete:
                                 #if 0
                                 #endif
                                 
                                 ; Save received character in a circular buffer. Do nothing if buffer overflows.
                                 
0000fb 91f0 0108                 	lds	zh,rxcount			;2   if rxcount < RXBUFSIZE
0000fd 38f0                      	cpi	zh,RXBUFSIZE			;1      (room for at least 1 char?)
0000fe f470                      	brsh	srxi_ov				;1 
0000ff 95f3                      	inc	zh				;1
000100 93f0 0108                 	sts	rxcount,zh			;2      rxcount++
                                 
000102 e0ee                      	ldi	zl,low(rxfifo)			;1  
000103 91f0 0109                 	lds	zh,rxidx_w			;2
000105 0fef                      	add	zl,zh				;1
000106 95f3                      	inc	zh				;1
000107 77ff                      	andi	zh,RXBUFMASK			;1
000108 93f0 0109                 	sts	rxidx_w,zh			;2      rxidx_w = ++rxidx_w % RXBUFSIZE
00010a e0f1                      	ldi	zh,high(rxfifo)			;1
00010b 1df7                      	adc	zh,_0				;1
00010c 8300                      	st	z,temp				;2      rxfifo[rxidx_w] = char
                                 srxi_ov:					;=19     endif
                                 
                                 srxi_end:
00010d 911f                      	pop	temp2
00010e 91ef                      	pop	zl
00010f 91ff                      	pop	zh
000110 910f                      	pop	temp
000111 bf0f                      	out	sreg,temp
000112 910f                      	pop	temp
000113 9518                      	reti
                                 
                                 
                                 ;----------------------------------------------------------------------
                                 
                                 	.cseg
                                 
                                 ; Timer/Counter1 Compare Match A interrupt
                                 	
000016 c0fd                      	INTERRUPT OC1Aaddr
                                 	
000114 93ef                      	push	zl
000115 b7ef                      	in	zl,sreg
000116 93ef                      	push	zl
000117 93ff                      	push	zh
                                 
000118 91e0 0088                 	inm8	zl,OCR1AL
00011a 91f0 0089                 	inm8	zh,OCR1AH
00011c 55e2                      	subi	zl,low(-SSER_BIT_TC)
00011d 4fff                      	sbci	zh,high(-SSER_BIT_TC)
00011e 93f0 0089                 	outm8	OCR1AH,zh
000120 93e0 0088                 	outm8	OCR1AL,zl
                                 
000122 91e0 0106                 	lds	zl,stx_bitcount
000124 95ea                      	dec	zl
000125 f512                      	brpl	stxi_nextbit
                                 	
                                 ; bit counter was 0, more characters?
                                 
                                 stxi_nxtchar:
000126 91e0 010b                 	lds	zl,txcount		;if txcount != 0
000128 95ea                      	dec	zl
000129 f0ba                      	brmi	stxi_dis
                                 
                                 ; get next char
00012a 93e0 010b                 	sts	txcount,zl		;   --txcount
00012c 930f                      	push	temp			;
00012d e8ee                      	ldi	zl,low(txfifo)		;  
00012e e0f1                      	ldi	zh,high(txfifo)		;
00012f 9100 010d                 	lds	temp,txidx_r		;
000131 0fe0                      	add	zl,temp			;
000132 1df7                      	adc	zh,_0
000133 9503                      	inc	temp			;
000134 770f                      	andi	temp,TXBUFMASK		;
000135 9300 010d                 	sts	txidx_r,temp		;
000137 8100                      	ld	temp,z
000138 9500                      	com	temp
000139 9300 0107                 	sts	stx_dr,temp
00013b e009                      	ldi	temp,9
00013c 9300 0106                 	sts	stx_bitcount,temp
00013e 910f                      	pop	temp
                                 
00013f e8f0                      	ldi	zh,(1<<COM1A1)
000140 c011                      	rjmp	stxi_ex
                                 
                                 ; disable transmitter
                                 stxi_dis:
000141 91e0 006f                 	inm8	zl,TIMSK1
000143 7fed                      	andi	zl,~(1<<OCIE1A)
000144 93e0 006f                 	outm8	TIMSK1,zl
                                 
000146 ecf0                      	ldi	zh,(1<<COM1A1)|(1<<COM1A0)
000147 c00a                      	rjmp	stxi_ex
                                 
                                 stxi_nextbit:
000148 93e0 0106                 	sts	stx_bitcount,zl
                                 
00014a e8f0                      	ldi	zh,(1<<COM1A1)
00014b 91e0 0107                 	lds	zl,stx_dr
00014d ffe0                      	sbrs	zl,0
00014e ecf0                      	ldi	zh,(1<<COM1A1)|(1<<COM1A0)
00014f 95e6                      	lsr	zl
000150 93e0 0107                 	sts	stx_dr,zl
                                 stxi_ex:
000152 93f0 0080                 	outm8	TCCR1A,zh
000154 91ff                      	pop	zh
000155 91ef                      	pop	zl
000156 bfef                      	out	sreg,zl
000157 91ef                      	pop	zl
000158 9518                      	reti
                                 
                                 ;------------------------------------------------------------------
                                 
                                 srx_to:
                                 #if 0
                                 #endif
000159 9270 0100                 	sts	srx_state,_0		;next state
00015b 930f                      	push	temp
                                 
                                 #if 0
                                 #endif
00015c 9100 0103                 	lds	temp,srx_dr		;only 0 if timeout after leading edge of start bit.
00015e 2300                      	tst	temp			; --> break
00015f f441                      	brne	srxto_store
000160 6031                      	sbr	intstat,(1<<i_break)
000161 9270 0108                 	sts	rxcount,_0		;clear rx buffer
000163 9270 0109                 	sts	rxidx_w,_0
000165 9270 010a                 	sts	rxidx_r,_0
000167 c019                      	rjmp	srxto_ov
                                 
                                 srxto_store:
000168 2fe0                      	mov	zl,temp
000169 95e0                      	com	zl
00016a 78e0                      	andi	zl,0x80
                                 srxto_l:
00016b 9506                      	lsr	temp
00016c 2b0e                      	or	temp,zl
00016d f7e8                      	brcc	srxto_l
                                 	
                                 ; Save received character in a circular buffer. Do nothing if buffer overflows.
                                 
00016e 91f0 0108                 	lds	zh,rxcount		;if rxcount < RXBUFSIZE
000170 38f0                      	cpi	zh,RXBUFSIZE		;   (room for at least 1 char?)
000171 f478                      	brsh	srxto_ov			; 
000172 95f3                      	inc	zh			;
000173 93f0 0108                 	sts	rxcount,zh		;   rxcount++
                                 
000175 e0ee                      	ldi	zl,low(rxfifo)		;  
000176 91f0 0109                 	lds	zh,rxidx_w		;
000178 0fef                      	add	zl,zh			;
000179 95f3                      	inc	zh			;
00017a 77ff                      	andi	zh,RXBUFMASK		;
00017b 93f0 0109                 	sts	rxidx_w,zh		;   rxidx_w = ++rxidx_w % RXBUFSIZE
00017d e0f1                      	ldi	zh,high(rxfifo)		;
00017e f408                      	brcc	PC+2			;
00017f 95f3                      	inc	zh			;
000180 8300                      	st	z,temp			;   rxfifo[rxidx_w] = char
                                 srxto_ov:					;endif
                                 	
000181 910f                      	pop	temp
000182 9508                      	ret
                                 	
                                 	
                                 ;Fetches a char from the buffer to temp. If none available, waits till one is.
                                 
                                 uartgetc:
000183 93ff                      	push	zh
000184 93ef                      	push	zl
000185 931f                      	push	temp2
                                 ugetc_w:
000186 9100 0108                 	lds	temp,rxcount		;Number of characters in buffer
000188 2300                      	tst	temp
000189 f3e1                      	breq	ugetc_w			;Wait for char
                                 	
00018a e0ee                      	ldi	zl,low(rxfifo)
00018b e0f1                      	ldi	zh,high(rxfifo)
00018c 9110 010a                 	lds	temp2,rxidx_r
00018e 0fe1                      	add	zl,temp2
00018f 1df7                      	adc	zh,_0
000190 9513                      	inc	temp2
000191 771f                      	andi	temp2,RXBUFMASK
000192 94f8                      	cli
000193 9100 0108                 	lds	temp,rxcount
000195 5001                      	subi	temp,1
000196 f410                      	brcc	ugetc_fin
000197 9478                      	sei
000198 cfed                      	rjmp	ugetc_w
                                 
                                 ugetc_fin:
000199 9300 0108                 	sts	rxcount,temp
00019b 9310 010a                 	sts	rxidx_r,temp2
00019d 9478                      	sei
00019e 8100                      	ld	temp,z		;don't forget to get the char
00019f 911f                      	pop	temp2
0001a0 91ef                      	pop	zl
0001a1 91ff                      	pop	zh
0001a2 9508                      	ret
                                 
                                 ;Sends a char from temp to the soft uart. 
                                 
                                 uartputc:
0001a3 93ff                      	push	zh
0001a4 93ef                      	push	zl
0001a5 b7ef                      	in	zl,sreg
0001a6 93ef                      	push	zl
0001a7 930f                      	push	temp
                                 sputc_l:
0001a8 9100 010b                 	lds	temp,txcount		;do {
0001aa 3800                      	cpi	temp,TXBUFSIZE		;
0001ab f7e0                      	brsh	sputc_l			;} while (txcount >= TXBUFSIZE)
                                 
0001ac 94f8                      	cli
0001ad e8ee                      	ldi	zl,low(txfifo)		;  
0001ae e0f1                      	ldi	zh,high(txfifo)		;
0001af 9100 010c                 	lds	temp,txidx_w		;
0001b1 0fe0                      	add	zl,temp			;
0001b2 1df7                      	adc	zh,_0			;
0001b3 9503                      	inc	temp			;
0001b4 770f                      	andi	temp,TXBUFMASK		;
0001b5 9300 010c                 	sts	txidx_w,temp		;   txidx_w = ++txidx_w % TXBUFSIZE
0001b7 910f                      	pop	temp			;
0001b8 8300                      	st	z,temp			;   txfifo[txidx_w] = char
                                 ;	cli
0001b9 91f0 010b                 	lds	zh,txcount
0001bb 95f3                      	inc	zh
0001bc 93f0 010b                 	sts	txcount,zh
0001be 30f1                      	cpi	zh,1
0001bf f491                      	brne	sputc_e
                                 ; Enable transmitter
0001c0 91f0 006f                 	inm8	zh,TIMSK1
0001c2 fdf1                      	sbrc	zh,OCIE1A
0001c3 c00e                      	rjmp	sputc_e
0001c4 60f2                      	ori	zh,(1<<OCIE1A)
0001c5 93f0 006f                 	outm8	TIMSK1,zh
                                 
0001c7 91e0 0084                 	inm8	zl,TCNT1L		;
0001c9 91f0 0085                 	inm8	zh,TCNT1H		;
0001cb 967e                      	adiw	zl,30			;
0001cc 93f0 0089                 	outm8	OCR1AH,zh		;
0001ce 93e0 0088                 	outm8	OCR1AL,zl		;
0001d0 e0e2                      	ldi	zl,(1<<OCF1A)
0001d1 bbe6                      	outm8	TIFR1,zl
                                 
                                 sputc_e:
0001d2 91ef                      	pop	zl
0001d3 bfef                      	out	sreg,zl
0001d4 91ef                      	pop	zl
0001d5 91ff                      	pop	zh
0001d6 9508                      	ret
                                 
                                 
                                 ; Wait, till tx buffer is empty.
                                 
                                 uart_wait_empty:
0001d7 930f                      	push	temp
                                 uwe_loop:
0001d8 9100 010b                 	lds	temp,txcount
0001da 2300                      	tst	temp
0001db f7e1                      	brne	uwe_loop
0001dc 910f                      	pop	temp
0001dd 9508                      	ret
                                 
                                 
                                 ; vim:set ts=8 noet nowrap
                                 
                                 #else				/* 4 bit RAM, hardware uart */
                                 #endif
                                 
                                 	.include "utils.asm"
                                 
                                 ;
                                 ;    Copyright (C) 2010-2013 Leo C.
                                 ;
                                 ;    This file is part of avrcpm.
                                 ;
                                 ;    avrcpm is free software: you can redistribute it and/or modify it
                                 ;    under the terms of the GNU General Public License as published by
                                 ;    the Free Software Foundation, either version 3 of the License, or
                                 ;    (at your option) any later version.
                                 ;
                                 ;    avrcpm is distributed in the hope that it will be useful,
                                 ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
                                 ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                                 ;    GNU General Public License for more details.
                                 ;
                                 ;    You should have received a copy of the GNU General Public License
                                 ;    along with avrcpm.  If not, see <http://www.gnu.org/licenses/>.
                                 ;
                                 ;    $Id: utils.asm 93 2014-01-03 16:32:32Z rapid $
                                 ;
                                 
                                 
                                 	.cseg
                                 
                                 
                                 ;Print a unsigned lonng value to the uart
                                 ; r15:r14:temp2:temp = value
                                 
                                 print_ultoa:
0001de 93df                      	push	yh
0001df 93cf                      	push	yl
0001e0 934f                      	push	z_flags
0001e1 92ff                      	push	r15
0001e2 92ef                      	push	r14
0001e3 931f                      	push	temp2
0001e4 930f                      	push	temp
                                 				
0001e5 27cc                      	clr	yl		;yl = stack level
                                 
0001e6 e240                      ultoa1:	ldi	z_flags, 32	;yh = r15:temp % 10
0001e7 27dd                      	clr	yh		;r15:temp /= 10
0001e8 0f00                      ultoa2:	lsl	temp	
0001e9 1f11                      	rol	temp2	
0001ea 1cee                      	rol	r14	
0001eb 1cff                      	rol	r15	
0001ec 1fdd                      	rol	yh	
0001ed 30da                      	cpi	yh,10	
0001ee f010                      	brcs	ultoa3	
0001ef 50da                      	subi	yh,10	
0001f0 9503                      	inc	temp
0001f1 954a                      ultoa3:	dec	z_flags	
0001f2 f7a9                      	brne	ultoa2
0001f3 30da                      	cpi	yh, 10	;yh is a numeral digit '0'-'9'
0001f4 5dd0                      	subi	yh, -'0'
0001f5 93df                      	push	yh		;Stack it
0001f6 95c3                      	inc	yl	
0001f7 1507                      	cp	temp,_0		;Repeat until r15:temp gets zero
0001f8 0517                      	cpc	temp2,_0
0001f9 04e7                      	cpc	r14,_0
0001fa 04f7                      	cpc	r15,_0
0001fb f751                      	brne	ultoa1	
                                 	
0001fc e300                      	ldi	temp, '0'
0001fd 30c3                      ultoa5:	cpi	yl,3		; at least 3 digits (ms)
0001fe f41c                      	brge	ultoa6
0001ff 930f                      	push	temp	
000200 95c3                      	inc	yl
000201 cffb                      	rjmp	ultoa5
                                 
000202 910f                      ultoa6:	pop	temp		;Flush stacked digits
000203 df9f                      	rcall	uartputc
000204 95ca                      	dec	yl	
000205 f7e1                      	brne	ultoa6	
                                 
000206 910f                      	pop	temp
000207 911f                      	pop	temp2
000208 90ef                      	pop	r14
000209 90ff                      	pop	r15
00020a 914f                      	pop	z_flags
00020b 91cf                      	pop	yl
00020c 91df                      	pop	yh
00020d 9508                      	ret
                                 
                                 
                                 ;Prints temp2:temp in hex to the uart
                                 printhexw:
00020e 930f                      	push	temp
00020f 2f01                      	mov	temp,temp2
000210 d001                      	rcall	printhex
000211 910f                      	pop	temp
                                 	;fall thru
                                 
                                 ;Prints temp in hex to the uart
                                 printhex:
000212 9502                      	swap temp
000213 d001                      	rcall printhexn
000214 9502                      	swap temp	
                                 	;fall thru
                                 
                                 ;Prints the lower nibble
                                 printhexn:
000215 930f                      	push temp
000216 700f                      	andi temp,0xf
000217 300a                      	cpi temp,0xA
000218 f008                      	brlo printhexn_isno
000219 5f09                      	subi temp,-7
                                 printhexn_isno:
00021a 5d00                      	subi temp,-'0'
00021b df87                      	rcall uartputc
00021c 910f                      	pop temp
00021d 9508                      	ret
                                 
                                 
                                 ; Prints a single space
                                 
                                 printspace:
00021e 930f                      	push	temp
00021f e200                      	ldi	temp,' '
000220 df82                      	rcall	uartputc
000221 910f                      	pop	temp
000222 9508                      	ret
                                 
                                 ;-----------------------------------------------------------------------
                                 ;Prints the zero-terminated string following the call statement. 
                                 
                                 printstr:
000223 93ff                      	push	zh		;SP+5
000224 93ef                      	push	zl		;   4
000225 93df                      	push	yh		;   3
000226 93cf                      	push	yl		;   2
000227 930f                      	push	temp		;   1
000228 b7de                      	in	yh,sph
000229 b7cd                      	in	yl,spl
00022a 81ef                      	ldd	zl,y+7		;SP+7  == "return adr." == String adr.
00022b 81fe                      	ldd	zh,y+6		;SP+6
                                 
00022c 0fee                      	lsl zl			;word to byte conv.
00022d 1fff                      	rol zh
                                 printstr_loop:
00022e 9105                      	lpm temp,z+
00022f 3000                      	cpi temp,0
000230 f031                      	breq printstr_end
000231 df71                      	rcall uartputc
000232 300d                      	cpi temp,13
000233 f7d1                      	brne printstr_loop
000234 e00a                      	ldi temp,10
000235 df6d                      	rcall uartputc
000236 cff7                      	rjmp printstr_loop
                                 
                                 printstr_end:
000237 9631                      	adiw zl,1		;rounding up
000238 95f6                      	lsr zh			;byte to word conv.
000239 95e7                      	ror zl
                                 
00023a 83ef                      	std	y+7,zl
00023b 83fe                      	std	y+6,zh
00023c 910f                      	pop	temp
00023d 91cf                      	pop	yl
00023e 91df                      	pop	yh
00023f 91ef                      	pop	zl
000240 91ff                      	pop	zh
000241 9508                      	ret
                                 	
                                 ; ------------------------ String functions -------------------------
                                 ;
                                 
                                 #if 0
                                 #endif
                                 
                                 #if 0
                                 #endif
                                 
                                 ;-----------------------------------------------------------------------
                                 ; String compare (x, y, temp2). Max temp2 bytes are compared.
                                 
                                 strncmp_p:
000242 5011                      	subi	temp2,1
000243 f030                      	brcs	strncmp_peq
000244 9109                      	ld	temp,y+
000245 9005                      	lpm	_tmp0, z+
000246 1900                      	sub	temp,_tmp0
000247 f419                      	brne	strncmp_pex
000248 2000                      	tst	_tmp0
000249 f7c1                      	brne	strncmp_p
                                 strncmp_peq:
00024a 1b00                      	sub	temp,temp
                                 strncmp_pex:
00024b 9508                      	ret
                                 
                                 ;-----------------------------------------------------------------------
                                 ; Memory compare: DRAM - AVR-RAM
                                 ; 	DRAM-Addr. in x, AVRRAM-Addr. in y 
                                 ;	Compare temp3 bytes.
                                 ;
                                 ;	Return Z-Flag == 1 if match
                                 ;	temp, _tmp0  destroyed
                                 ;
                                 
                                 memcmp_d:
00024c d5b6                      	rcall	dram_read_pp
00024d 9009                      	ld	_tmp0,y+
00024e 1500                      	cp	temp,_tmp0
00024f f411                      	brne	memcmpd_nomatch
000250 952a                      	dec	temp3
000251 f7d1                      	brne	memcmp_d
                                 memcmpd_nomatch:
000252 9508                      	ret
                                 
                                 ; --------------- Debugging stuff ---------------
                                 
                                 
                                 .if SRAM_FILL
                                 
                                 stackusage_print:
000253 e0ed
000254 e0f7                      	ldiw	z,ramtop
000255 e000                      	ldi	temp,  low(RAMEND+1)
000256 e019                      	ldi	temp2,high(RAMEND+1)
000257 e52a                      	ldi	temp3,SRAMFILL_VAL
                                 stack_search_l:
000258 9001                      	ld	_tmp0,z+
000259 1520                      	cp	temp3,_tmp0
00025a f419                      	brne	stack_search_found
00025b 17e0                      	cp	zl,temp
00025c 07f1                      	cpc	zh,temp2
00025d f7d1                      	brne	stack_search_l
                                 
                                 stack_search_found:
00025e 9731                      	sbiw	z,1
00025f 1b0e                      	sub	temp, zl
000260 0b1f                      	sbc	temp2,zh
000261 dfc1
000262 000d                      	printnewline
000263 dfbf
000264 7453
000265 6361
000266 206b
000267 7375
000268 6465
000269 2820
00026a 7962
00026b 6574
00026c 2973
00026d 203a
00026e 0000                      	printstring "Stack used (bytes): "
00026f 92ff                      	push	r15
000270 92ef                      	push	r14
000271 24ee                      	clr	r14
000272 24ff                      	clr	r15
000273 df6a                      	rcall	print_ultoa
000274 90ef                      	pop	r14
000275 90ff                      	pop	r15
000276 9508                      	ret
                                 .endif
                                 
                                 
                                 .if MEMDUMP_DEBUG
                                 
                                 ;-----------------------------------------------------------------------
                                 ; Prints 16 bytes RAM, pointed to by Z in hex.
                                 
                                 dbg_hexdump_line:			;Address in z
000277 931f                      	push	temp2
000278 930f                      	push	temp
                                 ;	printnewline
000279 018f                      	movw	temp,z			;Print address
00027a df93                      	rcall	printhexw
00027b dfa7
00027c 003a                      	printstring ":"
00027d e110                      	ldi	temp2,16		;16 byte per line
                                 dbg_hdl1:
00027e 3018                      	cpi	temp2,8
00027f f409                      	brne	PC+2
000280 df9d                      	rcall	printspace
                                 	
000281 df9c                      	rcall	printspace
000282 9101                      	ld	temp,z+
000283 df8e                      	rcall	printhex
000284 951a                      	dec	temp2
000285 f7c1                      	brne	dbg_hdl1
000286 9770                      	sbiw	z,16
                                 	
000287 df96                      	rcall	printspace
000288 df95                      	rcall	printspace
000289 e110                      	ldi	temp2,16
                                 dbg_hdl2:
00028a 9101                      	ld	temp,z+
00028b 3200                      	cpi	temp,' '
00028c f010                      	brlo	dbg_hdlpd
00028d 370f                      	cpi	temp,0x7F
00028e f008                      	brlo	dbg_hdlp
                                 dbg_hdlpd:
00028f e20e                      	ldi	temp,'.'
                                 dbg_hdlp:
000290 df12                      	rcall	uartputc
000291 951a                      	dec	temp2
000292 f7b9                      	brne	dbg_hdl2
000293 9770                      	sbiw	z,16
000294 df89                      	rcall	printspace
000295 910f                      	pop	temp
000296 911f                      	pop	temp2
000297 df8b
000298 000d                      	printnewline
000299 9508                      	ret
                                 	
                                 
                                 ; Prints temp2 bytes RAM, pointed to by Z in hex.
                                 
                                 dbg_hexdump:				;Address in z
00029a 930f                      	push	temp
00029b 931f                      	push	temp2
                                 ;	printnewline
00029c 018f                      	movw	temp,z			;Print address
00029d df70                      	rcall	printhexw
00029e df84
00029f 003a                      	printstring ":"
0002a0 911f                      	pop	temp2
0002a1 931f                      	push	temp2
                                 dbg_hd1:
0002a2 df7b                      	rcall	printspace
0002a3 9101                      	ld	temp,z+
0002a4 df6d                      	rcall	printhex
0002a5 951a                      	dec	temp2
0002a6 f7d9                      	brne	dbg_hd1
0002a7 911f                      	pop	temp2
0002a8 1be1                      	sub	zl,temp2
0002a9 09f7                      	sbc	zh,_0
0002aa df73                      	rcall	printspace
0002ab df72                      	rcall	printspace
                                 dbg_hd2:
0002ac 9101                      	ld	temp,z+
0002ad 3200                      	cpi	temp,' '
0002ae f010                      	brlo	dbg_hdpd
0002af 370f                      	cpi	temp,0x7F
0002b0 f008                      	brlo	dbg_hdp
                                 dbg_hdpd:
0002b1 e20e                      	ldi	temp,'.'
                                 dbg_hdp:
0002b2 def0                      	rcall	uartputc
0002b3 951a                      	dec	temp2
0002b4 f7b9                      	brne	dbg_hd2
0002b5 910f                      	pop	temp
0002b6 df6c
0002b7 000d                      	printnewline
0002b8 9508                      	ret
                                 
                                 .endif
                                 	
                                 ;-----------------------------------------------------------------------
                                 ; Print a line with the 8080/Z80 registers
                                 
                                 printregs:
0002b9 2f04                      	mov	temp,z_flags
0002ba d074                      	rcall	printflags
0002bb df67
0002bc 2020
0002bd 2041
0002be 003d                      	printstring "  A ="
0002bf 2f05                      	mov	temp,z_a
0002c0 df51                      	rcall	printhex	
0002c1 df61
0002c2 4220
0002c3 2043
0002c4 003d                      	printstring " BC ="
                                 #if 1
0002c5 0184                      	movw	temp,z_c
                                 #else
                                 #endif
0002c6 df47                      	rcall	printhexw
0002c7 df5b
0002c8 4420
0002c9 2045
0002ca 003d                      	printstring " DE ="
                                 #if 1
0002cb 0185                      	movw	temp,z_e
                                 #else
                                 #endif
0002cc df41                      	rcall	printhexw
0002cd df55
0002ce 4820
0002cf 204c
0002d0 003d                      	printstring " HL ="
                                 #if 1
0002d1 0186                      	movw	temp,z_l
                                 #else
                                 #endif
0002d2 df3b                      	rcall	printhexw
0002d3 df4f
0002d4 5320
0002d5 3d50
0002d6 0000                      	printstring " SP="
0002d7 0187                      	movw	temp, z_spl
0002d8 df35                      	rcall	printhexw
0002d9 df49
0002da 5020
0002db 3d43
0002dc 0000                      	printstring " PC="
0002dd 018c                      	movw	temp, z_pcl
0002de df2f                      	rcall	printhexw
0002df df43
0002e0 2020
0002e1 2020
0002e2 2020
0002e3 0020                      	printstring "       "
0002e4 01dc                      	movw 	xl,z_pcl
0002e5 940e 0803                 	lcall	dram_read_pp
0002e7 df2a                      	rcall	printhex
0002e8 df3a
0002e9 0020                      	printstring " "
0002ea 940e 0803                 	lcall	dram_read_pp
0002ec df25                      	rcall	printhex
0002ed df35
0002ee 0020                      	printstring " "
0002ef 940e 07e7                 	lcall	dram_read
0002f1 df20                      	rcall	printhex
0002f2 df30
0002f3 0020                      	printstring " "
                                 
                                 #if EM_Z80
0002f4 810e                      	ldd	temp,y+oz_f2
0002f5 d039                      	rcall	printflags
0002f6 df2c
0002f7 2020
0002f8 2761
0002f9 003d                      	printstring "  a'="
0002fa 810f                      	ldd	temp,y+oz_a2
0002fb df16                      	rcall	printhex	
0002fc df26
0002fd 6220
0002fe 2763
0002ff 003d                      	printstring " bc'="
000300 8119                      	ldd	temp2,y+oz_b2
000301 8108                      	ldd	temp,y+oz_c2
000302 df0b                      	rcall	printhexw
000303 df1f
000304 6420
000305 2765
000306 003d                      	printstring " de'="
000307 811b                      	ldd	temp2,y+oz_d2
000308 810a                      	ldd	temp,y+oz_e2
000309 df04                      	rcall	printhexw
00030a df18
00030b 6820
00030c 276c
00030d 003d                      	printstring " hl'="
00030e 811d                      	ldd	temp2,y+oz_h2
00030f 810c                      	ldd	temp,y+oz_l2
000310 defd                      	rcall	printhexw
000311 df11
000312 4920
000313 3d58
000314 0000                      	printstring " IX="
000315 8519                      	ldd	temp2,y+oz_xh
000316 8508                      	ldd	temp,y+oz_xl
000317 def6                      	rcall	printhexw
000318 df0a
000319 4920
00031a 3d59
00031b 0000                      	printstring " IY="
00031c 851b                      	ldd	temp2,y+oz_yh
00031d 850a                      	ldd	temp,y+oz_yl
00031e deef                      	rcall	printhexw
00031f df03
000320 4920
000321 003d                      	printstring " I="
000322 850c                      	ldd	temp,y+oz_i
000323 deee                      	rcall	printhex	
                                 
000324 defe
000325 2020
000326 2020
000327 2020
000328 0020                      	printstring "       "
                                 #endif
000329 9508                      	ret
                                 
                                 
                                 #if EM_Z80
                                 zflags_to_ch:
00032a 5a53
00032b 4820
00032c 5620
00032d 434e
00032e 0000                      	.db	"SZ H VNC",0,0
                                 #else	
                                 #endif
                                 	
                                 printflags:
00032f 931f                      	push	temp2
000330 2f10                      	mov	temp2,temp
000331 def1
000332 000d                      	printnewline
000333 93ef                      	push	zl
000334 93ff                      	push	zh
000335 e5e4
000336 e0f6                      	ldiw	z,zflags_to_ch*2
                                 pr_zfl_next:
000337 9105                      	lpm	temp,z+
000338 2300                      	tst	temp
000339 f039                      	breq	pr_zfl_end
00033a 3200                      	cpi	temp,' '			; Test if no flag
00033b f019                      	breq	pr_zfl_noflag
00033c ff17                      	sbrs	temp2,7			; 
00033d e200                      	 ldi	temp,' '			; Flag not set
00033e de64                      	rcall	uartputc
                                 pr_zfl_noflag:
00033f 1f11                      	rol	temp2
000340 cff6                      	rjmp	pr_zfl_next
                                 pr_zfl_end:
000341 91ff                      	pop	zh
000342 91ef                      	pop	zl	
000343 911f                      	pop	temp2
000344 9508                      	ret
                                 
                                 ; vim:set ts=8 noet nowrap
                                 
                                 	.include "init.asm"
                                 
                                 ;
                                 ;    Copyright (C) 2010 Sprite_tm
                                 ;    Copyright (C) 2010-2013 Leo C.
                                 ;
                                 ;    This file is part of avrcpm.
                                 ;
                                 ;    avrcpm is free software: you can redistribute it and/or modify it
                                 ;    under the terms of the GNU General Public License as published by
                                 ;    the Free Software Foundation, either version 3 of the License, or
                                 ;    (at your option) any later version.
                                 ;
                                 ;    avrcpm is distributed in the hope that it will be useful,
                                 ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
                                 ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                                 ;    GNU General Public License for more details.
                                 ;
                                 ;    You should have received a copy of the GNU General Public License
                                 ;    along with avrcpm.  If not, see <http://www.gnu.org/licenses/>.
                                 ;
                                 ;    $Id: init.asm 241 2015-12-10 09:38:25Z rapid $
                                 ;
                                 
                                 #define REFR_PRE    8           /* timer prescale factor  1/8 */
                                 #define REFR_CS     0x02        /* timer clock select for 1/8 */
                                 #define REFR_CNT    F_CPU / REFR_RATE / REFR_PRE
                                 
                                 	.cseg
                                 regval_tab:
000345 0000                      	.db 0,0
000346 fcfe                      	.db 0xFE,0xFC	; _RAS0  _CAS0
000347 f4f8                      	.db 0xF8,0xF4	; _OE    _WE
000348 00ff                      	.db 255,0	; _255  _0
                                 regval_tab_e:
                                 
                                 start:
000349 ef0f                      	ldi temp,low(RAMEND)	; top of memory; vim:set ts=8 noet nowrap
                                 
00034a bf0d                      	out SPL,temp		; init stack pointer
00034b e008                      	ldi temp,high(RAMEND)	; top of memory
00034c bf0e                      	out SPH,temp		; init stack pointer
                                 
                                 ; - Load some registers with constant values
                                 
00034d e8ea
00034e e0f6                      	ldiw	z,regval_tab*2
00034f e0c0
000350 e0d0                      	ldiw	y,0
000351 91b5                      cp_l:	lpm	xh,z+
000352 93b9                      	st	y+,xh
000353 39e2                      	cpi	zl,low(regval_tab_e*2)
000354 f7e1                      	brne	cp_l
                                 
                                 ; - Kill wdt
                                 
000355 95a8                      	wdr
000356 be74                      	out MCUSR,_0
                                 
000357 e108                      	ldi temp,(1<<WDCE) | (1<<WDE)
000358 9300 0060                 	outm8	WDTCSR,temp
00035a e100                      	ldi temp,(1<<WDCE)
00035b 9300 0060                 	outm8	WDTCSR,temp
                                 
                                 ; - Setup Ports
                                 
                                 ;	ldi 	temp,(1<<PUD)		;disable pullups
                                 ;	outm8	P_PUD,temp
00035d b86b                      	out 	PORTD,_255		;all pins high (enables pullup on input ports)
00035e b865                      	out 	PORTB,_255
00035f b868                      	out 	PORTC,_255
000360 b86a                      	out 	DDRD,_255		; PD all outputs
                                 #if I2C_SUPPORT
000361 ec0f                      	ldi	temp,~((1<<SCL)|(1<<SDA))
000362 b907                      	out	DDRC,temp
                                 #endif
                                 #if DRAM_8BIT
000363 ef0e                      	ldi	temp,~(1<<RXD)
000364 b904                      	out	DDRB,temp
                                 #endif
                                 
000365 9270 006f                 	outm8	TIMSK1,_0
000367 9270 0070                 	outm8	TIMSK2,_0
000369 9270 00b0                 	outm8	TCCR2A,_0
00036b 9270 00b1                 	outm8	TCCR2B,_0
                                 
                                 ; - Clear RAM
                                 
00036d e0e0
00036e e0f1                      	ldiw	z,SRAM_START
00036f e017                      	ldi	temp2,high(ramtop)
                                 clr_loop:
000370 9271                      	st	z+,_0
000371 30ed                      	cpi	zl,low(ramtop)
000372 07f1                      	cpc	zh,temp2
000373 f7e1                      	brne	clr_loop
                                 
                                 ; - Fill unused RAM (stack)
                                 
000374 e019                      	ldi	temp2,high(RAMEND+1)
000375 e50a                      	ldi	temp,SRAMFILL_VAL
                                 fill_loop:
000376 9301                      	st	z+,temp
000377 30e0                      	cpi	zl,low(RAMEND+1)
000378 07f1                      	cpc	zh,temp2
000379 f7e1                      	brne	fill_loop
                                 
                                 ; Init clock/timer system
                                 
                                 ; Init timer 1 as 1 ms system clock tick.
                                 
00037a e200                      	ldi	temp, low (TC_1MS)
00037b e41e                      	ldi	temp2,high(TC_1MS)
00037c 9310 008b                 	outm8	OCR1BH,temp2
00037e 9300 008a                 	outm8	OCR1BL,temp
000380 e801                      	ldi	temp,(1<<ICNC1)|(1<<CS10)	;Noise cancel, fall. edge, Normal Mode, clk/1
000381 9300 0081                 	outm8	TCCR1B,temp
000383 9100 006f                 	inm8	temp,TIMSK1
000385 6004                      	ori	temp,(1<<OCIE1B)		;Enable 1ms int.
000386 9300 006f                 	outm8	TIMSK1,temp
                                 
                                 ; - Init serial port
                                 
000388 dcab                      	rcall	uart_init
                                 
                                 
                                 ;Init timer2. Refresh-call should happen every (8ms/512) cycles.
                                 
000389 e40e                      	ldi	temp,REFR_CNT*2			; 2 cycles per int
00038a 9300 00b3                 	outm8	OCR2A,temp
00038c 9100 00b0                 	inm8	temp,TCCR2A
00038e 6002                      	ori	temp,(1<<WGM21)			;CTC mode
00038f 9300 00b0                 	outm8	TCCR2A,temp
000391 9100 00b1                 	inm8	temp,TCCR2B
000393 6002                      	ori	temp,REFR_CS			;clk/REFR_PRE
000394 9300 00b1                 	outm8	TCCR2B,temp
000396 9100 0070                 	inm8	temp,TIMSK2
000398 6002                      	ori	temp, (1<<OCIE2A)
000399 9300 0070                 	outm8	TIMSK2,temp
00039b 9478                      	sei
                                 
                                 
                                 #if I2C_SUPPORT
00039c d4d2                      	rcall	i2c_init			; Init I2C master
00039d d1c7                      	rcall	rtc_get
                                 #endif
                                 
                                 
                                 .if BOOTWAIT
00039e e00a                      	ldi temp,10
00039f d14c                      	rcall delay_ms
                                 
                                 .endif
                                 
0003a0 de82                      	rcall	printstr
0003a1 0d0d                      	.db	'\r', '\r'
                                 version_string:
0003a2 5043
0003a3 204d
0003a4 6e6f
0003a5 6120
0003a6 206e
0003a7 5641
0003a8 2c52
0003a9 7620
0003aa 2e33
0003ab 2035
0003ac 3272
0003ad 3134
0003ae 004d                      	makestring "CPM on an AVR, v" VERS_STR " r" SVN_REVSTR TESTSTR
                                 
                                 .if MEMTEST
0003af de73
0003b0 000d                      	printnewline
0003b1 de71
0003b2 6554
0003b3 7473
0003b4 6e69
0003b5 2067
0003b6 4152
0003b7 3a4d
0003b8 6620
0003b9 6c69
0003ba 2e6c
0003bb 2e2e
0003bc 0000                      	printstring "Testing RAM: fill..."
                                 
                                 ;Fill RAM
0003bd e0a0
0003be e0b0                      	ldiw	x,0
                                 ramtestw:
0003bf 2f0b                      	mov temp,xh
0003c0 270a                      	eor temp,xl
0003c1 d447                      	rcall	dram_write_pp
0003c2 f7e0                      	brcc ramtestw
0003c3 de5f
0003c4 6177
0003c5 7469
0003c6 2e2e
0003c7 002e                      	printstring "wait..."
                                 
0003c8 e018                      	ldi	temp2,8
                                 ramtestwl:
0003c9 ef0f                      	ldi	temp,255
0003ca d121                      	rcall	delay_ms
0003cb 951a                      	dec	temp2
0003cc f7e1                      	brne	ramtestwl
                                 
0003cd de55
0003ce 6572
0003cf 6572
0003d0 6461
0003d1 2e2e
0003d2 002e                      	printstring "reread..."
                                 
                                 ;re-read RAM
0003d3 e0a0
0003d4 e0b0                      	ldiw	x,0
0003d5 2722                      	clr	temp3			;Error counter
                                 ramtestr:
0003d6 d410                      	rcall	dram_read
                                 
                                 ;	ori	temp,0x04		;simulate error
                                 ;	andi	temp,0xF7		;another error
                                 
0003d7 2f1b                      	mov	temp2,xh
0003d8 271a                      	eor	temp2,xl
0003d9 1701                      	cp	temp,temp2
0003da f131                      	breq	ramtestrok
0003db 2322                      	tst	temp3
0003dc f449                      	brne	ramtestr1
0003dd de45
0003de 000d                      	printnewline
0003df de43
0003e0 6441
0003e1 7264
0003e2 7820
0003e3 2078
0003e4 7979
0003e5 0020                      	printstring "Addr xx yy "
                                 ramtestr1:
0003e6 de3c
0003e7 000d                      	printnewline
0003e8 2fe0                      	mov	zl,temp
0003e9 018d                      	movw	temp,x
0003ea de23                      	rcall	printhexw
0003eb de32                      	rcall	printspace
0003ec 2f0b                      	mov	temp,xh
0003ed 270a                      	eor	temp,xl
0003ee 2f10                      	mov	temp2,temp
0003ef de22                      	rcall	printhex
0003f0 de2d                      	rcall	printspace
0003f1 2f0e                      	mov	temp,zl
0003f2 de1f                      	rcall	printhex
0003f3 de2a                      	rcall	printspace
0003f4 2f01                      	mov	temp,temp2
0003f5 270e                      	eor	temp,zl
0003f6 2301                      	and	temp,temp2
0003f7 d017                      	rcall	printxbits
0003f8 de25                      	rcall	printspace
0003f9 2f01                      	mov	temp,temp2
0003fa 270e                      	eor	temp,zl
0003fb 9510                      	com	temp2
0003fc 2301                      	and	temp,temp2
0003fd d011                      	rcall	printxbits
                                 
0003fe 9523                      	inc	temp3
0003ff 3120                      	cpi	temp3,16		;
000400 f410                      	brsh	ramtestrex
                                 ramtestrok:
000401 9611                      	adiw	xl,1
000402 f698                      	brcc	ramtestr
                                 ramtestrex:
000403 2322                      	tst	temp3			;any errors?
000404 f0c1                      	breq	ramtestend
                                 
000405 de1d
000406 5320
000407 7379
000408 6574
000409 206d
00040a 6168
00040b 746c
00040c 6465
00040d 0021                      	printstring " System halted!"
                                 halted_loop:
00040e cfff                      	rjmp	halted_loop		;keep AVR in an endless loop
                                 
                                 printxbits:
00040f 931f                      	push	temp2
000410 932f                      	push	temp3
000411 2f10                      	mov	temp2,temp
000412 e028                      	ldi	temp3,8
                                 prntxb0:
000413 e20d                      	ldi	temp,'-'
000414 0f11                      	lsl	temp2
000415 f408                      	brcc	prntxb1
000416 e508                      	ldi	temp,'X'
                                 prntxb1:
000417 dd8b                      	rcall	uartPutc
000418 952a                      	dec	temp3
000419 f7c9                      	brne	prntxb0
00041a 912f                      	pop	temp3
00041b 911f                      	pop	temp2
00041c 9508                      	ret
                                 
                                 ramtestend:
                                 
                                 .endif
                                 
                                 .if MEMFILL
00041d e0a0
00041e e0b0                      	ldiw	x,0
00041f e706                      	ldi	temp,MEMFILL_VAL
                                 ramfillw:
000420 d3e8                      	rcall	dram_write_pp
000421 f7f0                      	brcc ramfillw
                                 .endif
                                 
                                 
                                 ;----------------------------------------------------------------------------
                                 
                                 boot_again:
000422 de00
000423 000d                      	printnewline
000424 ddfe
000425 6e49
000426 7469
000427 6e69
000428 2067
000429 6d6d
00042a 2e63
00042b 2e2e
00042c 0000                      	printstring "Initing mmc..."
00042d ddf5
00042e 000d                      	printnewline
00042f 940e 0b5c                 	lcall	mgr_init_partitions
                                 
000431 770f                      	cbr	temp,0x80
000432 f529                      	brne	boot_ipl2
000433 ddef
000434 6f4e
000435 6220
000436 6f6f
000437 6174
000438 6c62
000439 2065
00043a 5043
00043b 4d2f
00043c 6420
00043d 7369
00043e 206b
00043f 6f66
000440 6e75
000441 2164
000442 5020
000443 656c
000444 7361
000445 2065
000446 6863
000447 6e61
000448 6567
000449 4d20
00044a 434d
00044b 532f
00044c 2d44
00044d 6143
00044e 6472
00044f 002e                      	printstring "No bootable CP/M disk found! Please change MMC/SD-Card."
000450 ddd2
000451 000d                      	printnewline
000452 e112                      	ldi	temp2,18
                                 boot_iplwl:
000453 ef0f                      	ldi	temp,255
000454 d097                      	rcall	delay_ms
000455 951a                      	dec	temp2
000456 f7e1                      	brne	boot_iplwl
000457 cfca                      	rjmp	boot_again
                                 
                                 
                                 boot_ipl2:
000458 940e 0bb4                 	lcall	mgr_prnt_parttbl
00045a ddc8
00045b 000d                      	printnewline
00045c ddc6
00045d 6150
00045e 7472
00045f 6e69
000460 7469
000461 6420
000462 6e6f
000463 2e65
000464 0000                      	printstring "Partinit done."
                                 
                                 ; Init (de)blocking buffer
                                 
000465 940e 0de6                 	lcall	dsk_inval_hostbuf
                                 
                                 ; Read first sector of first CP/M partition (ipl)
                                 
000467 e9c5
000468 e0d4                      	ldiw	y,fsys_vars
                                 
                                 ;	Disk 0
000469 8679                      	std	y+o_seekdsk,_0
                                 ;	Track 0
00046a 867a                      	std	y+o_seektrk,  _0
00046b 867b                      	std	y+o_seektrk+1,_0
                                 ; 	Sector 0
00046c 867c                      	std	y+o_seeksec,_0
                                 
                                 ;	Destination
00046d e0a0
00046e e2b0                      	ldiw	x,IPLADDR
00046f 87ae                      	std	y+o_dmaadr+0,xl
000470 87bf                      	std	y+o_dmaadr+1,xh
                                 
000471 e800                      	ldi	temp,1<<READ_FUNC
000472 940e 0dc3                 	lcall	dskDoIt
                                 
                                 ;	lift off
000474 940c 0ed5                 	ljmp z80_init
                                 
                                 
                                 ; vim:set ts=8 noet nowrap
                                 	.include "timer.asm"
                                 
                                 ;
                                 ;    Copyright (C) 2010 Leo C.
                                 ;
                                 ;    This file is part of avrcpm.
                                 ;
                                 ;    avrcpm is free software: you can redistribute it and/or modify it
                                 ;    under the terms of the GNU General Public License as published by
                                 ;    the Free Software Foundation, either version 3 of the License, or
                                 ;    (at your option) any later version.
                                 ;
                                 ;    avrcpm is distributed in the hope that it will be useful,
                                 ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
                                 ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                                 ;    GNU General Public License for more details.
                                 ;
                                 ;    You should have received a copy of the GNU General Public License
                                 ;    along with avrcpm.  If not, see <http://www.gnu.org/licenses/>.
                                 ;
                                 ;    $Id: timer.asm 153 2014-11-12 12:59:42Z rapid $
                                 ;
                                 
                                 	.dseg
                                 
                                 timer_var:
                                 delay_timer1:
                                 .equ ot_timer1	= delay_timer1-timer_var
00020e                           	.byte	1
                                 delay_timer2:
                                 .equ ot_timer2	= delay_timer2-timer_var
00020f                           	.byte	1
                                 timer_base:
                                 timer_ms:
                                 .equ ot_ms	= timer_ms-timer_var
000210                           	.byte	2
                                 timer_sec:
                                 .equ ot_sec	= timer_sec-timer_var
000212                           	.byte	4
                                 
                                 ; don't change order here, clock put/get depends on it.
                                 cntms_out:		; register for ms
000216                           	.byte	2
                                 utime_io:		; register for uptime. 
000218                           	.byte	4	
                                 cnt_1ms:
                                 .equ ot_1ms	= cnt_1ms-timer_var
00021c                           	.byte	2
                                 uptime:
                                 .equ ot_uptime	= uptime-timer_var
00021e                           	.byte	4
                                 timer_top:
                                 .equ timer_size	= timer_top - timer_base
                                 	
                                 .equ utofs	= cnt_1ms-cntms_out
                                 .equ timerofs	= cnt_1ms-timer_ms
                                  
                                 clk_out:
                                 .equ oclk_out	= clk_out-timer_var
000222                           	.byte	7	;
                                 clock:
                                 .equ o_clock	= clock-timer_var
000229                           	.byte	7	;Format (bin): s m h D M YY
                                 .equ clkofs	= clock-clk_out
                                 
                                 	.cseg	
                                 
                                 ; ------------- system timer 1ms ---------------
                                 
                                 
                                 ; Timer/Counter1 Compare Match B interrupt
                                 	
000018 c45d                      	INTERRUPT OC1Baddr
                                 
                                 .if TIMER_DEBUG
                                 .endif	
000476 93ef                      	push    zl
000477 b7ef                      	in      zl,SREG
000478 93ef                      	push    zl
000479 93ff                      	push	zh
00047a 91e0 008a                 	inm8	zl,OCR1BL
00047c 91f0 008b                 	inm8	zh,OCR1BH
00047e 5ee0
00047f 4bf1                      	addiw	z,TC_1MS
000480 93f0 008b                 	outm8	OCR1BH,zh
000482 93e0 008a                 	outm8	OCR1BL,zl
                                 	
000484 93cf                      	push	yl
000485 93df                      	push	yh
000486 e0ce
000487 e0d2                      	ldiw	y,timer_var
                                 
                                 #if DRAM_8BIT	/* Implies software uart */
000488 91e0 0101                 	lds	zl,srx_char_to			;try to decrement character timout
00048a 50e1                      	subi	zl,1
00048b f020                      	brcs	syscl0				;timer was 0 before (not running)
00048c 93e0 0101                 	sts	srx_char_to,zl			;timer is running, store new value
00048e f409                      	brne	syscl0				
00048f dcc9                      	rcall	srx_to
                                 syscl0:
                                 #endif
000490 81e8                      	ldd	zl,y+ot_timer1
000491 50e1                      	subi	zl,1
000492 f008                      	brcs	syscl_t1n
000493 83e8                      	std	y+ot_timer1,zl
                                 syscl_t1n:	
000494 81e9                      	ldd	zl,y+ot_timer2
000495 50e1                      	subi	zl,1
000496 f008                      	brcs	syscl_t2n
000497 83e9                      	std	y+ot_timer2,zl
                                 syscl_t2n:
                                 
000498 85ee                      	ldd     zl,y+ot_1ms			;count milli seconds
000499 85ff                      	ldd     zh,y+ot_1ms+1
00049a 9631                      	adiw	z,1
00049b 87ee                      	std	y+ot_1ms,zl
00049c 87ff                      	std	y+ot_1ms+1,zh
00049d 3ee8                      	cpi	zl,low(1000)			;one second ?
00049e e0e3                      	ldi	zl,high(1000)			;doesn't change flags
00049f 07fe                      	cpc	zh,zl
0004a0 f1f4                      	brlt	syscl_end
                                 ;	brge	syscl_utime
                                 ;	rjmp	syscl_end
                                 
                                 syscl_utime:
0004a1 867e                      	std	y+ot_1ms,_0
0004a2 867f                      	std	y+ot_1ms+1,_0
                                 
0004a3 89e8                      	ldd	zl,y+ot_uptime+0
0004a4 89f9                      	ldd	zh,y+ot_uptime+1
0004a5 9631                      	adiw	z,1
0004a6 8be8                      	std	y+ot_uptime+0,zl
0004a7 8bf9                      	std	y+ot_uptime+1,zh
0004a8 f429                      	brne	syscl_clk
0004a9 89ea                      	ldd	zl,y+ot_uptime+2
0004aa 89fb                      	ldd	zh,y+ot_uptime+3
0004ab 9631                      	adiw	z,1
0004ac 8bea                      	std	y+ot_uptime+2,zl
0004ad 8bfb                      	std	y+ot_uptime+3,zh
                                 
                                 syscl_clk:
0004ae 8deb                      	ldd	zl,y+o_clock+0		;sec
0004af 95e3                      	inc	zl
0004b0 8feb                      	std	y+o_clock+0,zl
0004b1 33ec                      	cpi	zl,60
0004b2 f160                      	brlo	syscl_end
0004b3 8e7b                      	std	y+o_clock+0,_0
0004b4 8dec                      	ldd	zl,y+o_clock+1		;min
0004b5 95e3                      	inc	zl
0004b6 8fec                      	std	y+o_clock+1,zl
0004b7 33ec                      	cpi	zl,60
0004b8 f130                      	brlo	syscl_end
0004b9 8e7c                      	std	y+o_clock+1,_0
0004ba 8ded                      	ldd	zl,y+o_clock+2		;hour
0004bb 95e3                      	inc	zl
0004bc 8fed                      	std	y+o_clock+2,zl
0004bd 31e8                      	cpi	zl,24
0004be f100                      	brlo	syscl_end
                                 
                                 syscl_clk_date:
0004bf 8e7d                      	std	y+o_clock+2,_0
0004c0 930f                      	push	temp
                                 
0004c1 eceb
0004c2 e0f9                      	ldiw	z,dayspm_tab*2 - 1
0004c3 8d0f                      	ldd	temp,y+o_clock+4		;month
0004c4 0fe0                      	add	zl,temp
0004c5 1df7                      	adc	zh,_0
0004c6 91f4                      	lpm	zh,z			;days this month
0004c7 3002                      	cpi	temp,2
0004c8 f421                      	brne	syscl_clknl		;february, may be leap year
0004c9 a1e8                      	ldd	zl,y+o_clock+5		;year
0004ca 70e3                      	andi	zl,0x03
0004cb f409                      	brne	syscl_clknl
0004cc 95f3                      	inc	zh			;leap year 
                                 syscl_clknl:
0004cd 8dee                      	ldd	zl,y+o_clock+3		;day
0004ce 95e3                      	inc	zl
0004cf 8fee                      	std	y+o_clock+3,zl
0004d0 17fe                      	cp	zh,zl
0004d1 f460                      	brsh	syscl_clke
0004d2 e0e1                      	ldi	zl,1
0004d3 8fee                      	std	y+o_clock+3,zl
0004d4 9503                      	inc	temp			;month
0004d5 8f0f                      	std	y+o_clock+4,temp
0004d6 300d                      	cpi	temp,13
0004d7 f030                      	brlo	syscl_clke
                                 
0004d8 8fef                      	std	y+o_clock+4,zl
0004d9 a1e8                      	ldd	zl,y+o_clock+5		;low year
0004da a1f9                      	ldd	zh,y+o_clock+6		;high year
0004db 9631                      	adiw	z,1
0004dc a3e8                      	std	y+o_clock+5,zl
0004dd a3f9                      	std	y+o_clock+6,zh
                                 
                                 syscl_clke:
0004de 910f                      	pop	temp
                                 syscl_end:
0004df 91df                      	pop	yh
0004e0 91cf                      	pop     yl
0004e1 91ff                      	pop	zh
0004e2 91ef                      	pop     zl
0004e3 bfef                      	out     SREG,zl
0004e4 91ef                      	pop     zl
                                 .if TIMER_DEBUG
                                 .endif	
0004e5 9518                      	reti
                                 
                                 ; days per month
                                 
                                 dayspm_tab:
0004e6 1c1f
0004e7 1e1f
0004e8 1e1f                      	.db	31,28,31,30,31,30
0004e9 1f1f
0004ea 1f1e
0004eb 1f1e                      	.db	31,31,30,31,30,31
                                 
                                 ; ----------------------------------------------
                                 ; 	delay
                                 ;
                                 ; wait for temp ms
                                 ;
                                 
                                 delay_ms:
0004ec 9300 020e                 	sts	delay_timer1,temp
                                 dly_loop:
0004ee 9100 020e                 	lds	temp,delay_timer1
0004f0 3000                      	cpi	temp,0
0004f1 f7e1                      	brne	dly_loop
0004f2 9508                      	ret
                                 
                                 ; ----------------------------------------------
                                 ; 
                                 clockget:
0004f3 e2e2
0004f4 e0f2                      	ldiw	z,clk_out
0004f5 2322                      	tst	temp3
0004f6 f021                      	breq	clkget_copy		;lowest byte requestet, latch clock
                                 	
0004f7 0fe2                      	add	zl,temp3
0004f8 1df7                      	adc	zh,_0
0004f9 8100                      	ld	temp,z
                                 clkget_end:
0004fa 9508                      	ret
                                 	
                                 
                                 clkget_copy:
0004fb e027                      	ldi	temp3,7
0004fc 94f8                      	cli
                                 clkget_l:
0004fd 8107                      	ldd	temp,z+clkofs
0004fe 9301                      	st	z+,temp
0004ff 952a                      	dec	temp3
000500 f7e1                      	brne	clkget_l
000501 9478                      	sei
                                 
000502 9112                      	ld	temp2,-z
000503 9102                      	ld	temp, -z
000504 d032                      	rcall	binbcd4
000505 8300                      	std	z+0,temp
000506 8311                      	std	z+1,temp2
000507 e025                      	ldi	temp3,5
                                 clkget_l2:
000508 9102                      	ld	temp,-z	
000509 d022                      	rcall	binbcd2
00050a 8300                      	st	z,temp
00050b 952a                      	dec	temp3
00050c f7d9                      	brne	clkget_l2
                                 
00050d 9100 0222                 	lds	temp,clk_out
00050f 9508                      	ret				;req. byte in temp
                                 
                                 ; ----------------------------------------------
                                 ; 
                                 clockput:
000510 e2e2
000511 e0f2                      	ldiw	z,clk_out
000512 0fe2                      	add	zl,temp3
000513 1df7                      	adc	zh,_0
000514 8300                      	st	z,temp
000515 2322                      	tst	temp3
000516 f009                      	breq	clkput_copy		;lowest byte stored, latch clock
                                 clkput_end:
000517 9508                      	ret
                                 		
                                 
                                 clkput_copy:
000518 e025                      	ldi	temp3,5
                                 clkput_l2:
000519 8100                      	ld	temp,z	
00051a d034                      	rcall	bcdbin2
00051b 9301                      	st	z+,temp
00051c 952a                      	dec	temp3
00051d f7d9                      	brne	clkput_l2
                                 
00051e 8100                      	ldd	temp,z+0
00051f 8111                      	ldd	temp2,z+1
000520 d039                      	rcall	bcdbin4
000521 9301                      	st	z+,temp
000522 9311                      	st	z+,temp2
                                 
000523 e027                      	ldi	temp3,7
000524 94f8                      	cli
                                 clkput_l:
000525 9102                      	ld	temp,-z
000526 8307                      	std	z+clkofs,temp
000527 952a                      	dec	temp3
000528 f7e1                      	brne	clkput_l
000529 9478                      	sei
                                 #if I2C_SUPPORT
00052a d07b                      	rcall	rtc_set			; set hardware clock
                                 #endif
00052b 9508                      	ret
                                 
                                 
                                 ; ----------------------------------------------
                                 
                                 ; convert binary to bcd
                                 ; (only range 0 - 99)
                                 
                                 binbcd2:
00052c 931f                      	push	temp2
00052d e01a                      	ldi	temp2,10
00052e 2c06                      	mov	_tmp0,_255
                                 tobcd_l:
00052f 9403                      	inc	_tmp0
000530 1b01                      	sub	temp,temp2
000531 f7e8                      	brcc	tobcd_l
000532 0f01                      	add	temp,temp2
000533 9402                      	swap	_tmp0
000534 0d00                      	add	temp,_tmp0
000535 911f                      	pop	temp2
000536 9508                      	ret
                                 	
                                 
                                 binbcd4:
000537 e120                      	ldi	temp3,16
000538 0108                      	movw	_tmp0,temp
000539 2700                      	clr	temp
00053a 2711                      	clr	temp2
                                 binbcd4l:
00053b 0c00                      	lsl	_tmp0
00053c 1c11                      	rol	_tmp1
00053d 1f00                      	rol	temp
00053e 1f11                      	rol	temp2
00053f 952a                      	dec	temp3
000540 f069                      	breq	binbcd4e
                                 
000541 5f1d                      	subi	temp2,-0x03
000542 ff13                      	sbrs	temp2,3
000543 5013                      	subi	temp2,0x03
000544 5d10                      	subi	temp2,-0x30
000545 ff17                      	sbrs	temp2,7
000546 5310                      	subi	temp2,0x30
000547 5f0d                      	subi	temp,-0x03
000548 ff03                      	sbrs	temp,3
000549 5003                      	subi	temp,0x03
00054a 5d00                      	subi	temp,-0x30
00054b ff07                      	sbrs	temp,7
00054c 5300                      	subi	temp,0x30
00054d cfed                      	rjmp	binbcd4l
                                 
                                 binbcd4e:
00054e 9508                      	ret
                                 
                                 ; convert bcd to binary
                                 
                                 bcdbin2:
00054f 931f                      	push	temp2
000550 2f10                      	mov	temp2,temp		;temp2 = high digit
000551 9512                      	swap	temp2
000552 701f                      	andi	temp2,0x0f
000553 700f                      	andi	temp,0x0f		;temp  = low digit
000554 2e01                      	mov	r0,temp2
000555 e01a                      	ldi	temp2,10
000556 9d10                      	mul	temp2,r0		;high digit * 10
000557 0d00                      	add	temp,r0			;high digit * 10 + low digit
000558 911f                      	pop	temp2
000559 9508                      	ret
                                 
                                 bcdbin4:
00055a dff4                      	rcall	bcdbin2
00055b 930f                      	push	temp
00055c 2f01                      	mov	temp,temp2
00055d dff1                      	rcall	bcdbin2
00055e e614                      	ldi	temp2,100
00055f 9f01                      	mul	temp,temp2
000560 910f                      	pop	temp
000561 2d11                      	mov	temp2,r1
000562 0d00                      	add	temp,r0
000563 1d17                      	adc	temp2,_0
000564 9508                      	ret
                                 
                                 
                                 #if I2C_SUPPORT
                                 
                                 ; ----------------------------------------------
                                 ; Set software clock from hardware clock
                                 
                                 rtc_get:
000565 927f                      	push	_0			;Placeholder for month/weekday
000566 927f                      	push	_0			;day/year
000567 927f                      	push	_0			;hours
000568 927f                      	push	_0			;minutes
000569 e100                      	ldi	temp,0x10		;register address
00056a 930f                      	push	temp			;save reg adr/placeholder for sec
00056b b7fe                      	in	zh,sph
00056c b7ed                      	in	zl,spl
00056d ea00                      	ldi	temp,0xA0		;PCF8583 slave address
00056e 930f                      	push	temp
                                 
00056f e012                      	ldi	temp2,2
000570 d31f                      	rcall	i2c_write
000571 e013                      	ldi	temp2,3
000572 d339                      	rcall	i2c_read		;get year (stored in RTC-RAM addr. 10h)
000573 7003                      	andi	temp,0x3
000574 f151                      	breq	rtc_get_e		;i2c error
                                 
000575 8121                      	ldd	temp3,z+1		;save year
000576 81a2                      	ldd	xl,   z+2
                                 
000577 e012                      	ldi	temp2,2			;register pointer. 2 = secs
000578 8311                      	std	z+1,temp2
000579 d316                      	rcall	i2c_write
00057a e016                      	ldi	temp2,6
00057b d330                      	rcall	i2c_read
00057c 7003                      	andi	temp,0x3
00057d f109                      	breq	rtc_get_e		;i2c error
                                 
00057e 2f1a                      	mov	temp2,xl		;year century
00057f 8104                      	ldd	temp,z+4		;get year
000580 1f00                      	rol	temp
000581 1f00                      	rol	temp
000582 1f00                      	rol	temp
000583 2702                      	eor	temp,temp3
000584 7003                      	andi	temp,0x03
000585 f011                      	breq	rtc_get_1
000586 5f2f                      	subi    temp3, low(-1)  
000587 4f1f                      	sbci    temp2, high(-1)
                                 rtc_get_1:
000588 e2a9
000589 e0b2                      	ldiw	x,clock
00058a 94f8                      	cli
                                 
00058b 8101                      	ldd	temp,z+1		;get seconds
00058c dfc2                      	rcall	bcdbin2
00058d 930d                      	st	x+,temp
00058e 8102                      	ldd	temp,z+2		;get minutes
00058f dfbf                      	rcall	bcdbin2
000590 930d                      	st	x+,temp
000591 8103                      	ldd	temp,z+3		;get hours
000592 dfbc                      	rcall	bcdbin2
000593 930d                      	st	x+,temp
000594 8104                      	ldd	temp,z+4		;get day
000595 730f                      	andi	temp,0x3f
000596 dfb8                      	rcall	bcdbin2
000597 930d                      	st	x+,temp
000598 8105                      	ldd	temp,z+5		;get months
000599 710f                      	andi	temp,0x1f
00059a dfb4                      	rcall	bcdbin2
00059b 930d                      	st	x+,temp			;store month
00059c 932d                      	st	x+,temp3		;store year
00059d 931d                      	st	x+,temp2		;store year century
00059e 9478                      	sei
                                 
                                 rtc_get_e:
00059f 910f                      	pop	temp
0005a0 910f                      	pop	temp
0005a1 910f                      	pop	temp
0005a2 910f                      	pop	temp
0005a3 910f                      	pop	temp
0005a4 910f                      	pop	temp
0005a5 9508                      	ret
                                 
                                 ;----------------------------------------------
                                 ; Set hardware clock from software clock
                                 ; 
                                 ; Register:	temp2:	s
                                 ;		temp3:	m
                                 ;		xh:	h
                                 ;		xl:	D
                                 ;		temp:	M
                                 ;		yl:	Yl
                                 ;		yh:	Yh
                                 
                                 rtc_set:
0005a6 e2e9
0005a7 e0f2                      	ldiw	z,clock
0005a8 94f8                      	cli
0005a9 8110                      	ldd	temp2,z+0		;sec
0005aa 8121                      	ldd	temp3,z+1		;min
0005ab 81b2                      	ldd	xh,z+2			;hours
0005ac 81a3                      	ldd	xl,z+3			;day
0005ad 8104                      	ldd	temp,z+4		;month
0005ae 81c5                      	ldd	yl,z+5			;yearl
0005af 81d6                      	ldd	yh,z+6			;yearh
0005b0 9478                      	sei
0005b1 df7a                      	rcall	binbcd2
0005b2 930f                      	push	temp			;-1 save month
0005b3 2f0a                      	mov	temp,xl
0005b4 df77                      	rcall	binbcd2
0005b5 2fac                      	mov	xl,yl			;   least significant 2 bits of year
0005b6 95a2                      	swap	xl
0005b7 0faa                      	lsl	xl
0005b8 0faa                      	lsl	xl
0005b9 7ca0                      	andi	xl,0xc0
0005ba 2b0a                      	or	temp,xl			;   combine with day
0005bb 930f                      	push	temp			;-2 save year/day
0005bc 2f0b                      	mov	temp,xh
0005bd df6e                      	rcall	binbcd2
0005be 930f                      	push	temp			;-3 save hours
0005bf 2f02                      	mov	temp,temp3
0005c0 df6b                      	rcall	binbcd2
0005c1 930f                      	push	temp			;-4 save min
0005c2 2f01                      	mov	temp,temp2
0005c3 df68                      	rcall	binbcd2
0005c4 930f                      	push	temp			;-5 save sec
                                 
0005c5 927f                      	push	_0			;-6 1/10s, 1/100s
0005c6 e804                      	ldi	temp,0x84		;   stop count, alarm enable
0005c7 930f                      	push	temp			;-7
0005c8 927f                      	push	_0			;-8 register address
0005c9 b7fe                      	in	zh,sph
0005ca b7ed                      	in	zl,spl
0005cb ea00                      	ldi	temp,0xA0		;   PCF8583 slave address
0005cc 930f                      	push	temp			;(-9)
                                 
0005cd e019                      	ldi	temp2,9
0005ce d2c1                      	rcall	i2c_write
0005cf e004                      	ldi	temp,0x04		;enable counting
0005d0 8302                      	std	z+2,temp
0005d1 e013                      	ldi	temp2,3
0005d2 d2bd                      	rcall	i2c_write
0005d3 83d3                      	std	z+3,yh			;store year in RTC RAM
0005d4 83c2                      	std	z+2,yl
0005d5 e100                      	ldi	temp,0x10
0005d6 8301                      	std	z+1,temp
0005d7 e014                      	ldi	temp2,4
0005d8 d2b7                      	rcall	i2c_write
                                 
0005d9 5fe8
0005da 4fff                      	addiw	z,8			;remove buffer from stack
0005db 94f8                      	cli
0005dc bfed                      	out	spl,zl
0005dd 9478                      	sei
0005de bffe                      	out	sph,zh
                                 
0005df 9508                      	ret
                                 #endif /* I2C_SUPPORT */
                                 
                                 ; ----------------------------------------------
                                 ; 
                                 
                                 utimeget:
0005e0 ef0f                      	ldi	temp,0xFF
0005e1 e1e6
0005e2 e0f2                      	ldiw	z,cntms_out
0005e3 5021                      	subi	temp3,1
0005e4 f020                      	brcs	utimget_end		;Rel. port number = 0 ? (controlport)
0005e5 f021                      	breq	utimget_copy		;lowest byte requestet, latch clock
                                 	
0005e6 0fe2                      	add	zl,temp3
0005e7 1df7                      	adc	zh,_0
0005e8 8100                      	ld	temp,z
                                 utimget_end:
0005e9 9508                      	ret
                                 	
                                 utimget_copy:
0005ea e016                      	ldi	temp2,6
0005eb 94f8                      	cli
                                 utimget_l:
0005ec 8106                      	ldd	temp,z+utofs
0005ed 9301                      	st	z+,temp
0005ee 951a                      	dec	temp2
0005ef f7e1                      	brne	utimget_l
0005f0 9478                      	sei
0005f1 9100 0216                 	lds	temp,cntms_out
                                 					;req. byte in temp
0005f3 9508                      	ret
                                 
                                 utimeput:
0005f4 5021                      	subi	temp3,1
0005f5 f460                      	brcc	utput__1
                                 	
                                 	; clock control
                                 
0005f6 3001                      	cpi	temp,starttimercmd
0005f7 f0d9                      	breq	timer_start		;timer_ms
0005f8 3002                      	cpi	temp,quitTimerCmd
0005f9 f031                      	breq	utput_quit		;
0005fa 300f                      	cpi	temp,printTimerCmd
0005fb f109                      	breq	timer_print		;timer_ms
0005fc 3100                      	cpi	temp,uptimeCmd
0005fd f409                      	brne	utcp_ex
0005fe c05e                      	rjmp	uptime_print		;cnt_1ms
                                 utcp_ex:
0005ff 9508                      	ret	
                                 	
                                 utput_quit:
000600 d01c                      	rcall	timer_print
000601 c011                      	rjmp	timer_start
                                 
                                 utput__1:
000602 e1e6
000603 e0f2                      	ldiw	z,cntms_out
000604 f021                      	breq	utput__copy		;lowest byte requestet, latch clock
                                 	
000605 0fe2                      	add	zl,temp3
000606 1df7                      	adc	zh,_0
000607 8300                      	st	z,temp
000608 9508                      	ret
                                 		
                                 utput__copy:
000609 8300                      	st	z,temp
00060a 9635                      	adiw	z,5
00060b e016                      	ldi	temp2,6
00060c 94f8                      	cli
                                 utput__l:
00060d 8106                      	ldd	temp,z+utofs
00060e 9301                      	st	z+,temp
00060f 951a                      	dec	temp2
000610 f7e1                      	brne	utput__l
000611 9478                      	sei
000612 9508                      	ret
                                 
                                 ; start/reset timer
                                 ;
                                 timer_start:
000613 e1e0
000614 e0f2                      	ldiw	z,timer_ms
000615 e016                      	ldi	temp2,6
000616 94f8                      	cli
                                 ts_loop:
000617 8504                      	ldd	temp,z+timerofs
000618 9301                      	st	z+,temp
000619 951a                      	dec	temp2
00061a f7e1                      	brne	ts_loop
00061b 9478                      	sei
00061c 9508                      	ret
                                 
                                 
                                 ; print timer
                                 ;
                                 	
                                 timer_print:
00061d 92ff                      	push	r15		;
00061e 92ef                      	push	r14		;
00061f 93df                      	push	yh
000620 93cf                      	push	yl
000621 e1e0
000622 e0f2                      	ldiw	z,timer_ms
                                 
                                 ; put ms on stack (16 bit)
                                 
000623 94f8                      	cli
000624 85c4                      	ldd	yl,z+timerofs
000625 9111                      	ld	temp2,z+
000626 1bc1                      	sub	yl,temp2
000627 85d4                      	ldd	yh,z+timerofs
000628 9111                      	ld	temp2,z+
000629 0bd1                      	sbc	yh,temp2
00062a f418                      	brsh	tp_s
                                 	
00062b 51c8
00062c 4fdc                      	addiw	y,1000
00062d 9408                      	sec	
                                 tp_s:
00062e 93df                      	push	yh
00062f 93cf                      	push	yl
                                 
000630 8504                      	ldd	temp,z+timerofs
000631 91c1                      	ld	yl,z+
000632 0b0c                      	sbc	temp,yl
                                 
000633 8514                      	ldd	temp2,z+timerofs
000634 91d1                      	ld	yh,z+
000635 0b1d                      	sbc	temp2,yh
                                 
000636 84e4                      	ldd	r14,z+timerofs
000637 91c1                      	ld	yl,z+
000638 0aec                      	sbc	r14,yl
                                 
000639 9478                      	sei
00063a 84f4                      	ldd	r15,z+timerofs
00063b 91d1                      	ld	yh,z+
00063c 0afd                      	sbc	r15,yh
                                 	
00063d dbe5
00063e 000d                      	printnewline
00063f dbe3
000640 6954
000641 656d
000642 2072
000643 7572
000644 6e6e
000645 6e69
000646 2e67
000647 4520
000648 616c
000649 7370
00064a 6465
00064b 203a
00064c 0000                      	printstring "Timer running. Elapsed: "
00064d db90                      	rcall	print_ultoa
                                 
00064e dbd4
00064f 002e                      	printstring "."
000650 910f                      	pop	temp
000651 911f                      	pop	temp2
000652 24ee                      	clr	r14
000653 24ff                      	clr	r15
000654 db89                      	rcall	print_ultoa
000655 dbcd
000656 2e73
000657 0000                      	printstring "s."
                                 
000658 91cf                      	pop	yl
000659 91df                      	pop	yh
00065a 90ef                      	pop	r14
00065b 90ff                      	pop	r15
00065c 9508                      	ret
                                 	
                                 uptime_print:
00065d 92ff                      	push	r15
00065e 92ef                      	push	r14
00065f e1ec
000660 e0f2                      	ldiw	z,cnt_1ms
000661 94f8                      	cli
000662 9101                      	ld	temp,z+
000663 930f                      	push	temp
000664 9101                      	ld	temp,z+
000665 930f                      	push	temp
                                 	
000666 9101                      	ld	temp,z+
000667 9111                      	ld	temp2,z+
000668 90e1                      	ld	r14,z+
000669 9478                      	sei
00066a 90f1                      	ld	r15,z+
                                 	
00066b dbb7
00066c 000d                      	printnewline
00066d dbb5
00066e 7055
00066f 6974
000670 656d
000671 203a
000672 0000                      	printstring "Uptime: "
                                 	
000673 db6a                      	rcall	print_ultoa
000674 dbae
000675 002c                      	printstring ","
                                 
000676 24ee                      	clr	r14
000677 24ff                      	clr	r15
000678 911f                      	pop	temp2
000679 910f                      	pop	temp
00067a db63                      	rcall print_ultoa
00067b dba7
00067c 2e73
00067d 0000                      	printstring "s."
                                 
00067e 90ef                      	pop	r14
00067f 90ff                      	pop	r15
000680 9508                      	ret
                                 
                                 ; vim:set ts=8 noet nowrap
                                 
                                 	.include "heap.asm"
                                 
                                 ;
                                 ;    Copyright (C) 2010 Leo C.
                                 ;
                                 ;    This file is part of avrcpm.
                                 ;
                                 ;    avrcpm is free software: you can redistribute it and/or modify it
                                 ;    under the terms of the GNU General Public License as published by
                                 ;    the Free Software Foundation, either version 3 of the License, or
                                 ;    (at your option) any later version.
                                 ;
                                 ;    avrcpm is distributed in the hope that it will be useful,
                                 ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
                                 ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                                 ;    GNU General Public License for more details.
                                 ;
                                 ;    You should have received a copy of the GNU General Public License
                                 ;    along with avrcpm.  If not, see <http://www.gnu.org/licenses/>.
                                 ;
                                 ;    $Id: heap.asm 93 2014-01-03 16:32:32Z rapid $
                                 ;
                                 
                                 
                                 	.dseg
000230                           hp_top: .byte	2
                                 
                                 	.cseg
                                 
                                 .if HEAP_DEBUG
                                 .endif		
                                 
                                 
                                 ; Init heap
                                 ; temp:temp2 = first free memory location (heap start)
                                 
                                 heap_init:
                                 .if HEAP_DEBUG
                                 .endif		
                                 heap_release:
                                 .if HEAP_DEBUG
                                 .endif		
000681 9300 0230                 	sts	hp_top,temp
000683 9310 0231                 	sts	hp_top+1,temp2
                                 .if HEAP_DEBUG
                                 .endif		
000685 9508                      	ret
                                 
                                 ; Get memory block from heap.
                                 ; temp2:temp = size of block
                                 ; return temp2:temp = pointer to allocated block
                                 ; return 0 if not enough space
                                 
                                 heap_get:
000686 92ff                      	push	r15
000687 92ef                      	push	r14
                                 .if HEAP_DEBUG
                                 .endif		
000688 90e0 0230                 	lds	r14,hp_top
00068a 90f0 0231                 	lds	r15,hp_top+1
00068c 0d0e                      	add	temp,r14
00068d 1d1f                      	adc	temp2,r15
00068e f030                      	brcs	hp_full
                                 		
                                 ; zero flag clear here
                                 
00068f 9300 0230                 	sts	hp_top,temp
000691 9310 0231                 	sts	hp_top+1,temp2
000693 0187                      	movw	temp,r14
000694 c002                      	rjmp	hp_get_ex
                                 hp_full:
000695 2700                      	clr	temp
000696 2711                      	clr	temp2		;(sets zero flag)
                                 hp_get_ex:
                                 .if HEAP_DEBUG
                                 .endif
000697 90ef                      	pop	r14
000698 90ff                      	pop	r15
000699 9508                      	ret
                                 
                                 
                                 ; vim:set ts=8 noet nowrap
                                 				
                                 	.include "mmc.asm"
                                 
                                 ;
                                 ;    Copyright (C) 2010 Leo C.
                                 ;
                                 ;    This file is part of avrcpm.
                                 ;
                                 ;    avrcpm is free software: you can redistribute it and/or modify it
                                 ;    under the terms of the GNU General Public License as published by
                                 ;    the Free Software Foundation, either version 3 of the License, or
                                 ;    (at your option) any later version.
                                 ;
                                 ;    avrcpm is distributed in the hope that it will be useful,
                                 ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
                                 ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                                 ;    GNU General Public License for more details.
                                 ;
                                 ;    You should have received a copy of the GNU General Public License
                                 ;    along with avrcpm.  If not, see <http://www.gnu.org/licenses/>.
                                 ;
                                 ;    $Id: mmc.asm 93 2014-01-03 16:32:32Z rapid $
                                 ;
                                 
                                 /* Definitions for MMC/SDC command */
                                 #define CMD0	(0)		/* GO_IDLE_STATE */
                                 #define CMD1	(1)		/* SEND_OP_COND (MMC) */
                                 #define	ACMD41	(0x80+41)	/* SEND_OP_COND (SDC) */
                                 #define CMD8	(8)		/* SEND_IF_COND */
                                 #define CMD9	(9)		/* SEND_CSD */
                                 #define CMD10	(10)		/* SEND_CID */
                                 #define CMD12	(12)		/* STOP_TRANSMISSION */
                                 #define ACMD13	(0x80+13)	/* SD_STATUS (SDC) */
                                 #define CMD16	(16)		/* SET_BLOCKLEN */
                                 #define CMD17	(17)		/* READ_SINGLE_BLOCK */
                                 #define CMD18	(18)		/* READ_MULTIPLE_BLOCK */
                                 #define CMD23	(23)		/* SET_BLOCK_COUNT (MMC) */
                                 #define	ACMD23	(0x80+23)	/* SET_WR_BLK_ERASE_COUNT (SDC) */
                                 #define CMD24	(24)		/* WRITE_BLOCK */
                                 #define CMD25	(25)		/* WRITE_MULTIPLE_BLOCK */
                                 #define CMD55	(55)		/* APP_CMD */
                                 #define CMD58	(58)		/* READ_OCR */
                                 
                                 /* Disk Status Bits (masks) (DSTATUS) */
                                 #define MMCST_NOINIT	0x01	/* Drive not initialized */
                                 #define MMCST_NODISK	0x02	/* No medium in the drive */
                                 #define MMCST_PROTECT	0x04	/* Write protected */
                                 
                                 /* Card type flags (masks) (CardType) */
                                 #define CT_MMC		0x01	/* MMC ver 3 */
                                 #define CT_SD1		0x02	/* SD ver 1 */
                                 #define CT_SD2		0x04	/* SD ver 2 */
                                 #define CT_SDC	(CT_SD1|CT_SD2)	/* SD */
                                 #define CT_BLOCK	0x08	/* Block addressing */
                                 
                                 #define	RES_OK 		0	/* 0: Successful */
                                 #define	RES_ERROR	1	/* 1: R/W Error */
                                 #define	RES_WRPRT	2	/* 2: Write Protected */
                                 #define	RES_NOTRDY	3	/* 3: Not Ready */
                                 #define	RES_PARERR	4	/* 4: Invalid Parameter */
                                 
                                 
                                 #define SPI_MODE_0	(0<<CPOL)|(0<<CPHA)
                                 #define SPI_MODE_1	(0<<CPOL)|(1<<CPHA)
                                 #define SPI_MODE_2	(1<<CPOL)|(0<<CPHA)
                                 #define SPI_MODE_3	(1<<CPOL)|(1<<CPHA)
                                 #define SPI_MODE	SPI_MODE_0
                                 
                                 ;------------------------------------------------
                                 ; 
                                 .macro	spi_clkslow
                                 .if MMC_DEBUG > 1
                                 	printstring	"SPI_CLK_SLOW "
                                 .endif
                                 	ldi	temp,SPI_MODE|(1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0)	;clk/128
                                 	out	SPCR,temp
                                 	out	SPSR,_0
                                 .endm
                                 
                                 ;------------------------------------------------
                                 ; 
                                 .macro	spi_clkfast
                                 .if MMC_DEBUG > 1
                                 	printstring	"SPI_CLK_FAST "
                                 .endif
                                 	ldi	temp,SPI_MODE|(1<<SPE)|(1<<MSTR)			;clk/4
                                 	out	SPCR,temp
                                 #if MMC_SPI2X
                                 	ldi	temp,(1<<SPI2X)
                                 	out	SPSR,temp
                                 #else
                                 #endif
                                 .endm
                                 
                                 ;------------------------------------------------
                                 ; 
                                 .macro	spi_disable
                                 .if MMC_DEBUG > 1
                                 	printstring	"SPI_DISABLE "
                                 .endif
                                 	out	SPCR,_0
                                 .endm
                                 
                                 
                                 ;------------------------------------------------
                                 ;
                                 .macro	spi_waitm
                                 	.set	spiwl_ = PC
                                 	sbism8	SPSR,SPIF
                                 	rjmp	spiwl_
                                 .endm
                                 
                                 ;------------------------------------------------
                                 
                                 	.dseg
                                 
                                 mmcStat:
000232                           	.byte	1
                                 mmcCardType:
000233                           	.byte	1
                                 
                                 
                                 	.cseg
                                 
                                 ;------------------------------------------------
                                 ; Multiply 32 bit value in yh,yl,xh,xl by 512
                                 
                                 mul_yx_512:
00069a 2fdc                      	mov	yh,yl
00069b 2fcb                      	mov	yl,xh
00069c 2fba                      	mov	xh,xl
00069d e0a0                      	ldi	xl,0
00069e 0fbb                      	lsl	xh
00069f 1fcc                      	rol	yl
0006a0 1fdd                      	rol	yh
0006a1 9508                      	ret
                                 		
                                 ;------------------------------------------------
                                 spi_rcvr:
0006a2 bc6e                      	out	SPDR,_255
                                 spi_rcvr_l:
0006a3 b40d
0006a4 fe07                      	sbism8 SPSR,SPIF
0006a5 cffd                      	rjmp	spi_rcvr_l
0006a6 b50e                      	in	temp,SPDR
                                 .if MMC_DEBUG > 2
                                 .endif
0006a7 9508                      	ret
                                 
                                 ;------------------------------------------------
                                 spi_xmit:
                                 .if MMC_DEBUG > 2
                                 .endif
0006a8 bd0e                      	out	SPDR,temp
                                 					;fall thru
                                 spi_wait:	
0006a9 b40d
0006aa fe07                      	sbism8	SPSR,SPIF
0006ab cffd                      	rjmp	spi_wait
0006ac 9508                      	ret
                                 	
                                 ;------------------------------------------------
                                 ; Wait for card ready 
                                 ;	return  1:OK, 0:Timeout 
                                 
                                 mmcWaitReady:
0006ad 931f                      	push	temp2
0006ae e012                      	ldi	temp2,2			;Wait for ready in timeout of 500ms.
0006af dff2                      	rcall	spi_rcvr
                                 mmc_wrl:
0006b0 9260 020f                 	sts	delay_timer2,_255
                                 mmc_wrl1:
0006b2 dfef                      	rcall	spi_rcvr
0006b3 1506                      	cp	temp,_255
0006b4 f411                      	brne	mmc_wrl2
0006b5 e001                      	ldi	temp,1
0006b6 c006                      	rjmp	mmc_wrbreak
                                 
                                 mmc_wrl2:
0006b7 9100 020f                 	lds	temp,delay_timer2
0006b9 3000                      	cpi	temp,0
0006ba f7b9                      	brne	mmc_wrl1
0006bb 951a                      	dec	temp2
0006bc f799                      	brne	mmc_wrl		;tmp is 0 here
                                 
                                 mmc_wrbreak:
0006bd 911f                      	pop	temp2	
0006be 2300                      	tst	temp		;set flags
0006bf 9508                      	ret
                                 
                                 
                                 ;------------------------------------------------
                                 ; Deselect the card and release SPI bus
                                 ;	return 0
                                 
                                 mmcDeselect:
0006c0 9a2a                      	sbi	P_MMC_CS,mmc_cs		; CS high
0006c1 dfe0                      	rcall	spi_rcvr
0006c2 2700                      	clr	temp
0006c3 9508                      	ret
                                 
                                 ;------------------------------------------------
                                 ; Select the card and wait for ready 
                                 ;	return 255:Successful, 0:Timeout
                                 
                                 mmcSelect:
0006c4 982a                      	cbi	P_MMC_CS,mmc_cs		; CS low
0006c5 dfe7                      	rcall	mmcWaitReady
0006c6 f3c9                      	breq	mmcDeselect		;return via Deselect
0006c7 6f0f                      	sbr	temp,255
0006c8 9508                      	ret
                                 	
                                 
                                 ;------------------------------------------------
                                 ; Send a command packet to MMC 
                                 ; 	temp2:	Command
                                 ;       yh..xl:	Argument
                                 ;  return:
                                 ;	temp:	0 = ok, no error
                                 ;	z-flag	1 = ok, no error
                                 ;
                                 
                                 mmcCmd:
0006c9 ff17                      	sbrs	temp2,7
0006ca c013                      	rjmp	mmc_cmddo
                                 
                                 ; ACMD<n> is the command sequence of CMD55-CMD<n>	
                                 	
0006cb 93df                      	push	yh
0006cc 93cf                      	push	yl
0006cd 93bf                      	push	xh
0006ce 93af                      	push	xl
0006cf 931f                      	push	temp2
0006d0 e0c0
0006d1 e0d0                      	ldiw	y,0
0006d2 01de                      	movw	x,y
0006d3 e317                      	ldi	temp2,CMD55
0006d4 dff4                      	rcall	mmcCmd
0006d5 911f                      	pop	temp2
0006d6 91af                      	pop	xl
0006d7 91bf                      	pop	xh
0006d8 91cf                      	pop	yl
0006d9 91df                      	pop	yh
                                 
0006da 3002                      	cpi	temp,2
0006db f010                      	brlo	mmc_cmddo		; fall thru, if (retval <= 1)
                                 	
0006dc 2300                      	tst	temp
0006dd 9508                      	ret				; else return error
                                 
                                 ; Select the card and wait for ready
                                 
                                 mmc_cmddo:
                                 .if MMC_DEBUG
                                 .endif
0006de dfe1                      	rcall	mmcDeselect
0006df dfe4                      	rcall	mmcSelect
0006e0 f411                      	brne	mmc_cmd_p
                                 
0006e1 ef0f                      	ldi	temp,0xFF
0006e2 c01e                      	rjmp	mmc_cmdexit
                                 	
                                 ; Send command packet
                                 
                                 mmc_cmd_p:
0006e3 2f01                      	mov	temp,temp2
0006e4 770f                      	cbr	temp,0x80
0006e5 6400                      	sbr	temp,0x40
0006e6 dfc1                      	rcall	spi_xmit
0006e7 bdde                      	out	SPDR,yh
0006e8 dfc0                      	rcall	spi_wait
0006e9 bdce                      	out	SPDR,yl
0006ea dfbe                      	rcall	spi_wait
0006eb bdbe                      	out	SPDR,xh
0006ec dfbc                      	rcall	spi_wait
0006ed bdae                      	out	SPDR,xl
0006ee dfba                      	rcall	spi_wait
                                 	
0006ef e905                      	ldi	temp,0x95		;CRC for CMD0(0)
0006f0 3010                      	cpi	temp2,CMD0
0006f1 f021                      	breq	mmc_cmdxcrc
0006f2 e807                      	ldi	temp,0x87		;CRC for CMD8(0x1AA) 
0006f3 3018                      	cpi	temp2,CMD8
0006f4 f009                      	breq	mmc_cmdxcrc
0006f5 e001                      	ldi	temp,0x01		;Dummy CRC + Stop
                                 mmc_cmdxcrc:
                                 .if MMC_DEBUG
                                 .endif
0006f6 dfb1                      	rcall	spi_xmit
                                 
                                 ; Receive command response
                                 
0006f7 301c                      	cpi	temp2,CMD12		; Skip a stuff byte when stop reading
0006f8 f409                      	brne	mmc_cmdres
0006f9 dfa8                      	rcall	spi_rcvr
                                 	
                                 ; Wait for a valid response in timeout of 10 attempts
                                 
                                 mmc_cmdres:
0006fa 931f                      	push	temp2
0006fb e01a                      	ldi	temp2,10
                                 mmc_cmdrl:
0006fc dfa5                      	rcall	spi_rcvr
0006fd ff07                      	sbrs	temp,7
0006fe c002                      	rjmp	mmc_cmdexit
0006ff 951a                      	dec	temp2
000700 f7d9                      	brne	mmc_cmdrl
                                 
                                 ; Return with  response value
                                 
                                 mmc_cmdexit:
000701 911f                      	pop	temp2
                                 .if MMC_DEBUG
                                 .endif
000702 2300                      	tst	temp			;set flags
000703 9508                      	ret
                                 	
                                 ;------------------------------------------------
                                 ; Send command and receive ocr response
                                 ; 	temp2:	Command, zl: expected cmd response
                                 ;       yh..xl:	Argument
                                 ;	return: yh..xl: ocr, z flag == 1, if return from mmcCmd was ok.
                                 
                                 mmcCmd_ocr:
                                 
000704 dfc4                      	rcall	mmcCmd
                                 
000705 170e                      	cp	temp,zl			;
000706 f439                      	brne	mmc_cocr_e
                                 
                                 ; Get trailing return value of R7 response
                                 
000707 e014                      	ldi	temp2,4
000708 e1ea
000709 e0f0                      	ldiw	z,0x1a			;memory address of xl
                                 mmc_cocr1:
00070a df97                      	rcall	spi_rcvr
00070b 9301                      	st	z+,temp
00070c 951a                      	dec	temp2
00070d f7e1                      	brne	mmc_cocr1
                                 					;z-flag =1
                                 mmc_cocr_e:
00070e 9508                      	ret
                                 
                                 ;------------------------------------------------
                                 ; Check if 1 sec timeout
                                 ;	return Z-Flag set, if timeout
                                 
                                 mmc_timeout_1s:
00070f 9100 020e                 	lds	temp,delay_timer1
000711 2300                      	tst	temp
000712 f429                      	brne	mmc_ttex
000713 95fa                      	dec	zh
000714 f019                      	breq	mmc_ttex
000715 e604                      	ldi	temp,100
000716 9300 020e                 	sts	delay_timer1,temp
                                 mmc_ttex:
000718 9508                      	ret
                                 
                                 
                                 ;------------------------------------------------
                                 ;       "Public" functions
                                 ;------------------------------------------------
                                 
                                 ;------------------------------------------------
                                 ; Initialize MMC/SD card
                                 
                                 mmcInit:
                                 .if MMC_DEBUG 
                                 .endif
000719 9100 0232                 	lds	temp,mmcStat		;Set 'NO INIT' status
00071b 6001                      	sbr	temp,MMCST_NOINIT
00071c 9300 0232                 	sts	mmcStat,temp
                                 
00071e e503
00071f bd0c
000720 bc7d                      	spi_clkslow
000721 e01a                      	ldi	temp2,10
                                 mmci_lp:
000722 df7f                      	rcall	spi_rcvr
000723 951a                      	dec	temp2			;80 dummy clocks
000724 f7e9                      	brne	mmci_lp
                                 
000725 e020                      	ldi	temp3,0			;Card type
000726 e010                      	ldi	temp2,CMD0
000727 e0c0
000728 e0d0                      	ldiw	y,0
000729 01de                      	movw	x,y
00072a df9e                      	rcall	mmcCmd			;Enter Idle state
00072b 3001                      	cpi	temp,1
00072c f009                      	breq	mmci_1
00072d c03a                      	rjmp	mmci_lend
                                 mmci_1:	
00072e e0fa                      	ldi	zh,10			;Initialization timeout of 1000 ms.
00072f e604                      	ldi	temp,100
000730 9300 020e                 	sts	delay_timer1,temp
000732 e018                      	ldi	temp2,CMD8
000733 e0c0
000734 e0d0                      	ldiw	y,0
000735 e0b1                      	ldi	xh,0x01
000736 eaaa                      	ldi	xl,0xAA
000737 e0e1                      	ldi	zl,1
000738 dfcb                      	rcall	mmcCmd_ocr
000739 f4b9                      	brne	mmci_sdv1		;SDv2?
                                 
00073a 30c1                      	cpi	yl,0x01			;ocr[2]
00073b f4a9                      	brne	mmci_sdv1
00073c 3ada                      	cpi	yh,0xAA			;ocr[3]
00073d f499                      	brne	mmci_sdv1
                                 
                                 ; The card can work at vdd range of 2.7-3.6V.
                                 ; Wait for leaving idle state (ACMD41 with HCS bit).
                                 	
00073e ea19                      	ldi	temp2,ACMD41
00073f e4d0                      	ldi	yh,0x40
000740 e0c0                      	ldi	yl,0
000741 e0b0                      	ldi	xh,0
000742 e0a0                      	ldi	xl,0
                                 mmci_v2l2:
000743 df85                      	rcall	mmcCmd
000744 f019                      	breq	mmci_ccc
000745 dfc9                      	rcall	mmc_timeout_1s
000746 f7e1                      	brne	mmci_v2l2
000747 c008                      	rjmp	mmci_sdv2end
                                 	
                                 ; Check CCS bit in the OCR
                                 mmci_ccc:
000748 e31a                      	ldi	temp2,CMD58
000749 e0d0                      	ldi	yh,0
00074a e0e0                      	ldi	zl,0
00074b dfb8                      	rcall	mmcCmd_ocr
                                 
00074c f419                      	brne	mmci_sdv2end
                                 
00074d 6024                      	sbr	temp3,CT_SD2
00074e fda6                      	sbrc	xl,6
00074f 6028                      	sbr	temp3,CT_BLOCK
                                 
                                 mmci_sdv2end:
000750 c017                      	rjmp	mmci_lend
                                 	
                                 ; SDv1 or MMCv3
                                 
                                 mmci_sdv1:
000751 ea19                      	ldi	temp2,ACMD41
000752 e0c0
000753 e0d0                      	ldiw	y,0
000754 01de                      	movw	x,y
000755 df73                      	rcall	mmcCmd	
000756 3002                      	cpi	temp,2
000757 f418                      	brsh	mmci_mmcv3
000758 6022                      	sbr	temp3,CT_SD1		;SDv1
000759 ea19                      	ldi	temp2,ACMD41
00075a c002                      	rjmp	mmci_v1_l
                                 mmci_mmcv3:
00075b 6021                      	sbr	temp3,CT_MMC		;MMCv3
00075c e011                      	ldi	temp2,CMD1
                                 
                                 ; Wait for leaving idle state
                                 mmci_v1_l:
00075d df6b                      	rcall	mmcCmd
00075e f019                      	breq	mmci_v1_2
00075f dfaf                      	rcall	mmc_timeout_1s
000760 f7e1                      	brne	mmci_v1_l
000761 c006                      	rjmp	mmci_lend		;Timeout
                                 	
                                 ; Set R/W block length to 512
                                 mmci_v1_2:
000762 e110                      	ldi	temp2,CMD16		
000763 e0a0
000764 e0b2                      	ldiw	x,512
000765 df63                      	rcall	mmcCmd
000766 f009                      	breq	mmci_lend
000767 e020                      	ldi	temp3,0
                                 	
                                 mmci_lend:
000768 9320 0233                 	sts	mmcCardType,temp3
00076a df55                      	rcall	mmcDeselect
                                 	
                                 ; Initialization succeded?
                                 
00076b 9100 0232                 	lds	temp,mmcStat
00076d 2322                      	tst	temp3
00076e f019                      	breq	mmci_lex
00076f 7f0e                      	cbr	temp,MMCST_NOINIT	;Yes, clear 'NO INIT' status
000770 9300 0232                 	sts	mmcStat,temp
                                 mmci_lex:
                                 
                                 .if MMC_DEBUG
                                 .endif
                                 
000772 bc7c                      	spi_disable
000773 9508                      	ret
                                 	
                                 ;--------------------------------------------------------------
                                 
                                 	.equ	MMC_RDOP   = 0		;Read Operation
                                 	.equ	MMC_RDWORD = 1		;Read Word (FAT entry)
                                 
                                 ;--------------------------------------------------------------
                                 
                                 mmcReadSect:
                                 
                                 .if MMC_DEBUG > 1
                                 .endif
000774 e001                      	ldi	temp,(1<<MMC_RDOP)
000775 c003                      	rjmp	mmc_rw_common
                                 
                                 mmcReadWord:
                                 
                                 .if (MMC_DEBUG > 1) || (MMC_DEBUG_RDW > 0)
                                 .endif
000776 e003                      	ldi	temp,(1<<MMC_RDOP) | (1<<MMC_RDWORD) 
000777 c001                      	rjmp	mmc_rw_common
                                 
                                 mmcWriteSect:
                                 
                                 .if MMC_DEBUG > 1
                                 .endif
000778 e000                      	ldi	temp,0
                                 
                                 mmc_rw_common:
000779 932f                      	push	temp3
00077a 2f20                      	mov	temp3,temp
00077b 9100 0232                 	lds	temp,mmcStat
00077d e013                      	ldi	temp2,RES_NOTRDY
00077e fd00                      	sbrc	temp,log2(MMCST_NOINIT)
00077f c064                      	 rjmp	mmc_rwexit_2
                                 	
000780 e500
000781 bd0c
000782 e001
000783 bd0d                      	spi_clkfast
000784 9100 0233                 	lds	temp,mmcCardType
000786 ff03                      	sbrs	temp,log2(CT_BLOCK)
000787 df12                      	 rcall	mul_yx_512		;Convert to byte address  (*512)
                                 	
000788 fd20                      	sbrc	temp3,MMC_RDOP
000789 e111                      	 ldi	temp2,CMD17
00078a ff20                      	sbrs	temp3,MMC_RDOP
00078b e118                      	 ldi	temp2,CMD24
00078c df3c                      	rcall	mmcCmd
00078d f009                      	breq	mmc_rw_1
00078e c052                      	rjmp	mmc_rwexit_error
                                 
                                 mmc_rw_1:
00078f e0c0
000790 e0d2                      	ldiw	y,512
000791 ff20                      	sbrs	temp3,MMC_RDOP
000792 c03a                      	 rjmp	mmc_wroper
                                 
                                 ;-------------------------------------------------------------------------------
                                 ; Receive a data packet from MMC
                                 
000793 ec08                      	ldi	temp,200		;Wait for data packet in timeout of 200ms.
000794 9300 020e                 	sts	delay_timer1,temp
                                 mmc_rcv_wl:
000796 df0b                      	rcall	spi_rcvr
000797 1506                      	cp	temp,_255
000798 f421                      	brne	mmc_rcv_start
000799 9000 020e                 	lds	_tmp0,delay_timer1
00079b 1407                      	cp	_tmp0,_0
00079c f7c9                      	brne	mmc_rcv_wl
                                 .if MMC_DEBUG > 1
                                 .endif
                                 
                                 mmc_rcv_start:
                                 .if MMC_DEBUG > 1
                                 .endif
00079d 3f0e                      	cpi	temp,0xFE		;If not valid data token, 
00079e f009                      	breq	mmc_rw_2
00079f c041                      	rjmp	mmc_rwexit_error
                                 mmc_rw_2:
                                 
0007a0 df01                      	rcall	spi_rcvr		;Shift in first byte.
                                 .if MMC_DEBUG > 3
                                 .endif
0007a1 bc6e                      	out	SPDR,_255		;Start shift in next byte.
                                 
0007a2 ff21                      	sbrs	temp3,MMC_RDWORD
0007a3 c01b                      	 rjmp	mmc_rcv_readloop
                                 
                                 ; discard x-1 bytes
                                 
                                 mmc_rcvw_rl:
0007a4 9721                      	sbiw	yl,1
0007a5 f119                      	breq	mmc_rcv_rlend
0007a6 15e7                      	cp	zl,_0
0007a7 05f7                      	cpc	zh,_0
0007a8 f039                      	breq	mmc_rcvw_sto
                                 
0007a9 9731                      	sbiw	zl,1
0007aa b40d
0007ab fe07
0007ac cffd                      	spi_waitm
0007ad b50e                      	in	temp,SPDR
0007ae bc6e                      	out	SPDR,_255
0007af cff4                      	rjmp	mmc_rcvw_rl
                                 
                                 ; read next two bytes
                                 
                                 mmc_rcvw_sto:
0007b0 2fe0                      	mov 	zl,temp
0007b1 b40d
0007b2 fe07
0007b3 cffd                      	spi_waitm
0007b4 b50e                      	in	temp,SPDR
0007b5 bc6e                      	out	SPDR,_255
0007b6 2ff0                      	mov 	zh,temp
                                 
                                 .if MMC_DEBUG_RDW > 0
                                 .endif
                                 
                                 ; discard the rest
                                 
                                 mmc_rcvw_rl2:
0007b7 9721                      	sbiw	yl,1
0007b8 f081                      	breq	mmc_rcv_rlend
0007b9 b40d
0007ba fe07
0007bb cffd                      	spi_waitm
0007bc b50e                      	in	temp,SPDR
0007bd bc6e                      	out	SPDR,_255
0007be cff8                      	rjmp	mmc_rcvw_rl2
                                 
                                 ; read sector, store in buffer
                                 
                                 mmc_rcv_readloop:
0007bf 9721                      	sbiw	yl,1
0007c0 f039                      	breq	mmc_rcv_rle
0007c1 9301                      	st	z+,temp
0007c2 b40d
0007c3 fe07
0007c4 cffd                      	spi_waitm
0007c5 b50e                      	in	temp,SPDR
                                 .if MMC_DEBUG > 3
                                 .endif
0007c6 bc6e                      	out	SPDR,_255
0007c7 cff7                      	rjmp	mmc_rcv_readloop
                                 
                                 mmc_rcv_rle:
0007c8 9301                      	st	z+,temp			;Store last byte in buffer 
                                 mmc_rcv_rlend:
                                 .if MMC_DEBUG > 3
                                 .endif
0007c9 dedf                      	rcall	spi_wait		;while SPI module shifts in crc part1.
0007ca ded7                      	rcall	spi_rcvr		;Read second crc.
                                 	
0007cb e010                      	ldi	temp2,RES_OK		;Return success
0007cc c015                      	rjmp	mmc_rwexit
                                 
                                 	
                                 ;-------------------------------------------------------------------------------
                                 ; Send a data packet to MMC
                                 
                                 mmc_wroper:
                                 
                                 .if MMC_DEBUG > 2
                                 .endif
0007cd dedf                      	rcall	mmcWaitReady
0007ce f091                      	breq	mmc_rwexit_error
                                 
0007cf ef0e                      	ldi	temp,0xFE		;Data token
0007d0 bd0e                      	out	SPDR,temp
                                 mmc_x_loop:
0007d1 9101                      	ld	temp,z+
0007d2 b40d
0007d3 fe07
0007d4 cffd                      	spi_waitm
0007d5 bd0e                      	out	SPDR,temp
0007d6 9721                      	sbiw	yl,1
0007d7 f7c9                      	brne	mmc_x_loop
                                 	
0007d8 ded0                      	rcall	spi_wait
0007d9 ef0f                      	ldi	temp,0xFF		;dummy crc
0007da decd                      	rcall	spi_xmit
0007db decc                      	rcall	spi_xmit
0007dc dec5                      	rcall	spi_rcvr
                                 .if MMC_DEBUG > 2
                                 .endif
0007dd 710f                      	andi	temp,0x1F		;If not accepted, return with error
0007de 3005                      	cpi	temp,0x05
0007df e010                      	ldi	temp2,RES_OK		;Return success
0007e0 f009                      	breq	mmc_rwexit
                                 
                                 mmc_rwexit_error:
0007e1 e011                      	ldi	temp2,RES_ERROR
                                 mmc_rwexit:
0007e2 dedd                      	rcall	mmcDeselect
0007e3 bc7c                      	spi_disable
                                 mmc_rwexit_2:
0007e4 2f01                      	mov	temp,temp2
                                 
                                 .if MMC_DEBUG > 1
                                 .endif
0007e5 912f                      	pop	temp3
0007e6 9508                      	ret
                                 
                                 ;--------------------------------------------------------------
                                 ; vim:set ts=8 noet nowrap
                                 
                                 
                                 #if DRAM_8BIT			/* Implies software uart */
                                 	.include "dram-8bit.asm"
                                 
                                 ; This is part of the Z80-CP/M emulator written by Sprite_tm.
                                 
                                 ;    Copyright (C) 2010 Leo C.
                                 
                                 ;    This file is part of avrcpm.
                                 ;
                                 ;    avrcpm is free software: you can redistribute it and/or modify it
                                 ;    under the terms of the GNU General Public License as published by
                                 ;    the Free Software Foundation, either version 3 of the License, or
                                 ;    (at your option) any later version.
                                 ;
                                 ;    avrcpm is distributed in the hope that it will be useful,
                                 ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
                                 ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                                 ;    GNU General Public License for more details.
                                 ;
                                 ;    You should have received a copy of the GNU General Public License
                                 ;    along with avrcpm.  If not, see <http://www.gnu.org/licenses/>.
                                 ;
                                 ;    $Id: dram-8bit.asm 93 2014-01-03 16:32:32Z rapid $
                                 ;
                                 
                                 	.cseg
                                 
                                 ; ------------------ DRAM routines -------------
                                 
                                 ;Loads the byte on address xh:xl into temp.
                                 ;must not alter xh:xl
                                 
                                 dram_read:
                                 ;	cli				;
0007e7 b9bb                      	out	PORTD,xh		;1
0007e8 b828                      	out	PORTC,_RAS0		;1
0007e9 b9ab                      	out	PORTD,xl		;1
0007ea b838                      	out	PORTC,_CAS0		;1
0007eb b87a                      	out	DDRD,_0			;1
0007ec b848                      	out	PORTC,_OE		;1
0007ed c000                      	rjmp	PC+1			;2
0007ee 0000                      	dram_wait DRAM_WAITSTATES	;
0007ef b109                      	in	temp,PIND		;1
0007f0 b868                      	out	PORTC,_255		;1
0007f1 b86a                      	out	DDRD,_255		;1
                                 ;	sei				;
0007f2 9508                      	ret
                                 
                                 
                                 
                                 ;Writes the byte in temp to  xh:xl
                                 ;must not alter xh:xl
                                 
                                 dram_write:
                                 ;	cli
0007f3 b9bb                      	out	PORTD,xh		;1
0007f4 b828                      	out	PORTC,_RAS0		;1
0007f5 b9ab                      	out	PORTD,xl		;1
0007f6 b838                      	out	PORTC,_CAS0		;1
0007f7 b90b                      	out	PORTD,temp		;1
0007f8 b858                      	out	PORTC,_WE		;1
0007f9 b868                      	out	PORTC,_255		;1  = 7
                                 ;	sei
0007fa 9508                      	ret
                                 
                                 ; -------------------------------------------------------------------
                                 
                                 dram_readw_pp:
0007fb dfeb                      	rcall	dram_read
0007fc 9611                      	adiw	x,1
0007fd 930f                      	push	temp
0007fe dfe8                      	rcall	dram_read
0007ff 9611                      	adiw	x,1
000800 2f10                      	mov	temp2,temp
000801 910f                      	pop	temp
000802 9508                      	ret
                                 	
                                 dram_read_pp:
000803 dfe3                      	rcall	dram_read
000804 9611                      	adiw	x,1
000805 9508                      	ret
                                 
                                 ; -------------------------------------------------------------------
                                 
                                 dram_writew_pp:
000806 dfec                      	rcall	dram_write
000807 9611                      	adiw	x,1
000808 2f01                      	mov	temp,temp2
                                 dram_write_pp:
000809 dfe9                      	rcall	dram_write
00080a 9611                      	adiw	x,1
00080b 9508                      	ret
                                 
                                 
                                 ; -------------------------------------------------------------------
                                 ; vim:set ts=8 noet nowrap
                                 
                                 #else				/* 4 bit RAM, hardware uart */
                                 #endif
                                 #if DRAM_8BIT			/* Implies software uart */
                                 	.include "i2c.asm"
                                 
                                 ; This is part of the Z80-CP/M emulator written by Sprite_tm.
                                 ;
                                 ;    Copyright (C) 2013 Leo C.
                                 ;
                                 ;    This file is part of avrcpm.
                                 ;
                                 ;    avrcpm is free software: you can redistribute it and/or modify it
                                 ;    under the terms of the GNU General Public License as published by
                                 ;    the Free Software Foundation, either version 3 of the License, or
                                 ;    (at your option) any later version.
                                 ;
                                 ;    avrcpm is distributed in the hope that it will be useful,
                                 ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
                                 ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                                 ;    GNU General Public License for more details.
                                 ;
                                 ;    You should have received a copy of the GNU General Public License
                                 ;    along with avrcpm.  If not, see <http://www.gnu.org/licenses/>.
                                 ;
                                 ;    $Id$
                                 ;
                                 
                                 #if I2C_SUPPORT
                                 
                                 
                                 /* General TWI Master status codes */
                                 #define TWI_START                  0x08  /* START has been transmitted */
                                 #define TWI_REP_START              0x10  /* Repeated START has been transmitted */
                                 #define TWI_ARB_LOST               0x38  /* Arbitration lost */
                                 
                                 /* TWI Master Transmitter status codes */
                                 #define TWI_MTX_ADR_ACK            0x18  /* SLA+W has been transmitted and ACK received */
                                 #define TWI_MTX_ADR_NACK           0x20  /* SLA+W has been transmitted and NACK received */
                                 #define TWI_MTX_DATA_ACK           0x28  /* Data byte has been transmitted and ACK received */
                                 #define TWI_MTX_DATA_NACK          0x30  /* Data byte has been transmitted and NACK received */
                                 
                                 /* TWI Master Receiver status codes */
                                 #define TWI_MRX_ADR_ACK            0x40  /* SLA+R has been transmitted and ACK received */
                                 #define TWI_MRX_ADR_NACK           0x48  /* SLA+R has been transmitted and NACK received */
                                 #define TWI_MRX_DATA_ACK           0x50  /* Data byte has been received and ACK transmitted */
                                 #define TWI_MRX_DATA_NACK          0x58  /* Data byte has been received and NACK transmitted */
                                 
                                 /* TWI Miscellaneous status codes */
                                 #define TWI_NO_STATE               0xF8  /* No relevant state information available */
                                 #define TWI_BUS_ERROR              0x00  /* Bus error due to an illegal START or STOP condition */
                                 
                                 
                                 #define I2C_BR ((F_CPU / (2 * I2C_CLOCK)) - 8) /* I2C Bit Rate */
                                 
                                 ;----------------------------------------------------------------------
                                 ;
                                 ; TWINT: TWI Interrupt Flag
                                 ; TWEA:  TWI Enable Acknowledge Bit
                                 ; TWSTA: TWI START Condition Bit
                                 ; TWSTO: TWI STOP Condition Bit
                                 ; TWEN:  TWI Enable Bit
                                 ; TWIE:  TWI Interrupt Enable
                                 ;
                                 ; 	(1<<TWEN)|(1<<TWIE)|(1<<TWINT)
                                 ; 	(1<<TWEN)|(1<<TWIE)|(1<<TWINT)|           (1<<TWEA)
                                 ; 	(1<<TWEN)|(1<<TWIE)|(1<<TWINT)
                                 ;
                                 ; default:
                                 ; 	(1<<TWEN)|          (1<<TWINT)|           (1<<TWSTO)
                                 ;
                                 ; Init:
                                 ; 	(1<<TWEN)
                                 ;
                                 ; start read/write:
                                 ; 	(1<<TWEN)|(1<<TWIE)|(1<<TWINT)|(1<<TWSTA)
                                 ; 	(1<<TWEN)|(1<<TWIE)|(1<<TWINT)|(1<<TWSTA)
                                 ; 	(1<<TWEN)|(1<<TWIE)|(1<<TWINT)|(1<<TWSTA)
                                 ; 	(1<<TWEN)|(1<<TWIE)|(1<<TWINT)|(1<<TWSTA)
                                 ;
                                 ; wait ready:
                                 ; 	 (1<<TWIE)|(1<<TWSTO)
                                 ;
                                 ;----------------------------------------------------------------------
                                 ;
                                 ;i2c_result
                                 ;
                                 ;	0b10000000	Busy (Transmission in progress)
                                 ;	0b01000000	Timeout
                                 ;	0b00010000	Read after Write
                                 ;	0b00001000	Start transmitted
                                 ;	0b00000100	Slave acknowledged address
                                 ;	0b00000010	Data byte(s) transmitted/received
                                 ;	0b00000001	Transmission completed
                                 ;
                                 ;
                                 ;----------------------------------------------------------------------
                                 
                                 	.dseg
                                 
                                 i2c_var:
                                 i2ci_idx:
000234                           	.byte	1
                                 i2c_result:
000235                           	.byte	1
                                 i2c_txcnt:
000236                           	.byte	1
                                 i2c_rxcnt:
000237                           	.byte	1
                                 i2c_buf:
000238                           	.byte	I2C_BUFSIZE
                                 
                                 	.equ oi2ci_idx   = 0
                                 	.equ oi2c_result = 1
                                 	.equ oi2c_txcnt  = 2
                                 	.equ oi2c_rxcnt  = 3
                                 	.equ oi2c_buf    = 4
                                 
                                 ;------------------------------------------------------------------
                                 
                                 	.cseg
                                 
                                 
000030 c7db                      	INTERRUPT TWIaddr
                                 
00080c 930f                      	push	temp
00080d b70f                      	in	temp,sreg
00080e 930f                      	push	temp
00080f 9100 00b9                 	inm8	temp,TWSR
                                 .if I2C_STATE_DEBUG
                                 .endif
000811 931f                      	push	temp2
000812 932f                      	push	temp3
000813 93ff                      	push	zh
000814 93ef                      	push	zl
                                 
000815 e3e4
000816 e0f2                      	ldiw	z,i2c_var
000817 8110                      	ldd	temp2,z+oi2ci_idx
000818 8121                      	ldd	temp3,z+oi2c_result
                                 
000819 3008                      	cpi	temp,TWI_START
00081a f081                      	breq	i2ci_START
00081b 3100                      	cpi	temp,TWI_REP_START
00081c f069                      	breq	i2ci_REP_START
00081d 3108                      	cpi	temp,TWI_MTX_ADR_ACK
00081e f079                      	breq	i2ci_MTX_ADR_ACK
00081f 3208                      	cpi	temp,TWI_MTX_DATA_ACK
000820 f079                      	breq	i2ci_MTX_DATA_ACK
000821 3300                      	cpi	temp,TWI_MTX_DATA_NACK
000822 f0c9                      	breq	i2ci_MTX_DATA_NACK
000823 3400                      	cpi	temp,TWI_MRX_ADR_ACK
000824 f109                      	breq	i2ci_MRX_ADR_ACK
000825 3500                      	cpi	temp,TWI_MRX_DATA_ACK
000826 f109                      	breq	i2ci_MRX_DATA_ACK
000827 3508                      	cpi	temp,TWI_MRX_DATA_NACK
000828 f179                      	breq	i2ci_MRX_DATA_NACK
                                 
000829 c035                      	rjmp	i2ci_default
                                 
                                 i2ci_REP_START:					;Repeated START has been transmitted
00082a 7e2f                      	cbr	temp3,0b00010000
                                 i2ci_START:					;START has been transmitted
00082b 2711                      	clr	temp2					;reset buffer index
00082c 6828                      	ori	temp3,0b10001000
00082d c003                      	rjmp	i2ci_11
                                 i2ci_MTX_ADR_ACK:				;SLA+W has been transmitted and ACK received
00082e 6024                      	ori	temp3,0b00000100
00082f c001                      	rjmp	i2ci_11
                                 i2ci_MTX_DATA_ACK:				;Data byte has been transmitted and ACK received
000830 6022                      	ori	temp3,0b00000010
                                 i2ci_11:
000831 8102                      	ldd	temp,z+oi2c_txcnt
000832 1710                      	cp	temp2,temp				;all bytes transmited?
000833 f440                      	brsh	i2ci_12					; yes
000834 0fe1                      	add	zl,temp2
000835 1df7                      	adc	zh,_0
000836 9513                      	inc	temp2
000837 8104                      	ldd	temp,z+oi2c_buf				;next byte
000838 9300 00bb                 	outm8	TWDR,temp
00083a e805                      	ldi	temp,(1<<TWEN)|(1<<TWIE)|(1<<TWINT)
00083b c025                      	rjmp	i2ci_end
                                 
                                 i2ci_MTX_DATA_NACK:				;Data byte has been transmitted and NACK received
                                 i2ci_12:
00083c 6021                      	ori	temp3,0b00000001			;tx complete
00083d ff24                      	sbrs	temp3,4					;Read after Write?
00083e c020                      	rjmp	i2ci_default				;  no, stop transceiver
                                 
00083f 9100 0238                 	lds	temp,i2c_buf
000841 6001                      	sbr	temp,0x01				;<SLA+R>
000842 9300 0238                 	sts	i2c_buf,temp
000844 ea05                      	ldi	temp,(1<<TWEN)|(1<<TWIE)|(1<<TWINT)|(1<<TWSTA)
000845 c01b                      	rjmp	i2ci_end
                                 
                                 i2ci_MRX_ADR_ACK:				;SLA+R has been transmitted and ACK received
000846 6024                      	ori	temp3,0b00000100
000847 c007                      	rjmp	i2ci_31
                                 
                                 i2ci_MRX_DATA_ACK:				;Data byte has been received and ACK transmitted
000848 6022                      	ori	temp3,0b00000010
000849 0fe1                      	add	zl,temp2
00084a 1df7                      	adc	zh,_0
00084b 9513                      	inc	temp2
00084c 9100 00bb                 	inm8	temp,TWDR
00084e 8304                      	std	z+oi2c_buf,temp
                                 i2ci_31:
00084f 9100 0237                 	lds	temp,i2c_rxcnt
000851 950a                      	dec	temp
000852 1710                      	cp	temp2,temp
000853 f410                      	brsh	i2ci_32
000854 ec05                      	ldi	temp,(1<<TWEN)|(1<<TWIE)|(1<<TWINT)|(1<<TWEA)
000855 c00b                      	rjmp	i2ci_end
                                 i2ci_32:
000856 e805                      	ldi	temp,(1<<TWEN)|(1<<TWIE)|(1<<TWINT)
000857 c009                      	rjmp	i2ci_end
                                 
                                 i2ci_MRX_DATA_NACK:				;Data byte has been received and NACK transmitted
000858 6023                      	ori	temp3,0b00000011			;rx complete
000859 0fe1                      	add	zl,temp2
00085a 1df7                      	adc	zh,_0
00085b 9513                      	inc	temp2
00085c 9100 00bb                 	inm8	temp,TWDR
00085e 8304                      	std	z+oi2c_buf,temp
                                 ;	fall thru
                                 
                                 i2ci_default:
00085f 772f                      	andi	temp3,~0b10000000
000860 e904                      	ldi	temp,(1<<TWEN)|(0<<TWIE)|(1<<TWINT)|(1<<TWSTO)
                                 
                                 i2ci_end:
000861 9300 00bc                 	outm8	TWCR,temp
000863 9320 0235                 	sts	i2c_result,temp3
000865 9310 0234                 	sts	i2ci_idx,temp2
000867 91ef                      	pop	zl
000868 91ff                      	pop	zh
000869 912f                      	pop	temp3
00086a 911f                      	pop	temp2
                                 
                                 .if I2C_STATE_DEBUG
                                 .endif
                                 
00086b 910f                      	pop	temp
00086c bf0f                      	out	sreg,temp
00086d 910f                      	pop	temp
00086e 9518                      	reti
                                 
                                 ;------------------------------------------------------------------
                                 
                                 i2c_init:
00086f 9270 00bc                 	outm8	TWCR,_0				;Disable TWI, disable TWI interrupt.
                                 						;(Reset TWI hardware state machine.)
000871 e202                      	ldi	temp,(5 * TC_1US+3)/3		;1  Delay 5 us
                                 i2c_iwl:					;
000872 950a                      	dec	temp				;1
000873 f7f1                      	brne	i2c_iwl				;2
                                 
000874 e50c                      	ldi	temp,I2C_BR
000875 9300 00b8                 	outm8	TWBR,temp
000877 9260 00bb                 	outm8	TWDR,_255			;
000879 e004                      	ldi	temp,(1<<TWEN)			;Enable TWI, disable TWI interrupt.
00087a 9300 00bc                 	outm8	TWCR,temp
                                 
                                 ;	sts	i2c_result,_0
                                 
00087c 9508                      	ret
                                 
                                 ;------------------------------------------------------------------
                                 
                                 i2c_waitready:
                                 
00087d e10e                      	ldi	temp,30
00087e 9300 020e                 	sts	delay_timer1,temp
                                 i2c_wrl:
000880 9100 00bc                 	inm8	temp,TWCR
000882 7101                      	andi	temp,(1<<TWIE)|(1<<TWSTO)
000883 f031                      	breq	i2c_wre
000884 9100 020e                 	lds	temp,delay_timer1
000886 2300                      	tst	temp
000887 f7c1                      	brne	i2c_wrl
                                 
000888 dfe6                      	rcall	i2c_init
                                 
000889 e400                      	ldi	temp,0b01000000
                                 
                                 i2c_wre:
00088a 9000 0235                 	lds	_tmp0,i2c_result
00088c 2900                      	or	temp,_tmp0
00088d 9300 0235                 	sts	i2c_result,temp
00088f 9508                      	ret
                                 
                                 ;------------------------------------------------------------------
                                 ;
                                 ; 	z:	Pointer to the data to write.
                                 ;		First byte is slave address
                                 ;	temp2:	Number of bytes to write including address byte.
                                 ;
                                 
                                 i2c_write:
                                 
000890 dfec                      	rcall	i2c_waitready
000891 3400                      	cpi	temp,0b01000000
000892 f4c0                      	brsh	i2c_we
000893 93ff                      	push	zh
000894 93ef                      	push	zl
000895 93df                      	push	yh
000896 93cf                      	push	yl
                                 
000897 e3c4
000898 e0d2                      	ldiw	y,i2c_var
000899 e800                      	ldi	temp,0b10000000
00089a 8309                      	std	y+oi2c_result,temp		;result = busy
00089b 831a                      	std	y+oi2c_txcnt,temp2		;store size
00089c 9624                      	adiw	y,oi2c_buf
00089d 9101                      	ld	temp,z+				;get SLA
00089e 7f0e                      	cbr	temp,0x01			;
                                 i2c_wl:
00089f 9309                      	st	y+,temp
0008a0 951a                      	dec	temp2
0008a1 f011                      	breq	i2c_wle
0008a2 9101                      	ld	temp,z+
0008a3 cffb                      	rjmp	i2c_wl
                                 i2c_wle:
                                 	; Enable TWI, TWI int and initiate start condition
0008a4 ea05                      	ldi	temp,(1<<TWEN)|(1<<TWIE)|(1<<TWINT)|(1<<TWSTA)
0008a5 9300 00bc                 	outm8	TWCR,temp
                                 
0008a7 91cf                      	pop	yl
0008a8 91df                      	pop	yh
0008a9 91ef                      	pop	zl
0008aa 91ff                      	pop	zh
                                 i2c_we:
0008ab 9508                      	ret
                                 
                                 
                                 ;------------------------------------------------------------------
                                 ;
                                 ; 	z:	Pointer to data buffer.
                                 ;		First byte of buffer is slave address
                                 ;	temp2:	Buffer len. (Number of bytes to read + address byte.)
                                 ;
                                 ;	temp:	return (fail < 0, else succsess)
                                 
                                 i2c_read:
0008ac dfd0                      	rcall	i2c_waitready
0008ad 3400                      	cpi	temp,0b01000000
0008ae f4e0                      	brsh	i2c_re
                                 
0008af 93ff                      	push	zh
0008b0 93ef                      	push	zl
0008b1 93df                      	push	yh
0008b2 93cf                      	push	yl
0008b3 e3c4
0008b4 e0d2                      	ldiw	y,i2c_var
0008b5 e800                      	ldi	temp,0b10000000
0008b6 8309                      	std	y+oi2c_result,temp		;result = busy
0008b7 831b                      	std	y+oi2c_rxcnt,temp2		;store size
0008b8 8100                      	ld	temp,z
0008b9 6001                      	sbr	temp,0x01			;<SLA+R>
0008ba 830c                      	std	y+oi2c_buf,temp
                                 
                                 	; Enable TWI, TWI int and initiate start condition
0008bb ea05                      	ldi	temp,(1<<TWEN)|(1<<TWIE)|(1<<TWINT)|(1<<TWSTA)
0008bc 9300 00bc                 	outm8	TWCR,temp
                                 
0008be dfbe                      	rcall	i2c_waitready
                                 
0008bf ff01                      	sbrs	temp,1				;at least 1 byte received
0008c0 c006                      	rjmp	i2c_ex				;
0008c1 8118                      	ldd	temp2,y+oi2ci_idx
0008c2 9624                      	adiw	y,oi2c_buf
                                 i2c_rl:
0008c3 9009                      	ld	_tmp0,y+
0008c4 9201                      	st	z+,_tmp0
0008c5 951a                      	dec	temp2
0008c6 f7e1                      	brne	i2c_rl
                                 
                                 i2c_ex:
0008c7 91cf                      	pop	yl
0008c8 91df                      	pop	yh
0008c9 91ef                      	pop	zl
0008ca 91ff                      	pop	zh
                                 i2c_re:
0008cb 9100 0235                 	lds	temp,i2c_result
0008cd 9508                      	ret
                                 
                                 ;------------------------------------------------------------------
                                 ;
                                 ; 	z:	Pointer to the data to write/read.
                                 ;		First byte is slave address
                                 ;	temp2:	Number of bytes to read, including address byte.
                                 ;
                                 
                                 i2c_write_read:
                                 
0008ce dfae                      	rcall	i2c_waitready
0008cf 3400                      	cpi	temp,0b01000000
0008d0 f560                      	brsh	i2c_wr_e
0008d1 93df                      	push	yh
0008d2 93cf                      	push	yl
0008d3 93ff                      	push	zh
0008d4 93ef                      	push	zl
                                 
0008d5 e3c4
0008d6 e0d2                      	ldiw	y,i2c_var
0008d7 e900                      	ldi	temp,0b10010000
0008d8 8309                      	std	y+oi2c_result,temp		;result = busy
0008d9 e002                      	ldi	temp,2
0008da 830a                      	std	y+oi2c_txcnt,temp		;store tx size
0008db 831b                      	std	y+oi2c_rxcnt,temp2		;store rx size
0008dc 9624                      	adiw	y,oi2c_buf
                                 
0008dd 2e00                      	mov	_tmp0,temp			;save tx count
0008de 9101                      	ld	temp,z+				;get SLA
0008df 7f0e                      	cbr	temp,0x01			;
                                 i2c_wr_wl:
0008e0 9309                      	st	y+,temp
0008e1 940a                      	dec	_tmp0
0008e2 f011                      	breq	i2c_wr_wle
0008e3 9101                      	ld	temp,z+
0008e4 cffb                      	rjmp	i2c_wr_wl
                                 i2c_wr_wle:
                                 	; Enable TWI, TWI int and initiate start condition
0008e5 ea05                      	ldi	temp,(1<<TWEN)|(1<<TWIE)|(1<<TWINT)|(1<<TWSTA)
0008e6 9300 00bc                 	outm8	TWCR,temp
                                 
0008e8 df94                      	rcall	i2c_waitready
                                 
0008e9 fd04                      	sbrc	temp,4				;
0008ea c00e                      	rjmp	i2c_wr_ex				;
0008eb ff01                      	sbrs	temp,1				;at least 1 byte received
0008ec c00c                      	rjmp	i2c_wr_ex				;
0008ed e3c4
0008ee e0d2                      	ldiw	y,i2c_var
0008ef 8118                      	ldd	temp2,y+oi2ci_idx
0008f0 9624                      	adiw	y,oi2c_buf
0008f1 91ef                      	pop	zl
0008f2 91ff                      	pop	zh
0008f3 93ff                      	push	zh
0008f4 93ef                      	push	zl
                                 i2c_wr_rl:
0008f5 9009                      	ld	_tmp0,y+
0008f6 9201                      	st	z+,_tmp0
0008f7 951a                      	dec	temp2
0008f8 f7e1                      	brne	i2c_wr_rl
                                 
                                 i2c_wr_ex:
0008f9 91ef                      	pop	zl
0008fa 91ff                      	pop	zh
0008fb 91cf                      	pop	yl
0008fc 91df                      	pop	yh
                                 i2c_wr_e:
0008fd 9100 0235                 	lds	temp,i2c_result
0008ff 9508                      	ret
                                 
                                 
                                 ;------------------------------------------------------------------
                                 
                                 	.dseg
                                 
                                 vi2c_stat:
00027a                           	.byte	1
                                 vi2c_blen:
00027b                           	.byte	1
                                 vi2c_addr:
00027c                           	.byte	2
                                 
                                 	.cseg
                                 
                                 vi2c_stat_get:
000900 9100 0235                 	lds	temp,i2c_result
000902 9508                      	ret
                                 
                                 vi2c_param_get:
000903 2322                      	tst	temp3
000904 f419                      	brne	vi2c_pg2
                                 
000905 9100 0234                 	lds	temp,i2ci_idx
000907 c005                      	rjmp	vi2c_pge
                                 
                                 vi2c_pg2:
000908 e7eb
000909 e0f2                      	ldiw	z,vi2c_blen
00090a 0fe2                      	add	zl,temp3
00090b 1df7                      	adc	zh,_0
00090c 8100                      	ld	temp,z
                                 vi2c_pge:
00090d 9508                      	ret
                                 
                                 vi2c_param_set:
00090e e7eb
00090f e0f2                      	ldiw	z,vi2c_blen
000910 0fe2                      	add	zl,temp3
000911 1df7                      	adc	zh,_0
000912 8300                      	st	z,temp
000913 9508                      	ret
                                 
                                 ;------------------------------------------------------------------
                                 ;
                                 ; 	vi2c_addr:	Pointer to the data to write.
                                 ;			First byte is slave address
                                 ;	vi2c_blen:	Number of bytes to write including address byte.
                                 ;
                                 
                                 vi2c_write:
                                 
000914 df68                      	rcall	i2c_waitready
000915 3400                      	cpi	temp,0b01000000
000916 f4c8                      	brsh	vi2c_wex
000917 e3e4
000918 e0f2                      	ldiw	z,i2c_var
000919 e800                      	ldi	temp,0b10000000
00091a 8301                      	std	z+oi2c_result,temp		;result = busy
00091b 9120 027b                 	lds	temp3,vi2c_blen
00091d 3422                      	cpi	temp3,I2C_BUFSIZE
00091e f008                      	brlo	vi2c_w1
00091f e422                      	ldi	temp3,I2C_BUFSIZE
                                 vi2c_w1:
000920 8322                      	std	z+oi2c_txcnt,temp3		;store size
000921 9634                      	adiw	z,oi2c_buf
000922 91a0 027c
000924 91b0 027d                 	ldsw	x,vi2c_addr
000926 dedc                      	lcall	dram_read_pp
000927 7f0e                      	cbr	temp,0x01
                                 vi2c_wl:
000928 9301                      	st	z+,temp
000929 952a                      	dec	temp3
00092a f011                      	breq	vi2c_wle
00092b ded7                      	lcall	dram_read_pp
00092c cffb                      	rjmp	vi2c_wl
                                 vi2c_wle:
                                 	; Enable TWI, TWI int and initiate start condition
00092d ea05                      	ldi	temp,(1<<TWEN)|(1<<TWIE)|(1<<TWINT)|(1<<TWSTA)
00092e 9300 00bc                 	outm8	TWCR,temp
                                 vi2c_wex:
000930 9508                      	ret
                                 
                                 ;------------------------------------------------------------------
                                 ;
                                 ; 	x:	Pointer to the data buffer.
                                 ;		First byte is slave address
                                 ;	temp3:	Buffer len. (Number of bytes to read + address byte.)
                                 ;
                                 
                                 vi2c_read:
                                 
000931 df4b                      	rcall	i2c_waitready
000932 3400                      	cpi	temp,0b01000000
000933 f4e8                      	brsh	vi2c_rex
                                 
000934 e3e4
000935 e0f2                      	ldiw	z,i2c_var
000936 e800                      	ldi	temp,0b10000000
000937 8301                      	std	z+oi2c_result,temp		;result = busy
000938 9120 027b                 	lds	temp3,vi2c_blen
00093a 3422                      	cpi	temp3,I2C_BUFSIZE
00093b f008                      	brlo	vi2c_r1
00093c e422                      	ldi	temp3,I2C_BUFSIZE
                                 vi2c_r1:
00093d 8323                      	std	z+oi2c_rxcnt,temp3		;store size
00093e 9634                      	adiw	z,oi2c_buf
00093f 91a0 027c
000941 91b0 027d                 	ldsw	x,vi2c_addr
000943 debf                      	lcall	dram_read_pp
000944 6001                      	sbr	temp,0x01
000945 9301                      	st	z+,temp
000946 952a                      	dec	temp3
                                 
                                 	; Enable TWI, TWI int and initiate start condition
000947 ea05                      	ldi	temp,(1<<TWEN)|(1<<TWIE)|(1<<TWINT)|(1<<TWSTA)
000948 9300 00bc                 	outm8	TWCR,temp
                                 
00094a df32                      	rcall	i2c_waitready
00094b 7003                      	andi	temp,0b00000011
00094c f021                      	breq	vi2c_rex				;
                                 vi2c_rl:
00094d 9101                      	ld	temp,z+
00094e deba                      	lcall	dram_write_pp
00094f 952a                      	dec	temp3
000950 f7e1                      	brne	vi2c_rl
                                 
                                 vi2c_rex:
000951 9508                      	ret
                                 
                                 ;------------------------------------------------------------------
                                 ;
                                 ; 	vi2c_addr:	Pointer to the data to write.
                                 ;			First byte is slave address
                                 ;	temp2:		Number of bytes to write including address byte.
                                 ;
                                 ;	vi2c_blen:	Number of bytes to read including address byte.
                                 ;
                                 
                                 vi2c_write_read:
                                 
000952 df2a                      	rcall	i2c_waitready
000953 3400                      	cpi	temp,0b01000000
000954 f568                      	brsh	vi2c_wr_ex
000955 e3e4
000956 e0f2                      	ldiw	z,i2c_var
000957 e900                      	ldi	temp,0b10010000
000958 8301                      	std	z+oi2c_result,temp		;result = busy
000959 8312                      	std	z+oi2c_txcnt,temp2		;store tx size
00095a 9120 027b                 	lds	temp3,vi2c_blen
00095c 3422                      	cpi	temp3,I2C_BUFSIZE
00095d f008                      	brlo	vi2c_wr_w1
00095e e422                      	ldi	temp3,I2C_BUFSIZE
                                 vi2c_wr_w1:
00095f 8323                      	std	z+oi2c_rxcnt,temp3		;store rx size
000960 9634                      	adiw	z,oi2c_buf
000961 91a0 027c
000963 91b0 027d                 	ldsw	x,vi2c_addr
000965 de9d                      	lcall	dram_read_pp
000966 7f0e                      	cbr	temp,0x01
                                 vi2c_wr_wl:
000967 9301                      	st	z+,temp
000968 951a                      	dec	temp2
000969 f011                      	breq	vi2c_wr_wle
00096a de98                      	lcall	dram_read_pp
00096b cffb                      	rjmp	vi2c_wr_wl
                                 vi2c_wr_wle:
                                 	; Enable TWI, TWI int and initiate start condition
00096c ea05                      	ldi	temp,(1<<TWEN)|(1<<TWIE)|(1<<TWINT)|(1<<TWSTA)
00096d 9300 00bc                 	outm8	TWCR,temp
                                 
00096f df0d                      	rcall	i2c_waitready
                                 
000970 fd04                      	sbrc	temp,4				;
000971 cf87                      	rjmp	i2c_wr_ex			;
000972 7003                      	andi	temp,0b00000011			;
000973 f2e9                      	breq	vi2c_rex			;
000974 e3e4
000975 e0f2                      	ldiw	z,i2c_var
000976 8110                      	ldd	temp2,z+oi2ci_idx
000977 9635                      	adiw	z,oi2c_buf+1
000978 91a0 027c
00097a 91b0 027d                 	ldsw	x,vi2c_addr
00097c 9611                      	adiw	x,1
00097d c002                      	rjmp	vi2c_wr_rl0
                                 vi2c_wr_rl:
00097e 9101                      	ld	temp,z+
00097f de89                      	lcall	dram_write_pp
                                 vi2c_wr_rl0:
000980 951a                      	dec	temp2
000981 f7e1                      	brne	vi2c_wr_rl
                                 
                                 vi2c_wr_ex:
000982 9508                      	ret
                                 
                                 ;------------------------------------------------------------------
                                 
                                 
                                 vi2c_ctrl:
000983 3001                      	cpi	temp,1				;read ?
000984 f409                      	brne	vi2c_c1
000985 cfab                      	rjmp	vi2c_read
                                 
                                 vi2c_c1:
000986 3002                      	cpi	temp,2				;write?
000987 f409                      	brne	vi2c_c2
000988 cf8b                      	rjmp	vi2c_write
                                 vi2c_c2:
000989 3003                      	cpi	temp,3				;write and read ?
00098a f411                      	brne	vi2c_c3
00098b e012                      	ldi	temp2,2				;write 1 byte (subaddress), then read
00098c cfc5                      	rjmp	vi2c_write_read
                                 vi2c_c3:
                                 vi2c_ce:
00098d 9508                      	ret
                                 
                                 ;------------------------------------------------------------------
                                 
                                 /* -MH- */
                                 #if I2C_PCF8574_SUPPORT
                                 pcf8574_in:
                                 	; send address byte and read data byte
                                 	; make a buffer[0:1] on stack
00098e 926f                      	push	_255                 ; place holder for input value buffer[0]
00098f b7fe                      	in	zh,sph
000990 b7ed                      	in	zl,spl
000991 e200                      	ldi	temp,PCF8574_ADDR    ; PCF8574 address (7 bit)
000992 0f02                      	add	temp,temp3           ; usually == 0
000993 0f00                      	lsl	temp                 ; make into command byte (slave address << 1) without R/W flag
000994 930f                      	push	temp                 ; push command byte to buffer[1]
000995 e012                      	ldi	temp2,2              ; buffer length: command + 1 byte to read
000996 df15                      	rcall	i2c_read             ; sends command byte and reads the byte to the buffer[0]
000997 910f                      	pop	temp                 ; drop command byte from buffer[1]
000998 910f                      	pop	temp                 ; drop value from buffer[0] into temp as return value
000999 9508                      	ret
                                 
                                 pcf8574_out:
                                 	; send address byte and data byte
                                 	; make a buffer[0:1] on stack
00099a 930f                      	push	temp                 ; output value to buffer[0]
00099b b7fe                      	in 	zh,sph
00099c b7ed                      	in 	zl,spl
00099d e200                      	ldi	temp,PCF8574_ADDR    ; PCF8574 address (7 bit)
00099e 0f02                      	add	temp,temp3           ; usually == 0
00099f 0f00                      	lsl	temp                 ; make into command byte (slave address << 1) without R/W flag
0009a0 930f                      	push	temp                 ; push command byte to buffer[1]
0009a1 e012                      	ldi	temp2,2              ; 2 bytes to send: command and value
0009a2 deed                      	rcall	i2c_write            ; sends the 2 bytes slave address + value
0009a3 910f                      	pop	temp                 ; drop command byte from buffer[1]
0009a4 910f                      	pop	temp                 ; drop value buffer[0] 
0009a5 9508                      	ret
                                 #endif /* I2C_PCF8574_SUPPORT */
                                 /* -MH- */
                                 
                                 
                                 ;------------------------------------------------------------------
                                 
                                 #if I2C_UART_SUPPORT
                                 
                                 SC16IS740_in:
                                 	; send address byte, register index and read data byte
                                 	; make a buffer[0:1] on stack
                                 	; massage internal register number into bits 6:3 of temp3
0009a6 9522                      	swap	temp3       ;     7654.3210 -> 3210.7654
0009a7 9526                      	lsr	temp3       ;     3210.7654 -> -321.0765 as per data sheet
0009a8 932f                      	push	temp3       ; register index:  -A[3:0]00- to buffer[0]
0009a9 b7fe                      	in	zh,sph
0009aa b7ed                      	in	zl,spl
0009ab e408                      	ldi	temp,SC16IS740_ADDR  ; slave address (7 bit)
0009ac 0f00                      	lsl	temp                 ; (slave address << 1) (aka 8 bit address or command byte)
0009ad 930f                      	push	temp        ; command byte to buffer[1]
0009ae e012                      	ldi	temp2,2     ; buffer has command byte + index byte
0009af df1e                      	rcall	i2c_write_read   ; send command byte + register index, place result into buffer[0]
0009b0 910f                      	pop	temp        ; drop command byte from buffer[1]
0009b1 910f                      	pop	temp        ; drop input value from buffer[0] into temp as return value
0009b2 9508                      	ret
                                 
                                 SC16IS740_out:
                                 	; send address byte, register index and data byte
                                 	; make a buffer[0:1] on stack
0009b3 930f                      	push	temp        ; output value buffer[0]
                                 	; massage internal register number into bits 6:3 of temp3
0009b4 9522                      	swap	temp3       ;
0009b5 9526                      	lsr	temp3       ;
0009b6 932f                      	push	temp3       ; register index -A[3:0]00- to buffer[1]
0009b7 b7fe                      	in	zh,sph
0009b8 b7ed                      	in	zl,spl
0009b9 e408                      	ldi	temp,SC16IS740_ADDR  ; slave address (7 bit)
0009ba 0f00                      	lsl	temp                 ; (slave address << 1) (aka 8 bit address or command byte)
0009bb 930f                      	push	temp        ; command byte to buffer[2]
0009bc e013                      	ldi	temp2,3
0009bd ded2                      	rcall	i2c_write   ; send command byte + register index + data byte
0009be 910f                      	pop	temp			; drop command byte from buffer[2]
0009bf 910f                      	pop	temp			; drop register index from buffer[1]
0009c0 910f                      	pop	temp			; drop output value from buffer[0]
0009c1 9508                      	ret
                                 
                                 #endif /* I2C_UART_SUPPORT */
                                 
                                 /* -MH- very similar to I2C_UART_SUPPORT except for the register address byte */
                                 #if I2C_MCP23017_SUPPORT
                                 
                                 MCP23017_in:
                                 	; send address+R/W byte, register index and read data byte
                                 	; temp:  return value as read from I2C
                                 	; temp2: port number
                                 	; temp3: register index (== given_port - base_port)
                                 	; the MCP23017 expects 2 bytes: [slave address][register index] and sends one byte back
                                 	
                                 	; prepare a buffer[0:1] on the stack ([register index],[slave address])
0009c2 932f                      	push	temp3                ; -> register index byte to buffer[0] and SP->buffer[1]
0009c3 b7fe                      	in 	zh,sph               ; prepare 16-bit pointer to stack ...
0009c4 b7ed                      	in 	zl,spl               ; ... complete pointer to buffer[1]
0009c5 e200                      	ldi	temp,MCP23017_ADDR   ; load  slave address (7 bit)
0009c6 0f00                      	lsl	temp                 ; (slave address << 1) (aka 8 bit address or command byte)
0009c7 930f                      	push	temp                 ; -> (slave address << 1) to buffer[1]
0009c8 e012                      	ldi	temp2,2              ; 2 bytes to send: address and register index
0009c9 df04                      	rcall	i2c_write_read       ; send 2 bytes in buffer and read one byte to buffer[0]
0009ca 910f                      	pop	temp                 ; drop (slave address << 1) from buffer[1]
0009cb 910f                      	pop	temp                 ; drop input byte from buffer[0] into temp as return value
0009cc 9508                      	ret
                                 
                                 MCP23017_out:
                                 	; send address+R/W byte, register index and data byte
                                 	; temp:  value to output
                                 	; temp2: port number
                                 	; temp3: register index(== given_port - base_port)
                                 	; the MCP23017 expects 3 bytes: [slave address][register index][data byte to write]
                                 	
                                 	; prepare a buffer[0:2] on the stack (data bytes are pushed right to left)
0009cd 930f                      	push	temp                 ; -> data byte to buffer[0]           and SP->buffer[1]
0009ce 932f                      	push	temp3	               ; -> register index byte to buffer[1] and SP->buffer[2]
0009cf b7fe                      	in 	zh,sph               ; prepare 16-bit pointer to buffer[2] ...
0009d0 b7ed                      	in 	zl,spl               ; ... complete pointer to stack
0009d1 e200                      	ldi	temp,MCP23017_ADDR   ; load  slave address (7 bit)
0009d2 0f00                      	lsl	temp                 ; (slave address << 1) (aka 8 bit address or command byte)
0009d3 930f                      	push	temp                 ; -> (slave address << 1) to to buffer[2]
0009d4 e013                      	ldi	temp2,3              ; 3 bytes to send: address, register index and, data byte
0009d5 deba                      	rcall	i2c_write            ; send the 3 bytes (in buffer pointed to by Z)
0009d6 910f                      	pop	temp                 ; drop (slave address << 1) from buffer[2]
0009d7 910f                      	pop	temp                 ; drop register index from buffer[1]
0009d8 910f                      	pop	temp                 ; drop output value from buffer[0]
0009d9 9508                      	ret
                                 
                                 #endif /* I2C_MCP23017_SUPPORT */
                                 /* -MH- */
                                 
                                 #endif /* I2C_SUPPORT */
                                 ;------------------------------------------------------------------
                                 ; vim:set ts=8 noet nowrap
                                 #endif
                                 ; >>>-------------------------------------- File System Management
                                 	.include "dsk_cpm.asm"		; CPM- Disk Interaktion
                                 
                                 ;
                                 ;    Copyright (C) 2010 Frank Zoll
                                 ;
                                 ;    This file is part of avrcpm.
                                 ;
                                 ;    avrcpm is free software: you can redistribute it and/or modify it
                                 ;    under the terms of the GNU General Public License as published by
                                 ;    the Free Software Foundation, either version 3 of the License, or
                                 ;    (at your option) any later version.
                                 ;
                                 ;    avrcpm is distributed in the hope that it will be useful,
                                 ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
                                 ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                                 ;    GNU General Public License for more details.
                                 ;
                                 ;    You should have received a copy of the GNU General Public License
                                 ;    along with avrcpm.  If not, see <http://www.gnu.org/licenses/>.
                                 ;
                                 ;    $Id: dsk_cpm.asm 93 2014-01-03 16:32:32Z rapid $
                                 ;
                                 
                                 #if CPMDSK_SUPPORT
                                 
                                 
                                 	.cseg
                                 
                                 cpm_lba_to_phys:
0009da 8101                      	ldd	temp ,z+PTAB_START+0	; get startsector of partition
0009db 8112                      	ldd	temp2,z+PTAB_START+1
0009dc 81c3                      	ldd	yl,z+PTAB_START+2
0009dd 81d4                      	ldd	yh,z+PTAB_START+3
                                 
0009de 0fa0                      	add	xl,temp			; add offset to startsector
0009df 1fb1                      	adc	xh,temp2
0009e0 1dc7                      	adc	yl,_0
0009e1 1dd7                      	adc	yh,_0
                                 
0009e2 9508                      	ret
                                 
                                 ; ====================================================================
                                 ; Function: Add's a CP/M Partition to the Partition table
                                 ; ====================================================================
                                 ; Parameters
                                 ; --------------------------------------------------------------------
                                 ; Registers  : none
                                 ; Variables  : [r] seekdsk		Number of Disk to Read
                                 ;	       [r] seeksec		Sector to read
                                 ;              [r] seektrk		Track  to read
                                 ; --------------------------------------------------------------------
                                 ; Description:
                                 ; ====================================================================	
                                 cpm_add_partition:
                                 	
0009e3 e100                      	ldi 	temp,dskType_CPM
0009e4 8308                      	std	y+0,temp
                                 
0009e5 8500                      	ldd	temp,z+PART_START
0009e6 8309                      	std	y+1,temp
0009e7 8501                      	ldd	temp,z+PART_START+1
0009e8 830a                      	std	y+2,temp
0009e9 8502                      	ldd	temp,z+PART_START+2
0009ea 830b                      	std	y+3,temp
0009eb 8503                      	ldd	temp,z+PART_START+3
0009ec 830c                      	std	y+4,temp
                                 	
0009ed 8506                      	ldd	temp,z+PART_SIZE+2
0009ee 8517                      	ldd	temp2,z+PART_SIZE+3
0009ef 2b01                      	or	temp,temp2		;part size larger than 65535 sectors?
0009f0 f429                      	brne	cpm_add_prune
                                 
0009f1 8504                      	ldd	temp,z+PART_SIZE
0009f2 830d                      	std	y+5,temp
0009f3 8505                      	ldd	temp,z+PART_SIZE+1
0009f4 830e                      	std	y+6,temp
0009f5 c002                      	rjmp	cpm_add_e
                                 
                                 cpm_add_prune:
0009f6 826d                      	std	y+5,_255
0009f7 826e                      	std	y+6,_255
                                 
                                 cpm_add_e:
0009f8 9508                      	ret
                                 		
                                 #endif /* CPMDSK_SUPPORT */
                                 
                                 ; vim:set ts=8 noet nowrap
                                 
                                 	.include "dsk_fat16.asm"	; FAT16-DISK Interaktion
                                 
                                 ;
                                 ;    Copyright (C) 2010 Frank Zoll
                                 ;    Copyright (C) 2010 Sprite_tm
                                 ;    Copyright (C) 2010,2013 Leo C.
                                 ;
                                 ;    This file is part of avrcpm.
                                 ;
                                 ;    avrcpm is free software: you can redistribute it and/or modify it
                                 ;    under the terms of the GNU General Public License as published by
                                 ;    the Free Software Foundation, either version 3 of the License, or
                                 ;    (at your option) any later version.
                                 ;
                                 ;    avrcpm is distributed in the hope that it will be useful,
                                 ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
                                 ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                                 ;    GNU General Public License for more details.
                                 ;
                                 ;    You should have received a copy of the GNU General Public License
                                 ;    along with avrcpm.  If not, see <http://www.gnu.org/licenses/>.
                                 ;
                                 ;    $Id: dsk_fat16.asm 153 2014-11-12 12:59:42Z rapid $
                                 ;
                                 
                                 ; ============================================================================
                                 ; Prelimitary !
                                 ; 
                                 ; Size of a Sector is fixed to 512 Bytes by Base - MMC Driver implementation
                                 ; The Functions below therefore assume a fixed Size of 512 Bytes per Sector.
                                 ; ============================================================================
                                 
                                 #if FAT16_SUPPORT
                                 
                                 
                                 ; ############################################################################ 
                                 ;                       	Defines for FAT16 Structures
                                 ; ############################################################################ 
                                 
                                 /*These are the Offsets to the Variables within the Bootsector of a FAT16
                                   Partition.
                                 */
                                 ;#define FAT16_BSO_SECSIZE	0x0b	; Offset to Sectorsize Word
                                 #define FAT16_BSO_CLUSTSZ   	0x0d    ; Offset to Clustersize Byte
                                 #define FAT16_BSO_RESSECT   	0x0e	; Offset to Number of Reserved Sectors
                                 #define FAT16_BSO_VOLPTR    	0x1c    ; Offset to First VolumeSector
                                 #define FAT16_BSO_SECPERFAT 	0x16    ; Offset to Number of Sectors per Fat
                                 #define FAT16_BSO_NUMFATCP  	0x10	; Offset to Ammount of FAT Copys
                                 #define FAT16_BSO_NUMDIRENT 	0x11	; Offset to Max. Root Dir. entries
                                 
                                 #define	FAT16_FIRST_IMAGENAME 'A'	/* First letter of filename to search */
                                 #define FAT16_LAST_IMAGENAME  'Z'	/* Last letter of filename to */
                                 #define FAT16_IMAGENAME_PREFIX "CPMDSK_"
                                 #define FAT16_IMAGENAME_SUFFIX "IMG"
                                 
                                 ; ############################################################################ 
                                 ; 				Start of Data Segment
                                 ; ############################################################################ 
                                 
                                 	.dseg
                                 
                                 fat_vars:
00027e                           fat_partfound:   .byte   1	; (partition: 0= no found 0xff=found )
00027f                           fat_parttbl: 	 .byte	 4	; first fat16 partition entry 
                                 				; only startsector is needed
000283                           fat_clustersize: .byte   1	; sectors per cluster
000284                           fat_ptr2fat:     .byte   4	; pointer to the first fat sector
000288                           fat_ptr2dat:     .byte   4	; pointer to the first data sector
                                 
                                 /*These variables define a cache that holds the last Cluster and Sector
                                   thats been searched vor.
                                 */
00028c                           fat_last_dsk:	  .byte	 1	; number of disk with entry in cache
00028d                           fat_log_clust:	  .byte	 2	; last searched logical cluster
00028f                           fat_clust_offset: .byte	 1	; offset within the cluster
000290                           fat_clust_ptr:	  .byte	 4 	; sector of last real cluster
                                 
                                 	.equ	o_fat_partfound	  = 0
                                 	.equ	o_fat_parttbl	  = 1
                                 	.equ	o_fat_clustersize = 5
                                 	.equ	o_fat_ptr2fat	  = 6
                                 	.equ	o_fat_ptr2dat	  = 10
                                 	.equ	o_fat_last_dsk	  = 14
                                 	.equ	o_fat_log_clust	  = 15
                                 	.equ	o_fat_clust_offset= 17
                                 	.equ	o_fat_clust_ptr	  = 18
                                 
                                 .if FAT16_FATBUF
                                 
000294                           fat_last_fatsect:	.byte	1
                                 	.equ	o_fat_last_fatsect = 22
                                 
000295                           fat_buf:	.byte	512
                                 
                                 .endif	/* FAT16_FATBUF */
                                 
                                 ; ############################################################################ 
                                 ; 				Start of Code Segment
                                 ; ############################################################################ 
                                 
                                 	.cseg
                                 
0009f9 5043
0009fa 444d
0009fb 4b53
0009fc 005f                      fat_cfname:	.db	FAT16_IMAGENAME_PREFIX, 0
0009fd 4d49
0009fe 0047                      fat_cfext:	.db	FAT16_IMAGENAME_SUFFIX, 0
                                 
                                 
                                 ; ============================================================================
                                 ; Function: Initialize internal FAT-Partition Variables
                                 ; ============================================================================
                                 ; Parameters
                                 ; ----------------------------------------------------------------------------
                                 ; Registers  :	none
                                 ; Variables  :	[out]	fat_parttabl
                                 ; ----------------------------------------------------------------------------
                                 ; Description:
                                 ; This Routine initializes the internal Variables, that point to the
                                 ; first Found FAT16 Partition.
                                 ; ============================================================================
                                 fat_init_partitiontable:
                                 
0009ff e7ce
000a00 e0d2                      	ldiw	y,fat_vars
000a01 8278                      	std 	y+o_fat_partfound, _0
000a02 8279                      	std	y+o_fat_parttbl+0, _0
000a03 827a                      	std	y+o_fat_parttbl+1, _0
000a04 827b                      	std	y+o_fat_parttbl+2, _0
000a05 827c                      	std	y+o_fat_parttbl+3, _0
000a06 9508                      	ret
                                 
                                 
                                 ; ============================================================================
                                 ; Function: Resets the Cache
                                 ; ============================================================================
                                 ; Parameters
                                 ; ----------------------------------------------------------------------------
                                 ; Registers  :	none
                                 ; Variables  :	[out]	fat_log_clust
                                 ;		[out]	fat_last_dsk
                                 ; ----------------------------------------------------------------------------
                                 ; Description:
                                 ; This Routine resets the internal Cache- Variables. After reset, the
                                 ; next read or write Command will initialize a scan of the FAT of
                                 ; the FAT16-Partition for the given sector.
                                 ; ============================================================================
                                 fat_reset_cache:
000a07 e7ce
000a08 e0d2                      	ldiw	y,fat_vars
000a09 866f                      	std 	y+o_fat_log_clust  ,_255
000a0a 8a68                      	std	y+o_fat_log_clust+1,_255
000a0b 866e                      	std	y+o_fat_last_dsk   ,_255
                                 .if FAT16_FATBUF
000a0c 8a6e                      	std	y+o_fat_last_fatsect,_255
                                 .endif
                                 
000a0d 9508                      	ret
                                 
                                 ; ============================================================================
                                 ; Function: Saves FAT16 Partitiondata for later Scanning
                                 ; ============================================================================
                                 ; Parameters
                                 ; ----------------------------------------------------------------------------
                                 ; Registers  :	[in]	z		Pointer to the Partitondata
                                 ; Variables  :	[out]	fat_partfound	Boolean for "Partition found"
                                 ;		[out]	fat_parttbl	Pointer to Partitiontable
                                 ; ----------------------------------------------------------------------------
                                 ; Description:
                                 ; This funktion sets the internal Variables to the Start and Size
                                 ; of a given FAT16 Paritition. This Information will be used for a
                                 ; later scanning of the Partition. See Function "fat_scan_partition"
                                 ; for more information. 
                                 ; ============================================================================
                                 
                                 fat_add_partition:
                                 	
                                 .if FAT16_DEBUG > 0
                                 .endif
                                 
000a0e e7ce
000a0f e0d2                      	ldiw	y,fat_vars
                                 
                                 ; set fat16 partition found flag
                                 
000a10 8268                      	std 	y+o_fat_partfound,_255
                                 
                                 ; save data from first fat16 partition
                                 
000a11 8500                      	ldd	temp,z+PART_START
000a12 8309                      	std	y+o_fat_parttbl,temp
000a13 8501                      	ldd	temp,z+PART_START+1
000a14 830a                      	std	y+o_fat_parttbl+1,temp
000a15 8502                      	ldd	temp,z+PART_START+2
000a16 830b                      	std	y+o_fat_parttbl+2,temp
000a17 8503                      	ldd	temp,z+PART_START+3
000a18 830c                      	std	y+o_fat_parttbl+3,temp
                                 
000a19 9508                      	ret
                                 
                                 ; ============================================================================
                                 ; Read and Scann a FAT16 Partition for Imagedatefiles 
                                 ; ============================================================================
                                 ; Registers	: none
                                 ; Variables	: none
                                 ; ----------------------------------------------------------------------------
                                 ; This Routine reads the Bootblock and scanns it for a Diskimage
                                 ; ============================================================================
                                 
                                 
                                 fat_scan_partition:
                                 
                                 .if FAT16_DEBUG > 0
                                 .endif
                                 
                                 ; Check if a FAT16 Partition was realy found
000a1a 91c0 027e                 	lds	yl,fat_partfound
000a1c 30c0                      	cpi 	yl,0	
000a1d f079                      	breq	fat_scan_error 
                                 
                                 
                                 .if FAT16_DEBUG > 0
                                 .endif
                                 
                                 ; Check for free entries in partition table
000a1e 91c0 049b                 	lds	yl,ndisks
000a20 30c8                      	cpi	yl,MAXDISKS
000a21 f45c                      	brge	fat_scan_error
                                 
                                 .if FAT16_DEBUG > 0
                                 .endif
                                 
                                 ; Scan partition start
000a22 e7ef
000a23 e0f2                      	ldiw	z,fat_parttbl	
000a24 81a0                      	ldd	xl,z+0		
000a25 81b1                      	ldd	xh,z+1
000a26 81c2                      	ldd	yl,z+2
000a27 81d3                      	ldd	yh,z+3
000a28 efe9
000a29 e0f4                      	ldiw	z,hostbuf
                                 
                                 ; Load first sector from Partition
000a2a dd49                      	rcall	mmcReadSect
000a2b 2300                      	tst	temp
000a2c f011                      	breq	fat_bootblock_check
                                 
                                 ; Read error: Block not found
                                 fat_scan_error:
000a2d 2700                      	clr	temp
000a2e 9508                      	ret
                                 
                                 fat_bootblock_check:
                                 
                                 .if FAT16_DEBUG > 0
                                 .endif
                                 
000a2f e7ce
000a30 e0d2                      	ldiw	y,fat_vars
000a31 efe9
000a32 e0f4                      	ldiw	z,hostbuf
                                 
                                 ;   	get sectors per cluster from bootblock
000a33 8505                      	ldd	temp,z+FAT16_BSO_CLUSTSZ
000a34 830d                      	std	y+o_fat_clustersize,temp
                                 
                                 .if FAT16_DEBUG > 0
                                 .endif
                                 
                                 ;	get max num of entries in root direktory from bootblock
000a35 8901                      	ldd	temp ,z+FAT16_BSO_NUMDIRENT
000a36 8912                      	ldd	temp2,z+FAT16_BSO_NUMDIRENT+1
                                 
                                 .if FAT16_DEBUG > 0
                                 .endif
                                 
                                 ; Calculate begin of DATA Clusters within the Volume
                                 ; Num. Dir.Sektors = (Num. of Dir. entries * 32) / Bytes per Sektor
                                 
                                 ; Sectorsize is fixed at 512 bytes, makes 16 entries per sector
                                 
                                 
                                 ;   Num. Direntries / 16
000a37 9516                      	lsr	temp2
000a38 9507                      	ror	temp
000a39 9516                      	lsr	temp2
000a3a 9507                      	ror	temp
000a3b 9516                      	lsr	temp2
000a3c 9507                      	ror	temp
000a3d 9516                      	lsr	temp2
000a3e 9507                      	ror	temp
                                 
000a3f 930f                      	push	temp			;save # of rootdir sectors
                                 
                                 .if FAT16_DEBUG > 0
                                 .endif
                                 
                                 .if FAT16_DEBUG > 1
                                 .endif
                                 
                                 ;	get num of reseved sectors from bootblock
000a40 8406                      	ldd	_tmp0,z+FAT16_BSO_RESSECT
000a41 8417                      	ldd	_tmp1,z+FAT16_BSO_RESSECT+1
                                 
                                 ; 	Calculate begin of FAT within the Volume
000a42 81a9                      	ldd	xl,y+o_fat_parttbl+0		
000a43 81ba                      	ldd	xh,y+o_fat_parttbl+1
000a44 810b                      	ldd	temp,y+o_fat_parttbl+2
000a45 811c                      	ldd	temp2,y+o_fat_parttbl+3
                                 
000a46 0da0                      	add	xl,_tmp0
000a47 1db1                      	adc 	xh,_tmp1
000a48 1d07                      	adc	temp,_0
000a49 1d17                      	adc	temp2,_0
                                 
000a4a 83ae                      	std	y+o_fat_ptr2fat  ,xl
000a4b 83bf                      	std	y+o_fat_ptr2fat+1,xh
000a4c 8708                      	std	y+o_fat_ptr2fat+2,temp
000a4d 8719                      	std	y+o_fat_ptr2fat+3,temp2
                                 
                                 .if FAT16_DEBUG > 1
                                 .endif
                                 
                                 ;	get num of sectors per FAT-Table from bootblock
000a4e 8906                      	ldd	temp, z+FAT16_BSO_SECPERFAT
000a4f 8917                      	ldd	temp2,z+FAT16_BSO_SECPERFAT+1
                                 
                                 .if FAT16_DEBUG > 0
                                 .endif
                                 
                                 ;   	get num of FAT Tables from bootblock
000a50 8920                      	ldd	temp3,z+FAT16_BSO_NUMFATCP
                                 
                                 .if FAT16_DEBUG > 0
                                 .endif
                                 
000a51 0108                      	movw	_tmp0,temp
                                 
                                 ; Calculate begin of Root- Directory within the Volume
                                 
000a52 81ae                      	ldd	xl,   y+o_fat_ptr2fat+0
000a53 81bf                      	ldd	xh,   y+o_fat_ptr2fat+1
000a54 8508                      	ldd	temp, y+o_fat_ptr2fat+2
000a55 8519                      	ldd	temp2,y+o_fat_ptr2fat+3
                                 
                                 fat_calc_dp_loop:
000a56 1527                      	cp 	temp3,_0
000a57 f031                      	breq	fat_calc_dp_lend
                                 
000a58 0da0                      	add	xl,_tmp0
000a59 1db1                      	adc	xh,_tmp1
000a5a 1d07                      	adc	temp,_0
000a5b 1d17                      	adc	temp2,_0
000a5c 952a                      	dec	temp3
000a5d cff8                      	rjmp	fat_calc_dp_loop
                                 
                                 fat_calc_dp_lend:
                                 
                                 .if FAT16_DEBUG > 1
                                 .endif
                                 
000a5e 912f                      	pop	temp3			;number of rootdir sectors
                                 
000a5f 0fa2                      	add	xl,temp3
000a60 1db7                      	adc	xh,_0
000a61 1d07                      	adc	temp,_0
000a62 1d17                      	adc	temp2,_0
                                 
000a63 87aa                      	std	y+o_fat_ptr2dat  ,xl
000a64 87bb                      	std	y+o_fat_ptr2dat+1,xh
000a65 870c                      	std	y+o_fat_ptr2dat+2,temp
000a66 871d                      	std	y+o_fat_ptr2dat+3,temp2
                                 
                                 .if FAT16_DEBUG > 1
                                 .endif
                                 
                                 ;-------------------------------------------------------------------------------
                                 ; Here starts the scan of the directory for valid image files.
                                 
                                 
                                 fat_next_sector_loop:
                                 
                                 ;   Get a pointer to the last+1 directory sector
000a67 91a0 0288                 	lds	xl,fat_ptr2dat
000a69 91b0 0289                 	lds	xh,fat_ptr2dat+1
000a6b 91c0 028a                 	lds	yl,fat_ptr2dat+2
000a6d 91d0 028b                 	lds	yh,fat_ptr2dat+3
                                 
                                 ;	Add actual offset
000a6f 1ba2                      	sub	xl,temp3
000a70 09b7                      	sbc	xh,_0
000a71 09c7                      	sbc	yl,_0
000a72 09d7                      	sbc	yh,_0
                                 
                                 ;  Load sector from Directory
000a73 efe9
000a74 e0f4                      	ldiw	z,hostbuf
000a75 dcfe                      	lcall	mmcReadSect
000a76 2300                      	tst	temp
000a77 f011                      	breq	fat_look_for_images
                                 
                                 ; Read error: Block not found
000a78 2700                      	clr	temp
000a79 9508                      	ret
                                 
                                 ; Looks at a read directory block for image entries
                                 fat_look_for_images:
                                 	
000a7a efa9
000a7b e0b4                      	ldiw	x,hostbuf
                                 
                                 fat_look_for_loop:
                                 
000a7c 01ed                      	movw	y,x
000a7d efe2
000a7e e1f3                      	ldiw	z,fat_cfname*2
000a7f e017                      	ldi	temp2,STRLEN(FAT16_IMAGENAME_PREFIX)
000a80 940e 0242                 	lcall	strncmp_p
000a82 f489                      	brne	fat_look_continue
                                 
000a83 9621                      	adiw	y,1
000a84 9631                      	adiw	z,1
000a85 e013                      	ldi	temp2,STRLEN(FAT16_IMAGENAME_SUFFIX)
000a86 940e 0242                 	lcall	strncmp_p
000a88 f459                      	brne	fat_look_continue
                                 
000a89 01ed                      	movw	y,x
000a8a 811f                      	ldd	temp2,y+STRLEN(FAT16_IMAGENAME_PREFIX)
000a8b e401                      	ldi	temp,FAT16_FIRST_IMAGENAME
                                 fat_look_imgname_loop:
000a8c 1701                      	cp	temp,temp2
000a8d f021                      	breq	fat_look_imgname_match
000a8e 9503                      	inc	temp
000a8f 350b                      	cpi	temp,FAT16_LAST_IMAGENAME+1
000a90 f3d8                      	brlo	fat_look_imgname_loop
000a91 c002                      	rjmp	fat_look_continue
                                 
                                 fat_look_imgname_match:
000a92 d009                      	rcall	fat_store_new_entry
000a93 01de                      	movw	x,y
                                 
                                 fat_look_continue:
                                 
000a94 9690                      	adiw	x,32
000a95 e006                      	ldi	temp,high(hostbuf+HOSTSIZE)
000a96 3fa9                      	cpi	xl,low(hostbuf+HOSTSIZE)
000a97 07b0                      	cpc	xh,temp
000a98 f719                      	brne	fat_look_for_loop
                                 
                                 fat_scan_next_sector:
                                 	
000a99 952a                      	dec	temp3
000a9a f661                      	brne	fat_next_sector_loop
                                 
000a9b 9508                      	ret
                                 
                                 
                                 
                                 #if 0
                                 #endif
                                 
                                 ;-------------------------------------------------------------------------------
                                 ;	Create new Partition Entry
                                 ; ============================================================================
                                 ; Function: Create new Partition Entry
                                 ; ============================================================================
                                 ; Parameters:	[in]	yh,yl		Directory entry
                                 ;
                                 ; ----------------------------------------------------------------------------
                                 ; Registers  : 	
                                 ; Variables  : 	[used]
                                 ;		[changes] temp
                                 ; ----------------------------------------------------------------------------
                                 ; Description:
                                 ; 
                                 ; ============================================================================
                                 
                                 fat_store_new_entry:
                                 
                                 ;   Found a valid image
                                 .if FAT16_DEBUG > 1
                                 .endif
                                 
                                 #if 0
                                 #endif
000a9c ebe1
000a9d e0f4                      	ldiw	z,hostparttbl
                                 
                                 fat_st_searchpos:
000a9e 8100                      	ldd	temp,z+PTAB_TYPE
000a9f 2300                      	tst	temp
000aa0 f0a1                      	breq	fat_st_insert_slot			
000aa1 ff05                      	sbrs	temp,log2(dskType_FAT)
000aa2 c003                      	rjmp	fat_st_search_next
                                 
000aa3 8103                      	ldd	temp,z+PTAB_START+2
000aa4 1710                      	cp	temp2,temp
000aa5 f030                      	brlo	fat_st_ins_before
                                 
                                 fat_st_search_next:
000aa6 9639                      	adiw	z,PARTENTRY_SIZE
000aa7 3fe9                      	cpi	zl,low(hostparttbltop)
000aa8 e004                      	ldi	temp,high(hostparttbltop)
000aa9 07f0                      	cpc	zh,temp
000aaa f799                      	brne	fat_st_searchpos
                                 
                                 ; Table is full.
                                 #if 0
                                 #endif
000aab 9508                      	ret
                                 
                                 fat_st_ins_before:
000aac 01df                      	movw	x,z
000aad efe0
000aae e0f4                      	ldiw	z,hostparttbltop-PARTENTRY_SIZE
                                 fat_st_insert_mkslotloop:
000aaf 17ea                      	cp	zl,xl
000ab0 07fb                      	cpc	zh,xh
000ab1 f019                      	breq	fat_st_insert_slot
                                 
000ab2 9002                      	ld	_tmp0,-z
000ab3 8601                      	std	z+PARTENTRY_SIZE,_tmp0
000ab4 cffa                      	rjmp	fat_st_insert_mkslotloop
                                 
                                 fat_st_insert_slot:
                                 
                                 ;   Set Type of Partition to FAT16- Fileimage
000ab5 e200                      	ldi 	temp,dskType_FAT
000ab6 8300                      	std	z+PTAB_TYPE,temp
                                 
                                 ;   Offset to Startcluster + 2
000ab7 8c0a                      	ldd	_tmp0,y+0x1A
000ab8 8c1b                      	ldd	_tmp1,y+0x1B
000ab9 8201                      	std	z+PTAB_START,  _tmp0
000aba 8212                      	std	z+PTAB_START+1,_tmp1	
                                 
000abb 8313                      	std	z+PTAB_START+2,temp2
000abc 8274                      	std	z+PTAB_START+3,_0
                                 
                                 ;   Convert Filesize to ammount of sectors
                                 ;   (calc with 512byte/sector)
000abd 8c0c                      	ldd	_tmp0,y+0x1C
000abe 8dad                      	ldd	xl,   y+0x1D
000abf 8dbe                      	ldd	xh,   y+0x1E
000ac0 8d0f                      	ldd	temp, y+0x1F
                                 
000ac1 9488                      	clc
000ac2 1007                      	cpse	_tmp0,_0		;round up
000ac3 9611                      	adiw	x,1
000ac4 1d07                      	adc	temp,_0
                                 
000ac5 9506                      	lsr	temp
000ac6 95b7                      	ror 	xh
000ac7 95a7                      	ror 	xl
                                 
000ac8 1da7                      	adc	xl,_0
000ac9 1db7                      	adc	xh,_0
000aca 1d07                      	adc	temp,_0
                                 
                                 ;   store ammount of sectors in partitiontable	
                                 
000acb 2300                      	tst	temp			;file size larger than 65535 sectors?
000acc f011                      	breq	fat_add_noprune
                                 	
000acd efaf                      	ldi	xl,255
000ace efbf                      	ldi	xh,255
                                 fat_add_noprune:
000acf 83a5                      	std	z+PTAB_SIZE,  xl
000ad0 83b6                      	std	z+PTAB_SIZE+1,xh
                                 
                                 .if FAT16_DEBUG > 1
                                 .endif
                                 		
                                 
                                 ; Table counts one more entry if it was'nt allready full
                                 
000ad1 9100 049b                 	lds	temp,ndisks
000ad3 3008                      	cpi	temp,MAXDISKS
000ad4 f019                      	breq	fat_add_nomore
000ad5 9503                      	inc	temp
000ad6 9300 049b                 	sts	ndisks,temp
                                 
                                 fat_add_nomore:
                                 
                                 #if 0
                                 #endif
000ad8 9508                      	ret
                                 
                                 
                                 ; ============================================================================
                                 ; Function: Cluster to HostSector 
                                 ; ============================================================================
                                 ; Registers:	[in]	xl,xh			Cluster Number
                                 ;		[out]	yh,yl,xh,xl		Sector Number on Disk
                                 ; Variables:	[in]	fat_clustersize		Ammount of Sectors per Cluster
                                 ;		[out]	temp			=0
                                 ; ----------------------------------------------------------------------------
                                 ; Description:
                                 ; Calculates the logical Sectornumber given the physical ClusterNumber
                                 ; and the size of a Cluster un sectors.
                                 ;
                                 ; ! Only works with Clustersizes 2,4,8,16,32,64,128 !
                                 ; ============================================================================
                                 fat_gethostsec:
                                 
                                 ; Get Offset into Data area of Disk
                                 
000ad9 2400                      	clr 	_tmp0
000ada 2411                      	clr	_tmp1
000adb 9712                      	sbiw	x,2		; Substract the 2 reserved clusters
                                 
000adc 810d                      	ldd	temp,y+o_fat_clustersize
000add 9506                      	lsr	temp
                                 fat_c2s_loop:
000ade 2300                      	tst	temp
000adf f031                      	breq	fat_c2s_end
000ae0 9506                      	lsr	temp
                                 
000ae1 0faa                      	lsl	xl
000ae2 1fbb                      	rol	xh
000ae3 1c00                      	rol	_tmp0
000ae4 1c11                      	rol	_tmp1
000ae5 cff8                      	rjmp	fat_c2s_loop
                                 fat_c2s_end:
                                 
                                 ; Add begin of data area to offset
                                 
000ae6 850a                      	ldd	temp,y+o_fat_ptr2dat+0
000ae7 0fa0                      	add	xl,temp
000ae8 850b                      	ldd	temp,y+o_fat_ptr2dat+1
000ae9 1fb0                      	adc	xh,temp
000aea 850c                      	ldd	temp,y+o_fat_ptr2dat+2
000aeb 1e00                      	adc	_tmp0,temp
000aec 850d                      	ldd	temp,y+o_fat_ptr2dat+3
000aed 1e10                      	adc	_tmp1,temp
000aee 0180                      	movw	temp,_tmp0
                                 
000aef 9508                      	ret
                                 
                                 ; ====================================================================
                                 ; Function: Searches a physical Cluster, given the logical Cluster
                                 ; ====================================================================
                                 ; Registers:	[in]	xh:xl		logical- Cluster 
                                 ;		[out]	temp2:temp	physical- Cluster
                                 ; Variables:
                                 ; --------------------------------------------------------------------
                                 ; Description:
                                 ; ====================================================================
                                 
                                 fat_find_phsy_clust:
                                 
000af0 91e0 04ae                 	lds	zl,hostdsk
000af2 d150                      	rcall 	dsk_getpartentry	; get partition entry
                                 
                                 .if FAT16_DBG_FAT > 0
                                 .endif
                                 		
                                 ; Get First FAT- Cluster Number of Diskimage
                                 	
000af3 8101                      	ldd	temp, z+1
000af4 8112                      	ldd	temp2,z+2
                                 
                                 .if FAT16_DBG_FAT > 0
                                 .endif
                                 
                                 fat_next_phsy_clust:	
000af5 15a7                      	cp	xl,_0
000af6 05b7                      	cpc	xh,_0
000af7 f131                      	breq	fat_found_phsy_clust
                                 
                                 ;	Get Next Cluster from Fat
                                 
                                 ; Trick: 512 Bytes Per Sector equals to 256 FAT- entries per Sector
                                 ; so given:  temp is the Offset within the FAT Sector
                                 ;            temp2 is the number off the FAT sector to Read 
                                 
000af8 93af                      	push 	xl
000af9 93bf                      	push 	xh
                                 
                                 ; Create FAT Offset Value
                                 
000afa 27ff                      	clr	zh
000afb 2fe0                      	mov	zl,temp
000afc 0fee                      	lsl	zl
000afd 1fff                      	rol 	zh
                                 
                                 .if FAT16_FATBUF
                                 
                                 ; Check, if required fat sector allready in buffer
                                 
000afe 890e                      	ldd	temp,y+o_fat_last_fatsect
000aff 8b1e                      	std	y+o_fat_last_fatsect,temp2
000b00 1701                      	cp	temp,temp2
000b01 f081                      	breq	fat_phys_1
                                 
                                 ; Not in buffer, get fat sector
                                 
000b02 81ae                      	ldd 	xl,   y+o_fat_ptr2fat		;get FAT start
000b03 81bf                      	ldd 	xh,   y+o_fat_ptr2fat+1
000b04 8408                      	ldd 	_tmp0,y+o_fat_ptr2fat+2
000b05 8419                      	ldd 	_tmp1,y+o_fat_ptr2fat+3
000b06 0fa1                      	add	xl,temp2			;add cluster offset within sector
000b07 1db7                      	adc	xh,_0
000b08 1c07                      	adc 	_tmp0,_0
000b09 1c17                      	adc 	_tmp1,_0
000b0a 01e0                      	movw	y,_tmp0
                                 .if 0
                                 .endif
000b0b 93ef                      	push 	zl
000b0c 93ff                      	push 	zh
000b0d e9e5
000b0e e0f2                      	ldiw	z,fat_buf
                                 
                                 ; in	zh,zl		Pointer to Word within the Sector to read	
                                 ; in	yh..xl		Start sector number (LBA)
                                 ; out	zh,zl		word thats been read
000b0f dc64                      	lcall	mmcReadSect
000b10 91ff                      	pop 	zh
000b11 91ef                      	pop 	zl
                                 
                                 fat_phys_1:
000b12 e9c5
000b13 e0d2                      	ldiw	y,fat_buf
000b14 0fec                      	add	zl,yl
000b15 1ffd                      	adc	zh,yh
000b16 8100                      	ldd	temp, z+0
000b17 8111                      	ldd	temp2,z+1
000b18 e7ce
000b19 e0d2                      	ldiw	y,fat_vars
                                 
                                 .else
                                 .endif	/* FAT16_FATBUF */
                                 
000b1a 91bf                      	pop 	xh
000b1b 91af                      	pop 	xl
                                 
                                 
                                 ;	Check next logical Cluster
                                 
000b1c 9711                      	sbiw	x,1
000b1d cfd7                      	rjmp	fat_next_phsy_clust
                                 	
                                 ; Found the physical cluster
                                 fat_found_phsy_clust:
                                 	
                                 .if FAT16_DBG_FAT > 0
                                 .endif	
                                 
000b1e 9508                      	ret
                                 
                                 ; ============================================================================
                                 ; Function: This Routine searches for the Sector within an Imagefile 
                                 ; ============================================================================
                                 ; Registers:	[out] xl,xh,yl,yh	Pointer to the sector on the SD-Card
                                 ;		[out] temp		Error variable (0= No Error)
                                 ; Variables:	[in] hostdsk		host disk #,  (partition #)
                                 ; 		[in] hostlba		host block #, relative to part.start
                                 ;		[in] fat_last_dsk	number of disk with entry in cache
                                 ;		[in] fat_log_clust	last searched logical cluster
                                 ;		[in] fat_clust_offset	offset within the cluster
                                 ;               [in] fat_clust_ptr	sector of last real cluster
                                 ; ----------------------------------------------------------------------------
                                 ; Description:
                                 ; This routine uses the variables hostdsk and hostlba to find an sector
                                 ; in the imagefile.
                                 ; The CP/M sector given within "hostlba" are splited to a logical cluster-
                                 ; number and the subsector within this logical cluster.
                                 ; logical cluster number = hostlba / fat_clustersize
                                 ; The logical cluster number will be compared to the logical cluster number
                                 ; within the cache. When this clusters are the same and the diskid's are
                                 ; also the same, then the cached physical sector will be used.
                                 ; When the clusters or the disks don't match, a seek for the physical
                                 ; cluster is performed. This seek is done thru an access over the fat of
                                 ; the fat16 partition. the routine starts at the first cluster of the 
                                 ; imagefile and goes along the linked list of clusternumber till it reaches
                                 ; the searched cluster. The found clusternumber will be used to calculate
                                 ; the sektor where this cluster lies on the sd card. Both the found physical
                                 ; cluster and the logical cluster together with the physical sectornumber
                                 ; are stored in the cache.
                                 ; The last step done is to add the subsectoroffset to the found physical
                                 ; sector. this gives the pointer to the sector to be read and or written.
                                 ; ============================================================================
                                 
                                 fat_lba_to_phys:
                                 
                                 ; ################# Get logical Number of Cluster within the imagefile
                                 ;	printstring "calc log sector"
                                 ; Logical Sectornumber in x
                                 
000b1f e7ce
000b20 e0d2                      	ldiw	y,fat_vars
                                 
000b21 018d                      	movw	temp,x
000b22 2c07                      	mov 	_tmp0,_0
000b23 2c17                      	mov 	_tmp1,_0
                                 
                                 ; Divide logical sectornumber by size of cluster in sectors
                                 
000b24 81ed                      	ldd	zl,y+o_fat_clustersize
000b25 95e6                      	lsr     zl
                                 fat_search_clst_lp:
000b26 23ee                      	tst	zl
000b27 f031                      	breq	fat_found_clst
                                 
000b28 9416                      	lsr	_tmp1
000b29 9407                      	ror	_tmp0
000b2a 95b7                      	ror	xh
000b2b 95a7                      	ror	xl
                                 	
000b2c 95e6                      	lsr	zl
                                 
000b2d cff8                      	rjmp	fat_search_clst_lp
                                 		
                                 ; at this point xh and xl are carying the logical cluster number
                                 ;	printstring "find subsector"
                                 ; ################# Get subsector within the logical cluster for later use
                                 
                                 fat_found_clst:			
000b2e 2e0a                      	mov	_tmp0,xl
000b2f 81ed                      	ldd	zl,y+o_fat_clustersize
000b30 95e6                      	lsr	zl
                                 fat_search_clst_lp2:
000b31 23ee                      	tst	zl
000b32 f019                      	breq	fat_found_subsec
000b33 0c00                      	lsl	_tmp0
                                 
000b34 95e6                      	lsr	zl
000b35 cffb                      	rjmp	fat_search_clst_lp2		
                                 
                                 fat_found_subsec:
000b36 2fe0                      	mov	zl,temp
000b37 19e0                      	sub	zl,_tmp0
000b38 8be9                      	std	y+o_fat_clust_offset,zl
                                 
                                 ; Check against last HOSTDISK searched
000b39 9000 04ae                 	lds	_tmp0,hostdsk
000b3b 841e                      	ldd	_tmp1,y+o_fat_last_dsk
000b3c 860e                      	std	y+o_fat_last_dsk,_tmp0
000b3d 1401                      	cp	_tmp0,_tmp1
000b3e f451                      	brne	fat_wrong_cache_clst
                                 
                                 ; Check against last Cluster searched
000b3f 840f                      	ldd	_tmp0,y+o_fat_log_clust
000b40 8818                      	ldd	_tmp1,y+o_fat_log_clust+1
                                 
000b41 160a                      	cp	_tmp0,xl
000b42 061b                      	cpc	_tmp1,xh
000b43 f429                      	brne	fat_wrong_cache_clst
                                 
                                 ; Last Cluster = searched Cluster -> get Sectornumber from cache
000b44 89aa                      	ldd	xl,   y+o_fat_clust_ptr
000b45 89bb                      	ldd	xh,   y+o_fat_clust_ptr+1
000b46 890c                      	ldd	temp, y+o_fat_clust_ptr+2
000b47 891d                      	ldd	temp2,y+o_fat_clust_ptr+3
                                 
000b48 c009                      	rjmp	fat_add_offset
                                 
                                 ;  Cluster is not in cache, so we must search for it
                                 fat_wrong_cache_clst:
000b49 87af                      	std	y+o_fat_log_clust,xl
000b4a 8bb8                      	std	y+o_fat_log_clust+1,xh
                                 
                                 ;  Map Logical Cluster-Number to "Physical" Cluster Number using the FAT
                                 
000b4b dfa4                      	rcall   fat_find_phsy_clust
                                 
                                 ;  Get StartSector of "physical" Cluster
                                 
000b4c 01d8                      	movw 	x,temp
000b4d df8b                      	rcall   fat_gethostsec
                                 
                                 ; Found the physical sector
                                 
                                 .if FAT16_DBG_FAT > 0
                                 .endif	
                                 
                                 ;   Save the found Sector for later use into cache
                                 
000b4e 8baa                      	std	y+o_fat_clust_ptr  ,xl
000b4f 8bbb                      	std	y+o_fat_clust_ptr+1,xh
000b50 8b0c                      	std	y+o_fat_clust_ptr+2,temp
000b51 8b1d                      	std	y+o_fat_clust_ptr+3,temp2
                                 
                                 ;   Add- Subsector to Startsector 
                                 fat_add_offset:
000b52 89e9                      	ldd	zl,y+o_fat_clust_offset
000b53 0fae                      	add	xl,zl
000b54 1db7                      	adc	xh,_0
000b55 1d07                      	adc	temp,_0
000b56 1d17                      	adc	temp2,_0
000b57 01e8                      	movw	y,temp
                                 
                                 ; Found the physical sector
                                 .if FAT16_DBG_FAT > 0
                                 .endif
                                 
000b58 9508                      	ret
                                 
                                 #endif /* FAT16_SUPPORT */
                                 
                                 ; vim:set ts=8 noet nowrap
                                 
                                 	.include "dsk_ram.asm"		; RAM- Disk Interaktion
                                 
                                 ;
                                 ;    Copyright (C) 2010 Leo C.
                                 ;
                                 ;    This file is part of avrcpm.
                                 ;
                                 ;    avrcpm is free software: you can redistribute it and/or modify it
                                 ;    under the terms of the GNU General Public License as published by
                                 ;    the Free Software Foundation, either version 3 of the License, or
                                 ;    (at your option) any later version.
                                 ;
                                 ;    avrcpm is distributed in the hope that it will be useful,
                                 ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
                                 ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                                 ;    GNU General Public License for more details.
                                 ;
                                 ;    You should have received a copy of the GNU General Public License
                                 ;    along with avrcpm.  If not, see <http://www.gnu.org/licenses/>.
                                 ;
                                 ;    $Id: dsk_ram.asm 93 2014-01-03 16:32:32Z rapid $
                                 ;
                                 
                                 #ifndef RAMDISKCNT
                                 #endif
                                 
                                 #if RAMDISKCNT
                                 #if DRAM_8BIT
                                 #else	/* 4-bit DRAM */
                                 #endif	/* DRAM_8BIT */
                                 #else  /* no ram disk */
                                 
                                 rdsk_read:
000b59 9508                      	ret
                                 rdsk_write:
000b5a 9508                      	ret
                                 rdsk_add_partition:
000b5b 9508                      	ret
                                 
                                 #endif	/* RAMDISKCNT */
                                 
                                 	.include "dsk_mgr.asm"		; Disk- Manager
                                 
                                 ;    systems
                                 ;
                                 ;    Copyright (C) 2010 Frank Zoll
                                 ;    Copyright (C) 2013 Leo C.
                                 ;
                                 ;    This file is part of avrcpm.
                                 ;
                                 ;    avrcpm is free software: you can redistribute it and/or modify it
                                 ;    under the terms of the GNU General Public License as published by
                                 ;    the Free Software Foundation, either version 3 of the License, or
                                 ;    (at your option) any later version.
                                 ;
                                 ;    avrcpm is distributed in the hope that it will be useful,
                                 ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
                                 ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                                 ;    GNU General Public License for more details.
                                 ;
                                 ;    You should have received a copy of the GNU General Public License
                                 ;    along with avrcpm.  If not, see <http://www.gnu.org/licenses/>.
                                 ;
                                 ;    $Id: dsk_mgr.asm 93 2014-01-03 16:32:32Z rapid $
                                 ;
                                 
                                 
                                 	.cseg
                                 
                                 ; ====================================================================
                                 ; Function: Scans a Disk for CP/M Partions
                                 ; ====================================================================
                                 ; Parameters
                                 ; --------------------------------------------------------------------
                                 ; 
                                 ; Registers  : [w] temp	    Number of disk images (raw and fat16) found.
                                 ;			    + 0x80 if sd card changes. (not used, doesn't work)
                                 ; SREG	:	   Z 	    according to temp
                                 ; --------------------------------------------------------------------
                                 ; Description:
                                 ; This Function scans an SD-Cards Boot-Sector for valid Partitions.
                                 ; First all original CP/M Partitions will be usesed as Drives for
                                 ; the CPM-System. Wenn all CP/M Partitions are found, a second
                                 ; scann will be made. In the second Scan, the first FAT16 Partition
                                 ; on the Disk will be used for a detailed analyses. If there
                                 ; are any Files like "cpm_x.img" are found, these Files will be
                                 ; used as Disks by the CP/M- System. ( x must be in the Range A to D )
                                 ; ====================================================================	
                                 mgr_init_partitions:
                                 
000b5c 9270 049b                 	sts	ndisks,_0		; Set Number of Disks to 0
                                 
                                 ; Initialize partition table
000b5e ebc1
000b5f e0d4                      	ldiw	y,hostparttbl
000b60 e418                      	ldi	temp2,PARTENTRY_SIZE*MAXDISKS
                                 mgr_picl:
000b61 9279                      	st	y+,_0
000b62 951a                      	dec	temp2
000b63 f7e9                      	brne	mgr_picl
                                 
                                 ; Start mmc Card interaction
000b64 dbb4                      	lcall	mmcInit
000b65 7003                      	andi	temp,MMCST_NOINIT | MMCST_NODISK
000b66 f441                      	brne	mgr_pierr
                                 	
                                 ;Load first sector from MMC (boot sector)
000b67 e0c0
000b68 e0d0                      	ldiw	y,0			; Sector 0
000b69 01de                      	movw	x,y
000b6a efe9
000b6b e0f4                      	ldiw	z,hostbuf
000b6c dc07                      	lcall	mmcReadSect
000b6d 2300                      	tst	temp
000b6e f011                      	breq	mgr_check_bootsektor
                                 
                                 mgr_pierr:
000b6f 2700                      	clr	temp
000b70 9508                      	ret
                                 
                                 mgr_check_bootsektor:
                                 ;Pointer to first table entry
000b71 ebc1
000b72 e0d4                      	ldiw	y,hostparttbl
000b73 e020                      	ldi	temp3,0			;temp3 holds number of found disks (paritions)
                                 
                                 ;Test, if it has a valid MBR
                                 
000b74 9100 06f7                 	lds	temp,hostbuf+510	;MBR signature (0xAA55)  at and of sector?
000b76 3505                      	cpi	temp,0x55		
000b77 9100 06f8                 	lds	temp,hostbuf+510+1
000b79 ea1a                      	ldi	temp2,0xAA
000b7a 0701                      	cpc	temp,temp2
000b7b f079                      	breq	mgr_search
                                 
                                 ;No MBR, no partition table ...
                                 
                                 #if CPMDSK_SUPPORT
                                 
000b7c 9523                      	inc	temp3			;pretend we have one.
000b7d 9320 049b                 	sts	ndisks,temp3
000b7f e400                      	ldi	temp,high((1<<16) * 128/512)
000b80 e110                      	ldi     temp2,dskType_CPM
000b81 8318                      	std	y+0,temp2
000b82 8279                      	std	y+1,_0			;start at beginning of card
000b83 827a                      	std	y+2,_0
000b84 827b                      	std	y+3,_0
000b85 827c                      	std	y+4,_0
000b86 827d                      	std	y+5,_0			;max CP/M 2.2 disk size
000b87 830e                      	std	y+6,temp		;
                                 
000b88 e020                      	ldi	temp3,0
000b89 d194                      	rcall	dpb_imgdata_get
                                 
                                 #endif /* CPMDSK_SUPPORT */
                                 
000b8a c01d                      	rjmp	mgr_pend
                                 
                                 mgr_search:
                                 
                                 #if CPMDSK_SUPPORT
                                 
                                 ; Search for valid Partitions and ImageFiles 
000b8b ebe7
000b8c e0f6                      	ldiw	z,hostbuf+510-64	;Point to  first byte of partition table
                                 
                                 mgr_ploop:
                                 
                                 ;	Get Partitiontype
000b8d 8104                      	ldd	temp,z+PART_TYPE
                                 
                                 ;   Test for CP/M Partition
000b8e 3502                      	cpi	temp,PARTID_CPM
000b8f f439                      	brne	mgr_nextp
                                 	
000b90 de52                      	lcall	cpm_add_partition
000b91 9523                      	inc	temp3
000b92 9320 049b                 	sts	ndisks,temp3
000b94 9629                      	adiw	y,PARTENTRY_SIZE
000b95 3028                      	cpi	temp3,MAXDISKS
000b96 f089                      	breq	mgr_pend
                                 	
                                 mgr_nextp:
000b97 9670                      	adiw	z,16
000b98 3fe7                      	cpi	zl,low(hostbuf+510)	;End of partition table reached?
000b99 f799                      	brne	mgr_ploop
                                 #endif /* CPMDSK_SUPPORT */
                                 
                                 #if FAT16_SUPPORT
                                 
                                 ; Test for FAT16 Partition
000b9a ebe7
000b9b e0f6                      	ldiw	z,hostbuf+510-64	;Point to  first byte of partition table
                                 
                                 mgr_ploop2:
                                 ;	Get Partitiontype
000b9c 8104                      	ldd	temp,z+PART_TYPE
                                 
                                 ;   Test for FAT Partition Type 1
000b9d 300e                      	cpi	temp,PARTID1_FAT16
000b9e f011                      	breq	mgr_fatfound
                                 
                                 ;   Test for FAT Partition Type 2
000b9f 3006                      	cpi	temp,PARTID2_FAT16
000ba0 f421                      	brne	mgr_nextp2
                                 
                                 mgr_fatfound:
000ba1 de6c                      	rcall	fat_add_partition
000ba2 de77                      	rcall	fat_scan_partition
000ba3 de63                      	rcall	fat_reset_cache
000ba4 c003                      	rjmp	mgr_pend		;Stop after first FAT16 partition found.
                                 
                                 mgr_nextp2:
000ba5 9670                      	adiw	zl,16
000ba6 3fe7                      	cpi	zl,low(hostbuf+510)
000ba7 f7a1                      	brne	mgr_ploop2
                                 #endif /* FAT16_SUPPORT */
                                 
                                 mgr_pend:
000ba8 2722                      	clr	temp3
                                 mgr_imgd_lp:
000ba9 9100 049b                 	lds	temp,ndisks
000bab 1720                      	cp	temp3,temp
000bac f019                      	breq	mgr_pend2
000bad d170                      	rcall	dpb_imgdata_get
000bae 9523                      	inc	temp3
000baf cff9                      	rjmp	mgr_imgd_lp
                                 
                                 mgr_pend2:
000bb0 9100 049b                 	lds	temp,ndisks	;return # of "disks"
000bb2 2300                      	tst	temp
000bb3 9508                      	ret
                                 
                                 
                                 ; ====================================================================
                                 ; Function: Print partition table info
                                 ; ====================================================================
                                 ; Parameters
                                 ; --------------------------------------------------------------------
                                 ; Registers  :  none
                                 ; Variables  :  [r] hostparttbl		Table with Partitioninformations
                                 ;               [r] hostparttbltop	Pointer to the Top of the Table
                                 ; --------------------------------------------------------------------
                                 ; Description:
                                 ; ====================================================================
                                 
                                 mgr_prnt_parttbl:
000bb4 91c0 049b                 	lds	yl,ndisks
000bb6 23cc                      	tst 	yl
000bb7 f409                      	brne	ppr_doit
000bb8 9508                      	ret
                                 
                                 ppr_doit:
000bb9 92ff                      	push	r15
000bba 92ef                      	push	r14
000bbb ebe1
000bbc e0f4                      	ldiw	z,hostparttbl
000bbd e4b1                      	ldi	xh,'A'
                                 pprl:
000bbe 940e 0223
000bc0 000d                      	printnewline
                                 
000bc1 8101                      	ldd	temp ,z+1		;Get partition start
000bc2 8112                      	ldd	temp2,z+2
000bc3 80e3                      	ldd	r14,z+3
000bc4 80f4                      	ldd	r15,z+4
                                 
                                 ; Partitiontype examining
                                 
000bc5 81a0                      	ldd 	xl,z+0
000bc6 7fa0                      	andi	xl,dskType_MASK
                                 
                                 #if CPMDSK_SUPPORT
                                 
000bc7 1507                      	cp	temp,_0			;If zero ...
000bc8 0517                      	cpc	temp2,_0
000bc9 04e7                      	cpc	r14,_0
000bca 04f7                      	cpc	r15,_0
000bcb f419                      	brne	mgr_prchkcpm		;... no partition table at 0
                                 
000bcc d029                      	rcall   mgr_prnt_diskname
000bcd d03f                      	rcall	mgr_prnt_image
000bce c00b                      	rjmp	mgr_prnt_size
                                 
                                 mgr_prchkcpm:
                                 ; CP/M ?
000bcf 31a0                      	cpi	xl,dskType_CPM
000bd0 f419                      	brne 	mgr_prtb_nocpm
000bd1 d024                      	rcall   mgr_prnt_diskname
000bd2 d02d                      	rcall	mgr_prnt_table_cpm
000bd3 c006                      	rjmp	mgr_prnt_size
                                 mgr_prtb_nocpm:
                                 #endif
                                 
                                 #if FAT16_SUPPORT
                                 ; FAT16 ?
000bd4 32a0                      	cpi	xl,dskType_FAT
000bd5 f419                      	brne 	mgr_prtb_nofat
000bd6 d01f                      	rcall   mgr_prnt_diskname
000bd7 d045                      	rcall	mgr_prnt_table_fat
000bd8 c001                      	rjmp	mgr_prnt_size
                                 mgr_prtb_nofat:
                                 #endif
                                 
                                 #if 0					/* RAMDISK is not on SD card */
                                 #if RAMDISKCNT
                                 #endif
                                 #endif
                                 
                                 ; Entry Error
000bd9 d05c                      	rcall	mgr_prnt_table_err
                                 
                                 mgr_prnt_size:
000bda 940e 01de                 	lcall	print_ultoa
000bdc 940e 0223
000bde 202c
000bdf 6973
000be0 657a
000be1 203a
000be2 0000                      	printstring ", size: "
                                 
000be3 8105                      	ldd	temp ,z+5		;Get partition size
000be4 8116                      	ldd	temp2,z+6
000be5 24ee                      	clr	r14
000be6 24ff                      	clr	r15
000be7 9516                      	lsr	temp2
000be8 9507                      	ror	temp
000be9 940e 01de                 	lcall	print_ultoa
000beb 940e 0223
000bed 424b
000bee 002e                      	printstring "KB."
                                 
                                 mgr_goto_next_part:	
000bef 9639                      	adiw	z,PARTENTRY_SIZE
000bf0 95b3                      	inc	xh
000bf1 95ca                      	dec	yl
000bf2 f659                      	brne	pprl
                                 
                                 mgr_pppre:
000bf3 90ef                      	pop	r14
000bf4 90ff                      	pop	r15
000bf5 9508                      	ret
                                 	
                                 
                                 mgr_prnt_diskname:
000bf6 930f                      	push	temp
000bf7 2f0b                      	mov	temp,xh
000bf8 940e 01a3                 	lcall	uartputc
000bfa 940e 0223
000bfc 203a
000bfd 0000                      	printstring ": "
000bfe 910f                      	pop	temp
000bff 9508                      	ret
                                 
                                 #if CPMDSK_SUPPORT
                                 mgr_prnt_table_cpm:
000c00 940e 0223
000c02 5043
000c03 4d2f
000c04 7020
000c05 7261
000c06 6974
000c07 6974
000c08 6e6f
000c09 6120
000c0a 3a74
000c0b 0020                      	printstring "CP/M partition at: "
000c0c 9508                      	ret
                                 
                                 mgr_prnt_image:
000c0d 940e 0223
000c0f 7341
000c10 7573
000c11 696d
000c12 676e
000c13 4320
000c14 2f50
000c15 204d
000c16 6d69
000c17 6761
000c18 2065
000c19 7461
000c1a 203a
000c1b 0000                      	printstring "Assuming CP/M image at: "
000c1c 9508                      	ret
                                 #endif
                                 
                                 #if FAT16_SUPPORT
                                 mgr_prnt_table_fat:
000c1d 940e 0223
000c1f 4146
000c20 3154
000c21 2036
000c22 6946
000c23 656c
000c24 492d
000c25 616d
000c26 6567
000c27 2720
000c28 0000                      	printstring "FAT16 File-Image '"
000c29 930f                      	push	temp
000c2a 2d0e                      	mov	temp,r14
000c2b 940e 01a3                 	lcall	uartputc
000c2d 24ee                      	clr	r14
000c2e 910f                      	pop	temp
000c2f 940e 0223
000c31 2027
000c32 7461
000c33 203a
000c34 0000                      	printstring "' at: "
000c35 9508                      	ret
                                 #endif
                                 
                                 #if RAMDISKCNT
                                 #endif
                                 
                                 mgr_prnt_table_err:
000c36 940e 0223
000c38 6e55
000c39 6e6b
000c3a 776f
000c3b 206e
000c3c 6e45
000c3d 7274
000c3e 2079
000c3f 7461
000c40 203a
000c41 0000                      	printstring "Unknown Entry at: "
000c42 9508                      	ret
                                 
                                 
                                 	.include "dsk_fsys.asm"		; Basic Filesystem definitions
                                 
                                 ;
                                 ;    Copyright (C) 2010 Frank Zoll
                                 ;    Copyright (C) 2010,2011,2013 Leo C.
                                 ;
                                 ;    This file is part of avrcpm.
                                 ;
                                 ;    avrcpm is free software: you can redistribute it and/or modify it
                                 ;    under the terms of the GNU General Public License as published by
                                 ;    the Free Software Foundation, either version 3 of the License, or
                                 ;    (at your option) any later version.
                                 ;
                                 ;    avrcpm is distributed in the hope that it will be useful,
                                 ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
                                 ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                                 ;    GNU General Public License for more details.
                                 ;
                                 ;    You should have received a copy of the GNU General Public License
                                 ;    along with avrcpm.  If not, see <http://www.gnu.org/licenses/>.
                                 ;
                                 ;    $Id: dsk_fsys.asm 93 2014-01-03 16:32:32Z rapid $
                                 ;
                                 
                                 
                                 ; ---------------- Defines for the Filesystem Interface -------
                                 
                                 ;*****************************************************
                                 ;*        Disk-Manager constants                     *
                                 ;*****************************************************
                                 
                                 ; Fields in the parttabl
                                 
                                 	.equ	MAXDISKS       = 8		;Max number of Disks (partitions)
                                 	.equ    PARTENTRY_SIZE = 9		;Size of a Partitiontableentry
                                 
                                 	.equ	PTAB_TYPE	= 0
                                 	.equ	PTAB_START	= 1
                                 	.equ	PTAB_SIZE	= 5
                                 	.equ	PTAB_SPT	= 7
                                 	.equ	PTAB_BSH	= 8
                                 
                                 	.equ	dskType_None	=   0 << 4
                                 	.equ	dskType_CPM	=   1 << 4
                                 	.equ	dskType_FAT	=   2 << 4
                                 ;	.equ	dskType_RAM	=   3 << 4
                                 	.equ	dskType_MASK	= 0xf << 4
                                 
                                 ;*****************************************************
                                 ;*         CP/M to host disk constants               *
                                 ;*****************************************************
                                 ;	.equ	blksize = 1024			;CP/M allocation size
                                 ;	.equ	CPMSPT = 26			;
                                 
                                 	.equ	HOSTSIZE = 512			;host disk sector size
                                 	.equ	HOSTBLK  = HOSTSIZE/128		;CP/M sects/host buff
                                 	.equ	SECMSK   = HOSTBLK-1		;sector mask
                                 	.equ	SECSHF   = log2(HOSTBLK)	;sector shift
                                 
                                 ;*****************************************************
                                 ;*        BDOS constants on entry to write           *
                                 ;*****************************************************
                                 	.equ	WRALL = 0		;write to allocated
                                 	.equ	WRDIR = 1		;write to directory
                                 	.equ	WRUAL = 2		;write to unallocated
                                 	.equ	WRTMSK= 3		;write type mask
                                 
                                 ;----------------------------------------------- Start of Data Segment
                                 
                                 	.dseg
                                 
                                 fsys_vars:
                                 
                                 ; The following 3 variables are copied from DRAM.
                                 ; Don't change order.
                                 
000495                           biosdrvtbl:	.byte	2	;
000497                           biosdirbuf:	.byte	2	;
000499                           biosenddat:	.byte	2	;
                                 
00049b                           ndisks:		.byte	1		;Number of CP/M disks
                                 	.equ o_ndisks	= ndisks-fsys_vars
                                 
                                 ; The following 5 variables are accessed from 8080/z80 via the
                                 ; virtual port interface. Don't change order.
                                 
                                 biospar_base:
00049c                           bcbadr:		.byte	2		;adr of BiosControlBlock
00049e                           seekdsk:	.byte	1		;seek disk number
00049f                           seektrk:	.byte	2		;seek track number
0004a1                           seeksec:	.byte	2		;seek sector number
0004a3                           dmaadr:		.byte	2		;last dma address
                                 	.equ o_bcbadr	= bcbadr-fsys_vars
                                 	.equ o_seekdsk	= seekdsk-fsys_vars
                                 	.equ o_seektrk	= seektrk-fsys_vars
                                 	.equ o_seeksec	= seeksec-fsys_vars
                                 	.equ o_dmaadr	= dmaadr-fsys_vars
                                 
0004a5                           hdrsize:	.byte	1		;Image header size (offset)
0004a6                           cpmspt:		.byte	1		;CP/M sectors per track
0004a7                           secpblk:	.byte	1		;sectors per block (alloc size)
0004a8                           unacnt:		.byte	1		;unalloc rec cnt
0004a9                           unadsk:		.byte	1		;last unalloc disk
0004aa                           unalba:		.byte	2		;last unalloc disk block
                                 	.equ o_hdrsize	= hdrsize-fsys_vars
                                 	.equ o_cpmspt	= cpmspt-fsys_vars
                                 	.equ o_secpblk	= secpblk-fsys_vars
                                 	.equ o_unacnt	= unacnt-fsys_vars
                                 	.equ o_unadsk	= unadsk-fsys_vars
                                 	.equ o_unalba	= unalba-fsys_vars
                                 
0004ac                           erflag:		.byte	1		;error reporting
0004ad                           wrtype:		.byte	1		;write operation type
                                 	.equ o_erflag	= erflag-fsys_vars
                                 	.equ o_wrtype	= wrtype-fsys_vars
                                 
0004ae                           hostdsk:	.byte	1		;host disk number
0004af                           hostlba:	.byte	2		;host sector number (relative to partition start)
                                 	.equ o_hostdsk	= hostdsk-fsys_vars
                                 	.equ o_hostlba	= hostlba-fsys_vars
                                 
0004b1                           hostparttbl:	.byte	PARTENTRY_SIZE*MAXDISKS ;host partition table (type, start sector, sector count)
                                 hostparttbltop:
0004f9                           hostbuf:	.byte	HOSTSIZE 	;host buffer (from/to SD-card)
                                 
                                 
                                 ; ------------------------------- Start of Code Segment
                                 	.cseg
                                 
                                 ;---------------------------------------------------------------------
                                 
                                 .if DSKSEL_DEBUG
                                 .endif
                                 	
                                 ; ====================================================================
                                 ; ====================================================================
                                 ; Function: Get a Pointer to a Partitiontable entry
                                 ; ====================================================================
                                 ; Parameters
                                 ; --------------------------------------------------------------------
                                 ; Registers  : [w] z		Pointer to the Partitionentry
                                 ;              [r] zl		Number of Diskentry to Read
                                 ;	       [w] r0		scratch
                                 ;	       [w] r1		"
                                 ; --------------------------------------------------------------------
                                 ; Description:
                                 ; ====================================================================
                                 dsk_getpartentry:
                                 	
000c43 e0f9                      	ldi	zh,PARTENTRY_SIZE
000c44 9ffe                      	mul	zh,zl
000c45 ebe1
000c46 e0f4                      	ldiw	z,hostparttbl
000c47 0de0                      	add	zl,r0
000c48 1df1                      	adc	zh,r1
000c49 9508                      	ret
                                 
                                 ; ====================================================================
                                 ; ====================================================================
                                 ; Function: Virtual Port Interface
                                 ; ====================================================================
                                 ; Parameters
                                 ; --------------------------------------------------------------------
                                 ; Registers  : 
                                 ; Variables  : 
                                 ;              
                                 ; --------------------------------------------------------------------
                                 ; Description:
                                 ; ====================================================================
                                 	
                                 dsk_param_getadr:
000c4a e9ec
000c4b e0f4                      	ldiw	z,biospar_base
000c4c 0fe2                      	add	zl,temp3
000c4d 1df7                      	adc	zh,_0
000c4e 9508                      	ret
                                 
                                 dsk_param_set:
000c4f dffa                      	rcall	dsk_param_getadr
000c50 8300                      	st	z,temp
000c51 3021                      	cpi	temp3,bcbadr+1-biospar_base
000c52 f031                      	breq	SetBCB
000c53 9508                      	ret
                                 
                                 dsk_param_get:
000c54 3022                      	cpi	temp3,seekdsk-biospar_base
000c55 f079                      	breq	dskDiskCheck
000c56 dff3                      	rcall	dsk_param_getadr
000c57 8100                      	ld	temp,z
000c58 9508                      	ret
                                 
                                 SetBCB:
000c59 91a0 049c                 	lds	xl,bcbadr
000c5b 2fb0                      	mov	xh,temp
000c5c e9e5
000c5d e0f4                      	ldiw	z,biosdrvtbl
000c5e e026                      	ldi	temp3,6
                                 sbcb_l:
000c5f dba3                      	rcall	dram_read_pp
000c60 9301                      	st	z+,temp
000c61 952a                      	dec	temp3
000c62 f7e1                      	brne	sbcb_l
                                 	
                                 ;	rcall	dbg_print_biosd
000c63 d049                      	rcall	dpb_drvtblclear
                                 ;	rcall	dbg_prdrvtbl
                                 
000c64 9508                      	ret
                                 
                                 ; ====================================================================
                                 ; Function: Check if disk exists
                                 ; ====================================================================
                                 ; Parameters
                                 ; --------------------------------------------------------------------
                                 ; Registers  : 
                                 ; Variables  : 
                                 ;		return 0,  if selected disk not exist.
                                 ;		return !0, if disk exist
                                 ; --------------------------------------------------------------------
                                 ; Description:
                                 ; ====================================================================
                                 dskDiskCheck:
000c65 9110 049b                 	lds	temp2,ndisks
000c67 9100 049e                 	lds	temp,seekdsk
                                 .if	DSKSEL_DEBUG
                                 .endif
000c69 3008                      	cpi	temp,RAMDISKNR
000c6a f4a8                      	brsh	dsk_dchrd			;maybe ramdisk
                                 
000c6b 2311                      	tst	temp2				;0 disks?
000c6c f439                      	brne	dsk_dchpart1
                                 
                                 ; No disks yet, need to init
                                 
000c6d d03f                      	rcall	dpb_drvtblclear
                                 .if 0
                                 .endif
000c6e deed                      	rcall	mgr_init_partitions		;disk chanched?
000c6f 930f                      	push	temp
                                 .if 0
                                 .endif
                                 
                                 ;	rcall	dbg_prdrvtbl
000c70 911f                      	pop	temp2
                                 dsk_dchpart0:
000c71 771f                      	cbr	temp2,0x80
000c72 9100 049e                 	lds	temp,seekdsk
                                 	
                                 ; Check if selected disk # is less then # of disks.
                                 
                                 dsk_dchpart1:
000c74 1701                      	cp	temp,temp2
000c75 f440                      	brsh	dsk_dch_err
                                 
                                 .if	DSKSEL_DEBUG
                                 .endif
000c76 d034                      	rcall	dpb_drvtbl_entry_get
000c77 2b01                      	or	temp,temp2		;if !0, drive is allready initialized
000c78 f421                      	brne	dsk_dchend
000c79 9120 049e                 	lds	temp3,seekdsk
000c7b 2f02                      	mov	temp,temp3
000c7c d0e5                      	rcall	dpb_biosdph_get
                                 dsk_dchend:
                                 
                                 .if	DSKSEL_DEBUG
                                 .endif	
                                 
000c7d 9508                      	ret
                                 
                                 dsk_dch_err:
000c7e e000                      	ldi	temp,0			;error return
000c7f 9508                      	ret	
                                 	
                                 ;	Check RAMDISK
                                 
                                 dsk_dchrd:
                                 #if RAMDISKCNT
                                 #endif
                                 dsk_dchrd_err:
000c80 e000                      	ldi	temp,0			;error return
000c81 9508                      	ret
                                 
                                 
                                 ; ====================================================================
                                 ; Function: Return status of last disk i/o function
                                 ; ====================================================================
                                 ; Parameters
                                 ; --------------------------------------------------------------------
                                 ; Registers  : 
                                 ; Variables  : 
                                 ; --------------------------------------------------------------------
                                 ; Description:
                                 ; ====================================================================
                                 
                                 dskErrorRet:
000c82 9100 04ac                 	lds	temp,erflag
000c84 9508                      	ret
                                 
                                 		
                                 ; ====================================================================
                                 ; ====================================================================
                                 
                                 
                                 
                                 str_CPM_Disk:
000c85 3c0a
000c86 5043
000c87 5f4d
000c88 6944
000c89 6b73
000c8a 003e                      	.db	10,"<CPM_Disk>",0
                                 
                                 ;  DPBs for varios fixed formats
                                 ;  dpb data starts at 2. byte
                                 
                                 dpbdat_avrcpm: 			;(dpb243)
000c8b 1a00                      	.db 0x00,0x1A		;sector offset, low(spt)
000c8c 0300                      	.db 0x00,0x03		;high (spt), block shift 
000c8d 0007                      	.db 0x07,0x00		;bock mask, extent mask 
000c8e 00f2                      	.db 0xF2,0x00		;disk size - 1,
000c8f 003f                      	.db 0x3F,0x00		;dir max 
000c90 00c0                      	.db 0xC0,0x00		;alloc0, alloc1
000c91 0010                      	.db 0x10,0x00		;chk size
000c92 0002                      	.db 0x02,0x00		;offset
                                 
                                 dpbdat_myz80: 			;
000c93 8002                      	.db 0x02,0x80		;sector offset, low(spt)
000c94 0500                      	.db 0x00,0x05		;high (spt), block shift 
000c95 011f                      	.db 0x1F,0x01		;bock mask, extent mask 
000c96 07ff                      	.db 0xFF,0x07		;disk size - 1,
000c97 03ff                      	.db 0xFF,0x03		;dir max 
000c98 00ff                      	.db 0xFF,0x00		;alloc0, alloc1
000c99 0100                      	.db 0x00,0x01		;chk size
000c9a 0000                      	.db 0x00,0x00		;offset
                                 
                                 dpbdat_simhd: 			;
000c9b 2000                      	.db 0x00,0x20		;sector offset, low(spt)
000c9c 0500                      	.db 0x00,0x05		;high (spt), block shift 
000c9d 011f                      	.db 0x1F,0x01		;bock mask, extent mask 
000c9e 07f9                      	.db 0xF9,0x07		;disk size - 1,
000c9f 03ff                      	.db 0xFF,0x03		;dir max 
000ca0 00ff                      	.db 0xFF,0x00		;alloc0, alloc1
000ca1 0100                      	.db 0x00,0x01		;chk size
000ca2 0006                      	.db 0x06,0x00		;offset
                                 
                                 #if 0
                                 #endif
                                 
                                 
                                 
                                 ; ====================================================================
                                 ; Function: get drive table entry pointer for drive # in temp
                                 ; ====================================================================
                                 ; Parameters
                                 ; --------------------------------------------------------------------
                                 ; Registers  : 
                                 ; Variables  : 
                                 ;              
                                 ; --------------------------------------------------------------------
                                 ; Description:
                                 ; ====================================================================
                                 
                                 dpb_drvtbl_entry_p:
                                 
000ca3 91a0 0495
000ca5 91b0 0496                 	ldsw	x,biosdrvtbl
000ca7 0f00                      	lsl	temp			;drive #
000ca8 0fa0                      	add	xl,temp
000ca9 1db7                      	adc	xh,_0
000caa 9508                      	ret
                                 	
                                 
                                 ; ====================================================================
                                 ; Function: get drive table entry for drive # in temp
                                 ; ====================================================================
                                 ; Parameters
                                 ; --------------------------------------------------------------------
                                 ; Registers  : 
                                 ; Variables  : 
                                 ;              
                                 ; --------------------------------------------------------------------
                                 ; Description:
                                 ; ====================================================================
                                 
                                 dpb_drvtbl_entry_get:
                                 
000cab dff7                      	rcall	dpb_drvtbl_entry_p
000cac cb4e                      	ljmp	dram_readw_pp		
                                 
                                 
                                 ; ====================================================================
                                 ; Function: Clear drive table (entries 0 to 7)
                                 ; ====================================================================
                                 ; Parameters
                                 ; --------------------------------------------------------------------
                                 ; Registers  : 
                                 ; Variables  : 
                                 ;              
                                 ; --------------------------------------------------------------------
                                 ; Description:
                                 ; ====================================================================
                                 
                                 ;
                                 
                                 dpb_drvtblclear:
000cad 91a0 0495
000caf 91b0 0496                 	ldsw	x,biosdrvtbl
000cb1 9710                      	sbiw	x,0
000cb2 f071                      	breq	dpb_drvi_ex
                                 	
                                 dpb_drvi_1:
000cb3 e028                      	ldi	temp3,8
                                 dpb_drvi_lp:
000cb4 e000                      	ldi	temp,0
000cb5 e010                      	ldi	temp2,0
000cb6 db4f                      	rcall	dram_writew_pp
000cb7 952a                      	dec	temp3
000cb8 f7d9                      	brne	dpb_drvi_lp
                                 	
000cb9 9100 0499                 	lds	temp,biosenddat
000cbb 9110 049a                 	lds	temp2,biosenddat+1
000cbd 1507                      	cp	temp,_0
000cbe 0517                      	cpc	temp2,_0
000cbf f009                      	breq	dpb_drvi_ex
                                 
000cc0 d9c0                      	rcall	heap_init
                                 dpb_drvi_ex:
000cc1 2700                      	clr	temp
000cc2 9508                      	ret
                                 
                                 ; ====================================================================
                                 ; Function: Test disk format: avrcpmhd
                                 ; ====================================================================
                                 ; Parameters
                                 ; --------------------------------------------------------------------
                                 ; Registers  : temp		drive #
                                 ;              
                                 ; --------------------------------------------------------------------
                                 ; Description: Not implemented yet.
                                 ; ====================================================================
                                 
                                 dsk_tst_avrcpmhd:
000cc3 2700                      	clr	temp		; Test, return 'not found' for now.
000cc4 9508                      	ret
                                 
                                 
                                 ; ====================================================================
                                 ; Function: Test disk format: YAZE
                                 ; ====================================================================
                                 ; Parameters
                                 ; --------------------------------------------------------------------
                                 ; Registers  : temp		drive #
                                 ;              
                                 ; --------------------------------------------------------------------
                                 ; Description: From the YAZE Doc:
                                 ;
                                 ; The new disk header occupies the first 128 BYTES of the file and has the
                                 ; new format:
                                 ;
                                 ;          0 -   9    <CPM_Disk>
                                 ;         10 -  15    a null-terminated ascii comment (may be empty)
                                 ;     new 16          version (0 = yaze-1.06/1.10, 1 = yaze-ag-2.xx)
                                 ;         17 -  31    a null-terminated ascii comment (may be empty)
                                 ;         32 -  33    sectors per track
                                 ;         34          block shift factor
                                 ;         35          block mask
                                 ;         36          extent mask
                                 ;         37 -  38    disk size max
                                 ;         39 -  40    directory max
                                 ;         41          al0
                                 ;         42          al1
                                 ;         43 -  44    check size (always zero)
                                 ;         45 -  46    track offset
                                 ;     new 47          psh (used if version=1 and CP/M 3.1 is running)
                                 ;     new 48          phm ( "   "    "   "    "   "   "   "    "    )
                                 ;         49 - 127    unused (zeros)
                                 ; ====================================================================
                                 
                                 
                                 dsk_tst_yaze:
                                 
000cc5 efc9
000cc6 e0d4                      	ldiw	y,hostbuf
000cc7 e0ea
000cc8 e1f9                      	ldiw	z,str_CPM_Disk*2
000cc9 9115                      	lpm	temp2,z+		; get length
000cca 940e 0242                 	lcall	strncmp_p
000ccc f439                      	brne	dsk_tyze_not
                                 	
000ccd e1e8
000cce e0f5                      	ldiw	z,hostbuf+31
000ccf 94e8                      	clt				;dpb in RAM
000cd0 e001                      	ldi	temp,1			;1 sector header size
000cd1 8300                      	st	z,temp
                                 
000cd2 6f0f                      	ori	temp,0xff
000cd3 9508                      	ret
                                 
                                 dsk_tyze_not:
000cd4 2700                      	clr	temp			;Not a YAZE disk image.
000cd5 9508                      	ret
                                 	
                                 ; ====================================================================
                                 ; Function: Test disk format: MyZ80
                                 ; ====================================================================
                                 ; Parameters
                                 ; --------------------------------------------------------------------
                                 ; Registers  : temp		drive #
                                 ;              
                                 ; --------------------------------------------------------------------
                                 ; Description:	Test, if first 2 Sectors are filled with 0xE5,
                                 ; 		and Size = 8192KB + 256Bytes.
                                 ; ====================================================================
                                 
                                 dsk_tst_myz80:
                                 
000cd6 2fe2                      	mov	zl,temp3
000cd7 df6b                      	rcall	dsk_getpartentry	;get partition entry
000cd8 8105                      	ldd	temp,z+PTAB_SIZE
000cd9 8116                      	ldd	temp2,z+PTAB_SIZE+1	;check, if size is 16385 phys. sectors
000cda 3001                      	cpi	temp,low(16385)
000cdb e400                      	ldi	temp,high(16385)
000cdc 0710                      	cpc	temp2,temp
000cdd f469                      	brne	dsk_tmyz80_not		;wrong size
                                 	
000cde efe9
000cdf e0f4                      	ldiw	z,hostbuf
000ce0 e010                      	ldi	temp2,0
                                 	
                                 dsk_tmyz80_loop:
000ce1 9101                      	ld	temp,z+
000ce2 3e05                      	cpi	temp,0xE5
000ce3 f439                      	brne	dsk_tmyz80_not
000ce4 951a                      	dec	temp2
000ce5 f7d9                      	brne	dsk_tmyz80_loop
                                 
000ce6 e2e6
000ce7 e1f9                      	ldiw	z,dpbdat_myz80*2
000ce8 9468                      	set
000ce9 6f0f                      	ori	temp,0xff
000cea 9508                      	ret
                                 
                                 dsk_tmyz80_not:
000ceb 2700                      	clr	temp			;Not a MyZ80 hard disk image.
000cec 9508                      	ret
                                 	
                                 ; ====================================================================
                                 ; Function: Test disk format: simhd, simh altair 8800 hard disk format
                                 ; ====================================================================
                                 ; Parameters
                                 ; --------------------------------------------------------------------
                                 ; Registers  : temp		drive #
                                 ;              
                                 ; --------------------------------------------------------------------
                                 ; Description:	Test, if Size = 8192 KB and 
                                 ;		first 6 tracks are filled with 0xE5.
                                 ;		Actually, only the first phys. sector is tested, since 
                                 ;		the other 47 sectors are not in memory at this time.
                                 ; ====================================================================
                                 
                                 dsk_tst_simhd:
                                 
000ced 2fe2                      	mov	zl,temp3
000cee df54                      	rcall	dsk_getpartentry	;get partition entry
000cef 8105                      	ldd	temp,z+PTAB_SIZE
000cf0 8116                      	ldd	temp2,z+PTAB_SIZE+1	;check, if size is 16384 phys. sectors
000cf1 3000                      	cpi	temp,low(16384)
000cf2 e400                      	ldi	temp,high(16384)
000cf3 0710                      	cpc	temp2,temp
000cf4 f4b9                      	brne	dsk_tsimhd_not		;wrong size
                                 	
000cf5 e6cf
000cf6 e0d5                      	ldiw	y,hostbuf+128-10
000cf7 e0ea
000cf8 e1f9                      	ldiw	z,str_CPM_Disk*2
000cf9 9115                      	lpm	temp2,z+		; get length
000cfa 940e 0242                 	lcall	strncmp_p
000cfc f051                      	breq	dsk_tsimhd_found
                                 	
000cfd efe9
000cfe e0f4                      	ldiw	z,hostbuf
000cff e012                      	ldi	temp2,high(512)
000d00 2400                      	clr	_tmp0			;low(512)
                                 dsk_tsimhd_loop:
000d01 9101                      	ld	temp,z+
000d02 3e05                      	cpi	temp,0xE5
000d03 f441                      	brne	dsk_tsimhd_not
000d04 0c06                      	add	_tmp0,_255
000d05 1d16                      	adc	temp2,_255
000d06 f7d1                      	brne	dsk_tsimhd_loop
                                 
                                 dsk_tsimhd_found:
000d07 e3e6
000d08 e1f9                      	ldiw	z,dpbdat_simhd*2
000d09 9468                      	set
000d0a 6f0f                      	ori	temp,0xff
000d0b 9508                      	ret
                                 
                                 dsk_tsimhd_not:
000d0c 2700                      	clr	temp			;Not a simhd hard disk image.
000d0d 9508                      	ret
                                 	
                                 ; ====================================================================
                                 ; Function: 
                                 ; ====================================================================
                                 ; Parameters
                                 ; --------------------------------------------------------------------
                                 ; Registers  : temp3		drive #
                                 ;              
                                 ; --------------------------------------------------------------------
                                 ; Description:
                                 ; ====================================================================
                                 
                                 dsk_format_get:
                                 
                                 ; Get first sector (512 byte) of current drive into hostbuf.
                                 
000d0e e000                      	ldi	temp,0			
000d0f e010                      	ldi	temp2,0			;
000d10 d168                      	rcall	dsk_readhost_lba
                                 	
                                 ; Test for variable format avrcpmhd.
                                 
000d11 dfb1                      	rcall	dsk_tst_avrcpmhd
000d12 f451                      	brne	dsk_imgt_done
                                 
                                 ; Test for YAZE formats.
                                 
000d13 dfb1                      	rcall	dsk_tst_yaze
000d14 f441                      	brne	dsk_imgt_done
                                 
                                 ; Test for simhd format.
                                 
000d15 dfd7                      	rcall	dsk_tst_simhd
000d16 f431                      	brne	dsk_imgt_done
                                 
                                 ; Test for MyZ80 format.
                                 
000d17 dfbe                      	rcall	dsk_tst_myz80
000d18 f421                      	brne	dsk_imgt_done
                                 	
                                 ; No special image found. Use avrcpm.
                                 
000d19 e1e6
000d1a e1f9                      	ldiw	z,dpbdat_avrcpm*2
000d1b 9468                      	set
000d1c 6f0f                      	ori	temp,0xff
                                 
                                 dsk_imgt_done:
000d1d 9508                      	ret	
                                 
                                 ; ====================================================================
                                 ; Function: Add CP/M image format data to partition table data
                                 ; ====================================================================
                                 ; Parameters
                                 ; --------------------------------------------------------------------
                                 ; Registers  : temp3		drive #
                                 ;              
                                 ; --------------------------------------------------------------------
                                 ; Description:
                                 ; ====================================================================
                                 
                                 dpb_imgdata_get:
                                 
                                 ; Test for known CP/M formats 
                                 
000d1e dfef                      	rcall	dsk_format_get	
000d1f f1b1                      	breq	dpb_imgd_err		;no known format detected
                                 
                                 dpb_imgd_0:
000d20 f42e                      	brtc	dpb_imgd_variable
                                 dpb_imgd_fixed:
000d21 9105                      	lpm	temp, z+		;image header
000d22 91c5                      	lpm	yl,z+			;low(SPT)
000d23 91d5                      	lpm	yh,z+			;high(SPT)
000d24 9115                      	lpm	temp2,z+		;BSH
000d25 c004                      	rjmp	dpb_imgd_common
                                 
                                 dpb_imgd_variable:
000d26 9101                      	ld	temp, z+		;image header
000d27 91c1                      	ld	yl,z+			;low(SPT)
000d28 91d1                      	ld	yh,z+			;high(SPT)
000d29 9111                      	ld	temp2,z+		;BSH
                                 
                                 dpb_imgd_common:
000d2a 2fe2                      	mov	zl,temp3
000d2b df17                      	rcall	dsk_getpartentry	;get partition entry
000d2c 83c7                      	std	z+PTAB_SPT,yl
000d2d 23dd                      	tst	yh			;more then 256 sectors per track?
000d2e f149                      	breq	dpb_imgd_1		;todo: support 16 bit sector numbers
                                 
                                 dsk_imgprp_err:
000d2f 940e 0223
000d31 000d                      	printnewline
000d32 e401                      	ldi	temp,'A'
000d33 0f02                      	add	temp,temp3
000d34 940e 01a3                 	lcall	uartputc
000d36 940e 0223
000d38 203a
000d39 6f46
000d3a 6d72
000d3b 7461
000d3c 6e20
000d3d 746f
000d3e 7320
000d3f 7075
000d40 6f70
000d41 7472
000d42 6465
000d43 203a
000d44 6f54
000d45 206f
000d46 756d
000d47 6863
000d48 7320
000d49 6365
000d4a 6f74
000d4b 7372
000d4c 7020
000d4d 7265
000d4e 7420
000d4f 6172
000d50 6b63
000d51 2021
000d52 0000                      	printstring ": Format not supported: Too much sectors per track! "
000d53 940e 0223
000d55 000d                      	printnewline
                                 
                                 dpb_imgd_err:
000d56 2700                      	clr	temp
000d57 9508                      	ret
                                 
                                 dpb_imgd_1:
000d58 701f                      	andi	temp2,0x0f
000d59 9512                      	swap	temp2
000d5a 8710                      	std	z+PTAB_BSH,temp2
                                 	
000d5b 700f                      	andi	temp,~dskType_MASK
000d5c 8110                      	ldd	temp2,z+PTAB_TYPE
000d5d 7f10                      	andi	temp2,dskType_MASK
000d5e 2b01                      	or	temp,temp2
000d5f 8300                      	std	z+PTAB_TYPE,temp
                                 
000d60 6f0f                      	ori	temp,255
000d61 9508                      	ret
                                 
                                 ; ====================================================================
                                 ; Function: 
                                 ; ====================================================================
                                 ; Parameters
                                 ; --------------------------------------------------------------------
                                 ; Registers  : temp		drive #
                                 ;              
                                 ;			return !0 if ok
                                 ;				0 on error
                                 ; --------------------------------------------------------------------
                                 ; Description: Init CP/M data structures 
                                 ;
                                 ;       -----------------------------------------------------------------
                                 ; DPH:  |  XLT  |       |       |       |DIRBUF |  DPB  |  CSV  |  ALV  |
                                 ;       -----------------------------------------------------------------
                                 ;offset: 0       2       4       6       8       10      12      14
                                 ;
                                 ;       -------------------------------------------------------------
                                 ; DPB:  |  SPT  |BSH|BLM|EXM|  DSM  |  DRM  |AL0|AL1|  CKS  |  OFF  |
                                 ;       -------------------------------------------------------------
                                 ;offset: 0       2   3   4   5       7       9   10  11      13    
                                 ; ====================================================================
                                 
                                 dpb_biosdph_get:
000d62 2f20                      	mov	temp3,temp		;save disk #
                                 
000d63 dfaa                      	rcall	dsk_format_get	
000d64 f409                      	brne	dpb_di_0
000d65 c04c                      	rjmp	dpb_di_err
                                 
                                 dpb_di_0:
                                 
                                 ; get mem for DPH 
                                 
000d66 e100                      	ldi	temp, low (16)
000d67 e010                      	ldi	temp2,high(16)
000d68 d91d                      	rcall	heap_get		;returns ptr to dph mem
000d69 f409                      	brne	dpb_di_1
000d6a c047                      	rjmp	dpb_di_err		;
                                 dpb_di_1:
000d6b 01d8                      	movw	x,temp
000d6c 01e8                      	movw	y,temp			;save dph pointer
000d6d e000                      	ldi	temp,0
000d6e e010                      	ldi	temp2,0
000d6f da96                      	rcall	dram_writew_pp		;XLT
000d70 9616                      	adiw	x,6
000d71 9100 0497                 	lds	temp,biosdirbuf
000d73 9110 0498                 	lds	temp2,biosdirbuf+1
000d75 da90                      	rcall	dram_writew_pp		;DIRBUF
                                 
                                 ; get mem for DPB	
                                 	
000d76 e00f                      	ldi	temp, low (15)
000d77 e010                      	ldi	temp2,high(15)
000d78 d90d                      	rcall	heap_get
000d79 f1b1                      	breq	dpb_di_err_p1
000d7a 01d8                      	movw	x,temp
                                 	
000d7b 9631                      	adiw	z,1			;skip sector offset byte
000d7c 932f                      	push	temp3
000d7d e02f                      	ldi	temp3,15
                                 dpb_dicpl:
000d7e f40e                      	brtc	PC+2			;
000d7f 9105                      	 lpm	temp,z+
000d80 f00e                      	brts	PC+2			;
000d81 9101                      	 ld	temp,z+
000d82 da86                      	rcall	dram_write_pp
000d83 952a                      	dec	temp3
000d84 f7c9                      	brne	dpb_dicpl
000d85 912f                      	pop	temp3
000d86 971f                      	sbiw	x,15
000d87 973f                      	sbiw	z,15
000d88 018d                      	movw	temp,x
000d89 01de                      	movw	x,y
000d8a 961a                      	adiw	x,10
000d8b da7a                      	rcall	dram_writew_pp		;DPB
                                 
000d8c f43e                      	brtc	dpb_dicks_variable
                                 dpb_dicks_fixed:
000d8d 9635                      	adiw	z,5
000d8e 9005                      	lpm	_tmp0,z+		;dsm
000d8f 9015                      	lpm	_tmp1,z+
000d90 9634                      	adiw	z,11-5-2
000d91 9105                      	lpm	temp,z+			;cks
000d92 9115                      	lpm	temp2,z+
000d93 c004                      	rjmp	dpb_dicks_common
                                 dpb_dicks_variable:
000d94 8005                      	ldd	_tmp0,z+5		;dsm
000d95 8016                      	ldd	_tmp1,z+5+1
000d96 8503                      	ldd	temp,z+11		;cks
000d97 8514                      	ldd	temp2,z+11+1
                                 
                                 ; get mem for dir check vector
                                 
                                 dpb_dicks_common:
000d98 1507                      	cp	temp,_0
000d99 0517                      	cpc	temp2,_0
000d9a f011                      	breq	dpb_dicks0
000d9b d8ea                      	rcall	heap_get
000d9c f099                      	breq	dpb_di_err_p1
                                 dpb_dicks0:
000d9d da68                      	rcall	dram_writew_pp		;CSV
                                 
                                 ; get mem for alloc vector
                                 
000d9e 0180                      	movw	temp,_tmp0
000d9f 5f08                      	subi	temp, low (-8)
000da0 4f1f                      	sbci	temp2,high(-8)
000da1 9516                      	lsr	temp2
000da2 9507                      	ror	temp
000da3 9516                      	lsr	temp2
000da4 9507                      	ror	temp
000da5 9516                      	lsr	temp2
000da6 9507                      	ror	temp			;(dsm+1+7)/8
000da7 d8de                      	rcall	heap_get
000da8 f039                      	breq	dpb_di_err_p1
000da9 da5c                      	rcall	dram_writew_pp		;ALV
                                 
                                 ; success, insert DPH into drvtbl
                                 
000daa 2f02                      	mov	temp,temp3
000dab def7                      	rcall	dpb_drvtbl_entry_p
000dac 018e                      	movw	temp,y
000dad da58                      	rcall	dram_writew_pp	
                                 
000dae 6f0f                      	ori	temp,0xff		;return ok
000daf 9508                      	ret
                                 
                                 ; error, free mem
                                 
                                 dpb_di_err_p1:
000db0 018e                      	movw	temp,y
000db1 d8cf                      	rcall	heap_release
                                 dpb_di_err:
000db2 2700                      	eor	temp,temp		;return 0 (+ Z-flag)
000db3 9508                      	ret
                                 	
                                 ; ====================================================================
                                 ; Function: 
                                 ; ====================================================================
                                 ; Parameters
                                 ; --------------------------------------------------------------------
                                 ; Registers  : 
                                 ;
                                 ; --------------------------------------------------------------------
                                 ; Description:
                                 ; ====================================================================
                                 
                                 dsk_setdrvparam:
000db4 8110                      	ldd	temp2,z+PTAB_TYPE
000db5 701f                      	andi	temp2,~dskType_MASK	;Lower nibble is image header size
000db6 8b18                      	std	y+o_hdrsize,temp2
000db7 8117                      	ldd	temp2,z+PTAB_SPT
000db8 8b19                      	std	y+o_cpmspt,temp2		;CP/M sectors per track
000db9 8510                      	ldd	temp2,z+PTAB_BSH
000dba 9512                      	swap	temp2
000dbb 701f                      	andi	temp2,0x0f
000dbc 2400                      	clr	_tmp0
000dbd 9403                      	inc	_tmp0
                                 dsk_sdrvpl:
000dbe 0c00                      	lsl	_tmp0
000dbf 951a                      	dec	temp2
000dc0 f7e9                      	brne	dsk_sdrvpl
000dc1 8a0a                      	std	y+o_secpblk,_tmp0		;Sectors per block
000dc2 9508                      	ret
                                 	
                                 
                                 ; ====================================================================
                                 ; Function: Does a Disk interaction
                                 ; ====================================================================
                                 ; Parameters
                                 ; --------------------------------------------------------------------
                                 ; Registers  : 
                                 ; Variables  : 
                                 ;              
                                 ; --------------------------------------------------------------------
                                 ; Description:
                                 ; ====================================================================
                                 
                                 dskDoIt:
                                 
000dc3 e9c5
000dc4 e0d4                      	ldiw	y,fsys_vars
000dc5 8a7f                      	std	y+o_erflag,_0
                                 
                                 .if DISK_DEBUG
                                 .if DISK_DEBUG > 1
                                 .endif
                                 .endif
                                 
                                 	;See what has to be done.
000dc6 fd07                      	sbrc	temp,READ_FUNC
000dc7 c024                      	rjmp	dsk_readwrite
000dc8 fd06                      	sbrc	temp,WRITE_FUNC
000dc9 c022                      	rjmp	dsk_readwrite
000dca fd04                      	sbrc	temp,HOME_FUNC
000dcb c01d                      	rjmp	dsk_home
000dcc fd05                      	sbrc	temp,BOOT_FUNC
000dcd c017                      	rjmp	dsk_boot
                                 
000dce 940e 0223
000dd0 4944
000dd1 4b53
000dd2 4920
000dd3 4f2f
000dd4 203a
000dd5 6e49
000dd6 6176
000dd7 696c
000dd8 2064
000dd9 7546
000dda 636e
000ddb 6974
000ddc 6e6f
000ddd 6320
000dde 646f
000ddf 3a65
000de0 0020                      	printstring "DISK I/O: Invalid Function code: "
000de1 940e 0212                 	lcall	printhex
000de3 940c 101f                 	ljmp	haltinv
                                 
                                 dsk_boot:
000de5 827e                      	std	y+o_ndisks,_0	;no active partitions
                                 dsk_inval_hostbuf:
000de6 98f7                      	cbi	flags,hostact	;host buffer inactive
000de7 8a7b                      	std	y+o_unacnt,_0	;clear unalloc count
000de8 9508                      	ret
                                 
                                 dsk_home:
000de9 9bf6                      	sbis	flags,hostwrt	;check for pending write
000dea 98f7                      	cbi	flags,hostact	;clear host active flag
000deb 9508                      	ret
                                 
                                 
                                 
                                 
                                 dsk_readwrite:
                                 
                                 ; RAM disk?
                                 
000dec 85e9                      	ldd     zl,y+o_seekdsk
                                 #if RAMDISKCNT
                                 #endif
000ded de55                      	rcall 	dsk_getpartentry	;Get Paritiontableentry
000dee 8110                      	ld    	temp2,z			;Get Partitiontype
000def 7f10                      	andi	temp2,dskType_MASK
                                 
                                 ; Isn't it a Disk ?
                                 
000df0 3010                      	cpi	temp2,dskType_None
000df1 f409                      	brne	PC+2
000df2 9508                      	ret				;return error
                                 
                                 ; It must be a FAT16-Imagefile or CP/M Partition.
                                 
000df3 fd06                      	sbrc	temp,WRITE_FUNC
000df4 c006                      	 rjmp	dsk_write
                                 
000df5 9af4                      	sbi	flags,readop		;Set read operation flag
000df6 9af5                      	sbi	flags,rsflag		;must read data
000df7 8a7b                      	std	y+o_unacnt,_0
000df8 e002                      	ldi	temp,WRUAL		;write type
000df9 8f08                      	std	y+o_wrtype,temp		;treat as unalloc
000dfa c003                      	rjmp	dsk_rw
                                 
                                 dsk_write:
000dfb 98f4                      	cbi	flags,readop		;Not a read operation
000dfc 7003                      	andi	temp,WRTMSK
000dfd 8f08                      	std	y+o_wrtype,temp		;save write type
                                 dsk_rw:
000dfe dfb5                      	rcall	dsk_setdrvparam		;todo: do this only if needed (disk change)
                                 
                                 ; Convert track/sector to an LBA address (in 128byte blocks)
                                 
000dff 85ac                      	ldd	xl,y+o_seeksec		;
000e00 e0b0                      	ldi	xh,0			;
000e01 e010                      	ldi	temp2,0			;
000e02 8908                      	ldd	temp,y+o_hdrsize	;add image header size
000e03 0fa0                      	add	xl,temp			;
000e04 1db7                      	adc	xh,_0			;
000e05 8909                      	ldd	temp,y+o_cpmspt		;
000e06 840a                      	ldd	_tmp0,y+o_seektrk	;
000e07 9d00                      	mul	temp,_tmp0		;
000e08 0da0                      	add	xl,r0			;
000e09 1db1                      	adc	xh,r1			;
000e0a 840b                      	ldd	_tmp0,y+o_seektrk+1	;
000e0b 9d00                      	mul	temp,_tmp0		;
000e0c 0db0                      	add	xh,r0			;temp2:xh:xl := sec + trk * SectorsPerTrack
000e0d 1d11                      	adc	temp2,r1		;
000e0e 2f2a                      	mov	temp3,xl
000e0f 7023                      	andi	temp3,SECMSK		;mask buffer number
                                 
                                 ; Convert from CP/M LBA blocks to host LBA blocks
                                 
000e10 e002                      	ldi	temp,SECSHF
                                 dsk_sh1:
000e11 9516                      	lsr	temp2
000e12 95b7                      	ror	xh
000e13 95a7                      	ror	xl
000e14 950a                      	dec	temp
000e15 f7d9                      	brne	dsk_sh1
                                 					;todo: temp2 should be 0 here. 
                                 					;xh:xl = host block to seek
                                 ; 
000e16 99f4                      	sbic	flags,readop
000e17 c029                      	 rjmp	dsk_rwoper		;to perform the read
                                 
                                 ; Write operation
                                 
000e18 98f5                      	cbi	flags,rsflag		;rsflag = 0
000e19 8d08                      	ldd	temp,y+o_wrtype		;
000e1a 3002                      	cpi	temp,WRUAL		;write unallocated?
000e1b f461                      	brne	dsk_chkuna		;check for unalloc
                                 
                                 ; write to unallocated, set parameters
                                 
000e1c 890a                      	ldd	temp,y+o_secpblk	;next unalloc recs (blocksize/128)
000e1d 3020                      	cpi	temp3,0			;cpm sector on phys. sector boundary?
000e1e f021                      	breq	dsk_una1
000e1f 9af5                      	sbi	flags,rsflag		;  no, rsflag = 1
000e20 5004                      	subi	temp,HOSTBLK		;don't write
000e21 8808                      	ldd	_tmp0,y+o_hdrsize	;  in next bock
000e22 0d00                      	add	temp,_tmp0		;  if there is a header
                                 dsk_una1:
000e23 8b0b                      	std	y+o_unacnt,temp
000e24 8509                      	ldd	temp,y+o_seekdsk	;disk to seek
000e25 8b0c                      	std	y+o_unadsk,temp		;unadsk = sekdsk
000e26 8bad                      	std	y+o_unalba,  xl		;unalba = seeklba (== hostlba)
000e27 8bbe                      	std	y+o_unalba+1,xh
                                 
                                 ; check for write to unallocated sector
                                 
                                 dsk_chkuna:
                                 
000e28 890b                      	ldd	temp,y+o_unacnt		;any unalloc remain?
000e29 2300                      	tst	temp
000e2a f0a1                      	breq	dsk_alloc		;skip if not
                                 
                                 ; more unallocated records remain
                                 
000e2b 950a                      	dec	temp			;unacnt = unacnt-1
000e2c 8b0b                      	std	y+o_unacnt,temp
000e2d 8509                      	ldd	temp,y+o_seekdsk	;same disk?
000e2e 891c                      	ldd	temp2,y+o_unadsk
000e2f 1701                      	cp	temp,temp2		;seekdsk = unadsk?
000e30 f471                      	brne	dsk_alloc		;skip if not
                                 
                                 ; disks are the same
                                 
000e31 880d                      	ldd	_tmp0,y+o_unalba
000e32 881e                      	ldd	_tmp1,y+o_unalba+1
000e33 160a                      	cp	_tmp0,xl		;seeklba = unalba?
000e34 061b                      	cpc	_tmp1,xh
000e35 f449                      	brne	dsk_alloc		;skip if not
                                 
                                 ; block address is the same
                                 ; move to next sector for future ref
                                 
000e36 2f02                      	mov	temp,temp3
000e37 9503                      	inc	temp			;next part
000e38 7003                      	andi	temp,SECMSK
000e39 f421                      	brne	dsk_noovf		;skip if no overflow
                                 
                                 ; overflow to next block
                                 
000e3a 1806                      	sub	_tmp0,_255		;unalba = unalba+1
000e3b 0816                      	sbc	_tmp1,_255
000e3c 8a0d                      	std	y+o_unalba,  _tmp0
000e3d 8a1e                      	std	y+o_unalba+1,_tmp1
                                 
                                 dsk_noovf:
000e3e c002                      	rjmp	dsk_rwoper		;to perform the write
                                 
                                 ; not an unallocated record, requires pre-read
                                 
                                 dsk_alloc:
000e3f 8a7b                      	std	y+o_unacnt,_0		;unacnt = 0
000e40 9af5                      	sbi	flags,rsflag		;rsflag = 1
                                 
                                 
                                 ; Enter here to perform the read/write
                                 
                                 dsk_rwoper:
                                 
                                 .if DISK_DEBUG > 1
                                 .endif
                                 
000e41 932f                      	push	temp3
000e42 018d                      	movw	temp,x
000e43 8529                      	ldd	temp3,y+o_seekdsk
000e44 d03a                      	rcall	dsk_rw_hostbuf
000e45 910f                      	pop	temp			;get back buffer number (which part of hostbuf)
000e46 e9c5
000e47 e0d4                      	ldiw	y,fsys_vars
                                 
                                 ; copy data to or from buffer
                                 
000e48 efe9
000e49 e0f4                      	ldiw	z,hostbuf
000e4a e820                      	ldi	temp3,128
000e4b 9f02                      	mul	temp,temp3
000e4c 0de0                      	add	zl,r0			;offset in hostbuf
000e4d 1df1                      	adc	zh,r1
                                 
000e4e 85ae                      	ldd	xl,y+o_dmaadr
000e4f 85bf                      	ldd	xh,y+o_dmaadr+1
000e50 99f4                      	sbic	flags,readop		;which way?
000e51 c011                      	rjmp	dsk_rmove		;skip if read
                                 
                                 ; mark write operation
000e52 9af6                      	sbi	flags,hostwrt		;hostwrt = 1
                                 dsk_wmove:
000e53 b9bb
000e54 b828
000e55 b9ab
000e56 b838
000e57 b87a
000e58 b848
000e59 c000
000e5a 0000
000e5b b109
000e5c b868
000e5d b86a                      	mem_read
000e5e 9301                      	st	z+,temp
000e5f 9611                      	adiw	xl,1
000e60 952a                      	dec	temp3
000e61 f789                      	brne 	dsk_wmove
000e62 c00b                      	rjmp	dsk_rwmfin
                                 	
                                 dsk_rmove:
000e63 9101                      	ld	temp,z+
000e64 b9bb
000e65 b828
000e66 b9ab
000e67 b838
000e68 b90b
000e69 b858
000e6a b868                      	mem_write
000e6b 9611                      	adiw	xl,1
000e6c 952a                      	dec	temp3
000e6d f7a9                      	brne	dsk_rmove
                                 
                                 dsk_rwmfin:
                                 ; data has been moved to/from host buffer
000e6e 8d08                      	ldd	temp,y+o_wrtype		;write type
000e6f 3001                      	cpi	temp,WRDIR		;to directory?
000e70 f009                      	breq	dsk_wdir
000e71 9508                      	ret				;no further processing
                                 
                                 ; clear host buffer for directory write
                                 dsk_wdir:
000e72 890f                      	ldd	temp,y+o_erflag
000e73 2300                      	tst	temp			;errors?
000e74 f009                      	breq	dsk_wdir1
000e75 9508                      	ret				;skip if so
                                 
                                 dsk_wdir1:
000e76 d029                      	rcall	dsk_writehost		;clear host buff
000e77 98f6                      	cbi	flags,hostwrt		;buffer written
000e78 9508                      	ret
                                 
                                 ; ====================================================================
                                 ; Function: 
                                 ; ====================================================================
                                 ; Parameters
                                 ; --------------------------------------------------------------------
                                 ; Registers  :	temp2:temp	block to read (lba)
                                 ;		temp3		disk #
                                 ;              
                                 ; --------------------------------------------------------------------
                                 ; Description:
                                 ; ====================================================================
                                 
                                 dsk_readhost_lba:
                                 
                                 .if HOSTRW_DEBUG
                                 .endif
000e79 9af5                      	sbi	flags,rsflag		;must read data
000e7a d004                      	rcall	dsk_rw_hostbuf
000e7b 9100 04ac                 	lds	temp,erflag		;returns 0, if ok
000e7d 2300                      	tst	temp
000e7e 9508                      	ret
                                 
                                 ; ====================================================================
                                 ; Function: Get physical disk sector in hostbuf.
                                 ; ====================================================================
                                 ; Parameters
                                 ; --------------------------------------------------------------------
                                 ; Registers  :	temp2:temp	host block to read/write (lba)
                                 ;		temp3		disk #
                                 ;              
                                 ; --------------------------------------------------------------------
                                 ; Description: 
                                 ; ====================================================================
                                 dsk_rw_hostbuf:
000e7f e9c5
000e80 e0d4                      	ldiw	y,fsys_vars
                                 					;xh:xl = host block to seek
000e81 8a7f                      	std	y+o_erflag,_0		;no errors (yet)
                                 
                                 ; active host sector?
                                 
000e82 b20e                      	in	_tmp0,flags		;host active flag
000e83 9af7                      	sbi	flags,hostact		;always becomes 1
000e84 fe07                      	sbrs	_tmp0,hostact		;was it already?
000e85 c011                      	rjmp	dsk_filhst		;fill host if not
                                 
                                 ; host buffer active, same as seek buffer?
                                 
000e86 8c09                      	ldd	_tmp0,y+o_hostdsk		;same disk?
000e87 1520                      	cp	temp3,_tmp0		;seekdsk = hostdsk?
000e88 f429                      	brne	dsk_nomatch
                                 
                                 ; same disk, same block?
                                 
000e89 8c0a                      	ldd	_tmp0,y+o_hostlba
000e8a 1500                      	cp	temp, _tmp0
000e8b 8c0b                      	ldd	_tmp0,y+o_hostlba+1
000e8c 0510                      	cpc	temp2,_tmp0
000e8d f089                      	breq	dsk_match
                                 
                                 dsk_nomatch:
                                 	;proper disk, but not correct sector
000e8e 9bf6                      	sbis	flags,hostwrt		;host written?
000e8f c007                      	rjmp	dsk_filhst
000e90 932f                      	push	temp3
000e91 931f                      	push	temp2
000e92 930f                      	push	temp
000e93 d00c                      	rcall	dsk_writehost		;clear host buff
000e94 910f                      	pop	temp
000e95 911f                      	pop	temp2
000e96 912f                      	pop	temp3
                                 
                                 ; may have to fill the host buffer
                                 dsk_filhst:
000e97 e9c5
000e98 e0d4                      	ldiw	y,fsys_vars
000e99 8f0a                      	std	y+o_hostlba,temp
000e9a 8f1b                      	std	y+o_hostlba+1,temp2
000e9b 8f29                      	std	y+o_hostdsk,temp3
                                 
000e9c 99f5                      	sbic	flags,rsflag		;need to read?
000e9d d00f                      	rcall	dsk_readhost		;yes, if 1
000e9e 98f6                      	cbi	flags,hostwrt		;no pending write
                                 
                                 dsk_match:
000e9f 9508                      	ret
                                 
                                 ; ====================================================================
                                 ; Function: Does a Disk write operation
                                 ; ====================================================================
                                 ; Parameters
                                 ; --------------------------------------------------------------------
                                 ; Registers  : none
                                 ; Variables  : [r] seekdsk		Number of Disk to Read
                                 ;			   [r] seeksec		Sector to read
                                 ;              [r] seektrk		Track  to read
                                 ; --------------------------------------------------------------------
                                 ; Description:
                                 ; ====================================================================
                                 
                                 dsk_writehost:
                                 
                                 .if HOSTRW_DEBUG
                                 .if DISK_DEBUG == 0
                                 .else
                                 .endif
                                 .endif
                                 
000ea0 d019                      	rcall	dsk_hostparam
000ea1 f041                      	breq	dsk_hstwr_err
                                 	
000ea2 efe9
000ea3 e0f4                      	ldiw	z,hostbuf
000ea4 d8d3                      	rcall	mmcWriteSect
000ea5 2300                      	tst	temp
000ea6 f419                      	brne	dsk_hstwr_err
                                 	
                                 dsk_hstwr_ok:
000ea7 9270 04ac                 	sts	erflag,_0
000ea9 9508                      	ret
                                 
                                 dsk_hstwr_err:
000eaa 9260 04ac                 	sts	erflag,_255
000eac 9508                      	ret
                                 
                                 ; ====================================================================
                                 ; Function: Does a Disk read operation
                                 ; ====================================================================
                                 ; Parameters
                                 ; --------------------------------------------------------------------
                                 ; Registers  : none
                                 ; Variables  : [r] seekdsk		Number of Disk to Read
                                 ;			   [r] seeksec		Sector to read
                                 ;              [r] seektrk		Track  to read
                                 ; --------------------------------------------------------------------
                                 ; Description:
                                 ; ====================================================================
                                 
                                 dsk_readhost:
                                 
                                 .if HOSTRW_DEBUG
                                 .if DISK_DEBUG == 0
                                 .else
                                 .endif
                                 .endif
                                 
000ead d00c                      	rcall	dsk_hostparam
000eae f041                      	breq	dsk_hstrd_err
                                 	
000eaf efe9
000eb0 e0f4                      	ldiw	z,hostbuf
000eb1 d8c2                      	lcall	mmcReadSect
000eb2 2300                      	tst	temp
000eb3 f419                      	brne	dsk_hstrd_err
                                 
                                 dsk_hstrd_ok:
000eb4 9270 04ac                 	sts	erflag,_0
000eb6 9508                      	ret
                                 
                                 dsk_hstrd_err:
000eb7 9260 04ac                 	sts	erflag,_255
000eb9 9508                      	ret
                                 
                                 ; ====================================================================
                                 ; Function: Does a Disk write operation
                                 ; ====================================================================
                                 ; Parameters
                                 ; --------------------------------------------------------------------
                                 ; Registers  : none
                                 ; Variables  : [r] seekdsk		Number of Disk to Read
                                 ;			   [r] seeksec		Sector to read
                                 ;              [r] seektrk		Track  to read
                                 ; hostdsk = host disk #,  (partition #)
                                 ; hostlba = host block #, relative to partition start 
                                 ; Read/Write "hostsize" bytes to/from hostbuf
                                 ; --------------------------------------------------------------------
                                 ; Description:
                                 ; ====================================================================	
                                 
                                 dsk_hostparam:
                                 
000eba 91e0 04ae                 	lds    zl,hostdsk
                                 
                                 .if HOSTRW_DEBUG
                                 .endif
000ebc dd86                      	rcall  dsk_getpartentry
000ebd 91a0 04af                 	lds	xl,hostlba		; get sector to access
000ebf 91b0 04b0                 	lds	xh,hostlba+1
                                 
                                 .if HOSTRW_DEBUG
                                 .endif
                                 
000ec1 8005                      	ldd	_tmp0,z+PTAB_SIZE		; get disksize
000ec2 8016                      	ldd	_tmp1,z+PTAB_SIZE+1
                                 	
000ec3 15a0                      	cp	xl,_tmp0			; check given sector against disksize
000ec4 05b1                      	cpc	xh,_tmp1
000ec5 f468                      	brcc	dsk_hst_param_err
                                 
000ec6 8100                      	ldd     temp,z+PTAB_TYPE
000ec7 7f00                      	andi	temp,dskType_MASK
                                 
                                 #if FAT16_SUPPORT
                                 ; Is it a FAT16 Diskimage ?
000ec8 3200                      	cpi	temp,dskType_FAT
000ec9 f411                      	brne	dsk_hstpar_nofat
000eca dc54                      	rcall	fat_lba_to_phys
000ecb c005                      	rjmp	dsk_hstpar_gotit
                                 dsk_hstpar_nofat:
                                 #endif
                                 #if CPMDSK_SUPPORT
                                 ; Is it a CP/M Partition ?
000ecc 3100                      	cpi	temp,dskType_CPM
000ecd f411                      	brne	dsk_hstpar_nocpm
000ece db0b                      	lcall	cpm_lba_to_phys
000ecf c001                      	rjmp	dsk_hstpar_gotit
                                 dsk_hstpar_nocpm:
                                 #endif
                                 ; Disktype not supported
000ed0 c002                      	rjmp	dsk_hst_param_err
                                 
                                 dsk_hstpar_gotit:
                                 
                                 .if HOSTRW_DEBUG
                                 .endif
                                 
000ed1 6f0f                      	ori	temp,255
000ed2 9508                      	ret
                                 
                                 dsk_hst_param_err:
                                 
                                 .if HOSTRW_DEBUG
                                 .endif
                                 	
000ed3 2700                      	clr	temp
000ed4 9508                      	ret
                                 
                                 ; --------------------------------------------------------------------
                                 ; vim:set ts=8 noet nowrap
                                 
                                 
                                 ; <<<-------------------------------------- File System Management
                                 
                                 ;	.include "8080int-orig.asm"	;Old 8080 interpreter.
                                 ;	.include "8080int.asm"		;New 8080 interpreter.
                                 ;	.include "8080int-t3.asm"	;Another 8080 interpreter
                                 ;	.include "8080int-t3-jmp.asm"	;Can't get enough
                                 ;	.include "8080int-jmp.asm"	;
                                 	.include "Z80int-jmp.asm"	;
                                 
                                 ; This is part of the Z80-CP/M emulator written by Sprite_tm.
                                 ; 
                                 
                                 ;    Copyright (C) 2010 Sprite_tm
                                 ;    Copyright (C) 2010-2013 Leo C.
                                 ;    Copyright (C) 2010 Horst S.
                                 
                                 ;    This file is part of avrcpm.
                                 ;
                                 ;    avrcpm is free software: you can redistribute it and/or modify it
                                 ;    under the terms of the GNU General Public License as published by
                                 ;    the Free Software Foundation, either version 3 of the License, or
                                 ;    (at your option) any later version.
                                 ;
                                 ;    avrcpm is distributed in the hope that it will be useful,
                                 ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
                                 ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                                 ;    GNU General Public License for more details.
                                 ;
                                 ;    You should have received a copy of the GNU General Public License
                                 ;    along with avrcpm.  If not, see <http://www.gnu.org/licenses/>.
                                 ;
                                 ;    $Id: Z80int-jmp.asm 93 2014-01-03 16:32:32Z rapid $
                                 ;
                                 
                                 #if EM_Z80
                                 
                                 	.dseg
                                 z_regs:	
                                 z_c2:
                                 	.equ	oz_c2 = z_c2 - z_regs
0006f9                           	.byte	1
                                 z_b2:
                                 	.equ	oz_b2 = z_b2 - z_regs
0006fa                           	.byte	1
                                 z_e2:
                                 	.equ	oz_e2 = z_e2 - z_regs
0006fb                           	.byte	1
                                 z_d2:
                                 	.equ	oz_d2 = z_d2 - z_regs
0006fc                           	.byte	1
                                 z_l2:
                                 	.equ	oz_l2 = z_l2 - z_regs
0006fd                           	.byte	1
                                 z_h2:
                                 	.equ	oz_h2 = z_h2 - z_regs
0006fe                           	.byte	1
                                 z_f2:
                                 	.equ	oz_f2 = z_f2 - z_regs
0006ff                           	.byte	1
                                 z_a2:
                                 	.equ	oz_a2 = z_a2 - z_regs
000700                           	.byte	1
                                 
                                 z_xl:
                                 	.equ	oz_xl = z_xl - z_regs
000701                           	.byte	1
                                 z_xh:
                                 	.equ	oz_xh = z_xh - z_regs
000702                           	.byte	1
                                 z_yl:
                                 	.equ	oz_yl = z_yl - z_regs
000703                           	.byte	1
                                 z_yh:
                                 	.equ	oz_yh = z_yh - z_regs
000704                           	.byte	1
                                 z_i:
                                 	.equ	oz_i  = z_i - z_regs
000705                           	.byte	1
                                 z_r:
                                 	.equ	oz_r  = z_r - z_regs
000706                           	.byte	1
                                 
                                 z_istat:
                                 	.equ	oz_istat = z_istat - z_regs
000707                           	.byte	1
                                 
                                 	.equ IM_MASK = 0x03		;Mask IM 0..2
                                 	.equ IM0     = 0
                                 	.equ IM1     = 1
                                 	.equ IM2     = 2
                                 
                                 	.equ IFF1 = 2			;IFF1 Flag
                                 	.equ IFF2 = 3			;IFF2 Flag
                                 #endif
                                 
                                 	.cseg
                                 	
                                 ;Init z80
                                 z80_init:
000ed5 e080
000ed6 e290                      	ldiw	z_pc,IPLADDR
000ed7 efc9
000ed8 e0d6                      	ldiw	y,z_regs
                                 
000ed9 2733                      	clr	intstat
                                 
000eda 940e 0223
000edc 000d                      	printnewline
                                 
                                 .if INS_DEBUG
                                 .endif
                                 
000edd 940e 0223
000edf 6b4f
000ee0 202c
000ee1 385a
000ee2 2d30
000ee3 5043
000ee4 2055
000ee5 7369
000ee6 6c20
000ee7 7669
000ee8 2165
000ee9 0000                      	printstring "Ok, "CPUSTR"-CPU is live!"
000eea 940e 0223
000eec 000d                      	printnewline
                                 
                                 main:
                                 
                                 .if PRINT_PC
                                 .endif
                                 
                                 	;TODO: hier kommt die Interruptbehandlung rein
                                 
000eed 1137                      	cpse	intstat,_0			; 2 Fast path if no trace, int, break, ...
000eee c00f                      	rjmp	int_test
                                 
                                 int_instr:
000eef b99b
000ef0 b828
000ef1 b98b
000ef2 b838
000ef3 b87a
000ef4 b848
000ef5 c000
000ef6 0000
000ef7 b1e9
000ef8 b868
000ef9 b86a                      	mem_read_ds zl,z_pc			;11 zl = memReadByte(z_pc)
000efa 9601                      	adiw	z_pcl,1				; 2 ++z_pc
000efb e1f3                      	ldi	zh,high(opcjmp)			; 1
000efc 9509                      	icall					; 3  (+4 ret)
000efd cfef                      	rjmp	main				; 2
                                 						; / 25 cycles minimum (NOP)
                                 int_test:
000efe ff31                      	sbrs	intstat,i_trace
000eff c008                      	rjmp	int_notrace
000f00 fd32                      	sbrc	intstat,i_halt
000f01 c006                      	rjmp	int_notrace
000f02 3091                      	cpi	z_pch,DBG_TRACE_BOTTOM
000f03 f020                      	brlo	int_notrace
000f04 3d9c                      	cpi	z_pch,DBG_TRACE_TOP
000f05 f410                      	brsh	int_notrace
000f06 940e 02b9                 	lcall	printregs
                                 int_notrace:
000f08 ff30                      	sbrs	intstat,i_break
000f09 c011                      	rjmp	int_nobreak
000f0a 7f3a                      	cbr	intstat,(1<<i_break)|(1<<i_halt)
000f0b 940e 0223
000f0d 000d                      	printnewline
000f0e 940e 0223
000f10 7242
000f11 6165
000f12 206b
000f13 6564
000f14 6574
000f15 7463
000f16 6465
000f17 2021
000f18 0000                      	printstring "Break detected! "
000f19 2d87                      	mov	z_pcl,_0
000f1a 2d97                      	mov	z_pch,_0
                                 int_nobreak:
                                 
000f1b cfd3                      	rjmp	int_instr		;Continue with normal instruction interpretation
                                 
                                 
                                 ;--------------------------------------------------
                                 ; init opcode table 
                                 ;
                                 ; 	opctable opc_name, pos
                                 ;
                                 
                                 .macro	opctable
                                 
                                 
                                   .set opcjmp_table_pos_ = (@1 + 255) & -0x100		;0xff00
                                 
                                   .ifndef opc_tabnext_
                                     .set opc_tabnext_ = opcjmp_table_pos_
                                 
                                     .set opc_tablow_0 = 0
                                     .set opc_tablen_0 = 0
                                     .set opc_tablow_1 = 0
                                     .set opc_tablen_1 = 0
                                   .endif
                                 
                                   .if opcjmp_table_pos_ < opc_tabnext_
                                     .set opcjmp_table_pos_ = opc_tabnext_
                                   .endif
                                 
                                   .if opc_tablow_0 == 0
                                     .set opc_tablow_0 = opcjmp_table_pos_
                                     .set opc_tablen_0 = 256
                                 ;.message "add tab_0"
                                   .elif opc_tablow_1 == 0
                                     .if (opc_tablow_0 + opc_tablen_0) == opcjmp_table_pos_
                                       .set opc_tablen_0 = opc_tablen_0 + 256
                                 ;.message "    tab_0++"
                                     .else
                                       .set opc_tablow_1 = opcjmp_table_pos_
                                       .set opc_tablen_1 = 256
                                 ;.message "add tab_1"
                                     .endif
                                   .else  
                                     .if (opc_tablow_1 + opc_tablen_1) == opcjmp_table_pos_
                                       .set opc_tablen_1 = opc_tablen_1 + 256
                                 ;.message     "tab_1++"
                                     .else
                                       .error "Tab full_"
                                     .endif
                                   .endif
                                 
                                   .set opc_tabnext_ = opcjmp_table_pos_ + 256
                                   .equ @0 = opcjmp_table_pos_
                                 
                                 .endm
                                 
                                 ;--------------------------------------------------
                                 ; 
                                 ;	checkspace frompos, size
                                 ;
                                 .macro checkspace
                                 
                                   .ifdef opc_tablow_0
                                     .if @0 <=  opc_tablow_0
                                       .if (@0 + @1) >  opc_tablow_0
                                         .org opc_tablow_0 + opc_tablen_0
                                 ;        .message "skip tab, remove tab_0"
                                         .if opc_tablow_1 == 0
                                           .set opc_tablow_0 = 0
                                           .set opc_tablen_0 = 0
                                         .else
                                           .set opc_tablow_0 = opc_tablow_1
                                           .set opc_tablen_0 = opc_tablen_1
                                           .set opc_tablow_1 = 0
                                           .set opc_tablen_1 = 0
                                 ;          .message "remove tab_1"
                                         .endif
                                       .endif
                                     .endif
                                   .endif
                                 .endm
                                 
                                 ;--------------------------------------------------
                                 ; Generate a table entry for one instruction
                                 ;
                                 ; 	instr fetch, op, store
                                 ;
                                 .macro	instr	
                                 
                                   .set fetch_ = (do_@0 != do_fetch_nop)		; must call or jump to fetch action
                                   .set op_    = (do_@1 != do_op_nop)		; must call or jump to op action
                                   .set store_ = (do_@2 != do_store_nop)		; must jump to store action
                                   .set cnt_ = fetch_ + op_ + store_		; number of actions for this instruction
                                 
                                 
                                   .set done_ = 0
                                   .set pc_save_ = PC
                                 
                                   .if cnt_ == 0					; nothing to do (nop)
                                     .org opcjmp_table_pos_
                                     ret						; go back to main
                                     .org pc_save_
                                     .set done_ = 1
                                   .elif cnt_ == 1				; jump direct to action
                                     .if fetch_
                                       .set action_1_ = do_@0
                                     .elif op_
                                       .set action_1_ = do_@1
                                     .else
                                       .set action_1_ = do_@2
                                     .endif
                                     .if (opcjmp_table_pos_ - action_1_) <= 2047
                                        .org opcjmp_table_pos_
                                         rjmp action_1_				; do op and return to main
                                        .org pc_save_
                                       .set done_ = 1
                                     .endif
                                   .endif
                                 
                                   .if !done_
                                 
                                     .if defined (l_@0_@1_@2)
                                 
                                       .if (opcjmp_table_pos_ - l_@0_@1_@2) <= 2047
                                         .org opcjmp_table_pos_
                                         rjmp l_@0_@1_@2				; generate a jump to action table
                                         .org pc_save_
                                       .else
                                         checkspace pc_save_, 2
                                         .set pc_save_ = PC
                                         .org opcjmp_table_pos_
                                         rjmp pc_save_
                                         .org pc_save_
                                 	jmp l_@0_@1_@2
                                       .endif
                                 
                                     .else
                                 
                                       checkspace pc_save_, 2*cnt_
                                       .set pc_save_ = PC
                                 
                                       .org opcjmp_table_pos_
                                       .equ l_@0_@1_@2 = pc_save_		; make a label
                                       rjmp l_@0_@1_@2				; generate a jump to action table
                                 
                                       .org l_@0_@1_@2
                                 
                                       .if fetch_				; must fetch
                                         .if op_ || store_ 
                                           .if do_@0 == 0
                                             m_do_@0
                                           .else
                                             lcall do_@0				; fetch and come back here
                                           .endif
                                         .else
                                           .if do_@0 == 0
                                             m_do_@0
                                             ret
                                           .else
                                             ljmp do_@0				; do op and return to main
                                           .endif
                                         .endif
                                       .endif
                                       .if op_					; must exec op
                                         .if store_
                                           .if do_@1 == 0
                                             m_do_@1
                                           .else
                                             lcall do_@1				; fetch and come back here
                                           .endif
                                         .else
                                           .if do_@1 == 0
                                             m_do_@1
                                             ret
                                           .else
                                             ljmp do_@1				; do op and return to main
                                           .endif
                                         .endif
                                       .endif
                                       .if store_				; must store
                                         .if do_@2 == 0
                                           m_do_@2
                                           ret
                                         .else
                                           ljmp do_@2				; store is allways last
                                         .endif
                                       .endif    
                                 
                                     .endif
                                   .endif
                                 
                                   .set opcjmp_table_pos_ = opcjmp_table_pos_ + 1
                                 
                                 .endm
                                 
                                 
                                 do_x_nop:
000f1c 9508                      	ret
                                 
                                 ; ------------ Fetch phase stuff -----------------
                                 
                                 
                                 fetch_ops:
                                 .equ do_fetch_nop = do_x_nop
                                 
                                 do_fetch_rst:
000f1d 01dc                      	movw x,z_pcl
000f1e 9711                      	sbiw x,1
000f1f b9bb
000f20 b828
000f21 b9ab
000f22 b838
000f23 b87a
000f24 b848
000f25 c000
000f26 0000
000f27 b169
000f28 b868
000f29 b86a                      	mem_read_d opl
000f2a 7368                      	andi opl,0x38
000f2b e070                      	ldi oph,0
000f2c 9508                      	ret
                                 
                                 .macro m_do_fetch_a
                                 	mov opl,z_a
                                 .endm
                                 
                                 .equ do_fetch_a = 0
                                 ;	mov opl,z_a
                                 ;	ret
                                 
                                 .macro m_do_fetch_b
                                 	mov	opl,z_b
                                 .endm
                                 
                                 .equ do_fetch_b = 0
                                 ;	mov	opl,z_b
                                 ;	ldd opl,y+oz_b
                                 ;	ret
                                 
                                 .macro m_do_fetch_c
                                 	mov	opl,z_c
                                 .endm
                                 
                                 .equ do_fetch_c = 0
                                 ;	mov	opl,z_c
                                 ;	ldd	opl,y+oz_c
                                 ;	ret
                                 
                                 .macro m_do_fetch_d
                                 	mov	opl,z_d
                                 .endm
                                 
                                 .equ do_fetch_d = 0
                                 ;	ldd	opl,y+oz_d
                                 ;	ret
                                 
                                 .macro m_do_fetch_e
                                 	mov	opl,z_e
                                 .endm
                                 
                                 .equ do_fetch_e = 0
                                 ;	ldd	opl,y+oz_e
                                 ;	ret
                                 
                                 .macro m_do_fetch_h
                                 	mov	opl,z_h
                                 .endm
                                 
                                 .equ do_fetch_h = 0
                                 ;	mov	opl,z_h
                                 ;	ret
                                 
                                 .macro m_do_fetch_l
                                 	mov	opl,z_l
                                 .endm
                                 
                                 .equ do_fetch_l = 0
                                 ;	mov	opl,z_l
                                 ;	ret
                                 
                                 .macro m_do_fetch_af
                                 	movw	opl,z_flags
                                 .endm
                                 
                                 .equ do_fetch_af = 0
                                 ;	movw	opl,z_flags
                                 ;	ret
                                 
                                 .macro m_do_fetch_bc
                                 	movw	opl,z_c
                                 .endm
                                 
                                 .equ do_fetch_bc = 0
                                 ;	movw	opl,z_c
                                 ;	ret
                                 
                                 .macro m_do_fetch_de
                                 	movw	opl,z_e
                                 .endm
                                 
                                 .equ do_fetch_de = 0
                                 ;	movw	opl,z_e
                                 ;	ret
                                 
                                 .macro m_do_fetch_hl
                                 	movw	opl,z_l
                                 .endm
                                 
                                 .equ do_fetch_hl = 0
                                 ;	movw	opl,z_l
                                 ;	ret
                                 
                                 .macro m_do_fetch_sp
                                 	movw opl,z_spl
                                 .endm
                                 
                                 .equ do_fetch_sp = 0
                                 ;	movw opl,z_spl
                                 ;	ret
                                 
                                 do_fetch_mbc:
                                 ;	movw	x,z_c
000f2d b89b
000f2e b828
000f2f b88b
000f30 b838
000f31 b87a
000f32 b848
000f33 c000
000f34 0000
000f35 b159
000f36 b868
000f37 b86a                      	mem_read_ds z_a, z_bc
000f38 9508                      	ret
                                 
                                 do_fetch_mde:
                                 ;	movw	x,z_e
000f39 b8bb
000f3a b828
000f3b b8ab
000f3c b838
000f3d b87a
000f3e b848
000f3f c000
000f40 0000
000f41 b159
000f42 b868
000f43 b86a                      	mem_read_ds z_a, z_de
000f44 9508                      	ret
                                 
                                 do_fetch_mhl:
                                 ;	movw	x,z_l
000f45 b8db
000f46 b828
000f47 b8cb
000f48 b838
000f49 b87a
000f4a b848
000f4b c000
000f4c 0000
000f4d b169
000f4e b868
000f4f b86a                      	mem_read_ds opl, z_hl
000f50 9508                      	ret
                                 
                                 do_fetch_msp:
000f51 01d7                      	movw x,z_spl
000f52 b9bb
000f53 b828
000f54 b9ab
000f55 b838
000f56 b87a
000f57 b848
000f58 c000
000f59 0000
000f5a b169
000f5b b868
000f5c b86a                      	mem_read_d opl
000f5d 9611                      	adiw x,1
000f5e b9bb
000f5f b828
000f60 b9ab
000f61 b838
000f62 b87a
000f63 b848
000f64 c000
000f65 0000
000f66 b179
000f67 b868
000f68 b86a                      	mem_read_d oph
000f69 9508                      	ret
                                 
                                 do_fetch_dir8:
000f6a b99b
000f6b b828
000f6c b98b
000f6d b838
000f6e b87a
000f6f b848
000f70 c000
000f71 0000
000f72 b169
000f73 b868
000f74 b86a                      	mem_read_ds opl, z_pc
000f75 9601                      	adiw z_pcl,1
000f76 9508                      	ret
                                 
                                 do_fetch_dir16:
000f77 b99b
000f78 b828
000f79 b98b
000f7a b838
000f7b b87a
000f7c b848
000f7d c000
000f7e 0000
000f7f b169
000f80 b868
000f81 b86a                      	mem_read_ds opl, z_pc
000f82 9601                      	adiw z_pcl,1
000f83 b99b
000f84 b828
000f85 b98b
000f86 b838
000f87 b87a
000f88 b848
000f89 c000
000f8a 0000
000f8b b179
000f8c b868
000f8d b86a                      	mem_read_ds oph, z_pc
000f8e 9601                      	adiw z_pcl,1
000f8f 9508                      	ret
                                 
                                 ; ------------ Store phase stuff -----------------
                                 
                                 store_ops:
                                 .equ do_store_nop = do_x_nop
                                 
                                 	
                                 do_store_a:
000f90 2f56                      	mov z_a,opl
000f91 9508                      	ret
                                 
                                 ;.macro m_do_store_b 
                                 ;	std	y+oz_b,opl
                                 ;.endm
                                 ;.equ do_store_b = 0
                                 do_store_b:
000f92 2e96                      	mov	z_b,opl
000f93 9508                      	ret
                                 
                                 do_store_c:
000f94 2e86                      	mov	z_c,opl
000f95 9508                      	ret
                                 
                                 do_store_d:
000f96 2eb6                      	mov	z_d,opl
000f97 9508                      	ret
                                 
                                 do_store_e:
000f98 2ea6                      	mov	z_e,opl
000f99 9508                      	ret
                                 
                                 do_store_h:
000f9a 2ed6                      	mov	z_h,opl
000f9b 9508                      	ret
                                 
                                 do_store_l:
000f9c 2ec6                      	mov	z_l,opl
000f9d 9508                      	ret
                                 
                                 do_store_af:
000f9e 01ab                      	movw z_flags,opl
000f9f 9508                      	ret
                                 
                                 do_store_bc:
000fa0 014b                      	movw	z_c,opl
000fa1 9508                      	ret
                                 
                                 do_store_de:
000fa2 015b                      	movw	z_e,opl
                                 ;	std	y+oz_d,oph
                                 ;	std	y+oz_e,opl
000fa3 9508                      	ret
                                 
                                 do_store_hl:
000fa4 016b                      	movw	z_l,opl
000fa5 9508                      	ret
                                 
                                 do_store_mbc:
                                 ;	movw	x,z_c
000fa6 b89b
000fa7 b828
000fa8 b88b
000fa9 b838
000faa b95b
000fab b858
000fac b868                      	mem_write_ds z_bc, z_a
000fad 9508                      	ret
                                 
                                 do_store_mde:
                                 ;	movw	x,z_e
000fae b8bb
000faf b828
000fb0 b8ab
000fb1 b838
000fb2 b95b
000fb3 b858
000fb4 b868                      	mem_write_ds z_de, z_a
000fb5 9508                      	ret
                                 
                                 do_store_mhl:
                                 ;	movw	x,z_l
000fb6 b8db
000fb7 b828
000fb8 b8cb
000fb9 b838
000fba b96b
000fbb b858
000fbc b868                      	mem_write_ds z_hl, opl
000fbd 9508                      	ret
                                 
                                 do_store_msp:
000fbe 01d7                      	movw xl,z_spl
000fbf b9bb
000fc0 b828
000fc1 b9ab
000fc2 b838
000fc3 b96b
000fc4 b858
000fc5 b868                      	mem_write_s opl
000fc6 9611                      	adiw xl,1
000fc7 b9bb
000fc8 b828
000fc9 b9ab
000fca b838
000fcb b97b
000fcc b858
000fcd b868                      	mem_write_s oph
000fce 9508                      	ret
                                 
                                 do_store_sp:
000fcf 017b                      	movw z_spl,opl
000fd0 9508                      	ret
                                 
                                 do_store_pc:
000fd1 01cb                      	movw z_pcl,opl
000fd2 9508                      	ret
                                 
                                 do_store_pcrel:				;add displacement to PC
                                 #if EM_Z80
000fd3 2777                      	clr	oph
000fd4 2366                      	tst	opl			;sign extend
000fd5 f40a                      	brpl	stpcr1
000fd6 9570                      	com	oph
                                 stpcr1:
000fd7 0f86                      	add	z_pcl,opl
000fd8 1f97                      	adc	z_pch,oph
000fd9 9508                      	ret
                                 #else
                                 #endif
                                 
                                 do_store_ret:
000fda 01d7                      	movw	x,z_spl
000fdb b9bb
000fdc b828
000fdd b9ab
000fde b838
000fdf b87a
000fe0 b848
000fe1 c000
000fe2 0000
000fe3 b189
000fe4 b868
000fe5 b86a                      	mem_read_d z_pcl
000fe6 9611                      	adiw	x,1
000fe7 b9bb
000fe8 b828
000fe9 b9ab
000fea b838
000feb b87a
000fec b848
000fed c000
000fee 0000
000fef b199
000ff0 b868
000ff1 b86a                      	mem_read_d z_pch
000ff2 9611                      	adiw	x,1
000ff3 017d                      	movw	z_spl,x
                                 
                                 .if STACK_DBG
                                 .endif
000ff4 9508                      	ret
                                 
                                 do_store_call:
000ff5 01d7                      	movw	xl,z_spl
000ff6 9711                      	sbiw	x,1
000ff7 b9bb
000ff8 b828
000ff9 b9ab
000ffa b838
000ffb b99b
000ffc b858
000ffd b868                      	mem_write_s z_pch
000ffe 9711                      	sbiw	x,1
000fff b9bb
001000 b828
001001 b9ab
001002 b838
001003 b98b
001004 b858
001005 b868                      	mem_write_s z_pcl
001006 017d                      	movw	z_spl,xl
                                 
                                 .if STACK_DBG
                                 .endif
001007 01cb                      	movw	z_pcl,opl
001008 9508                      	ret
                                 
                                 
                                 do_store_am:
001009 b97b
00100a b828
00100b b96b
00100c b838
00100d b95b
00100e b858
00100f b868                      	mem_write_ds op, z_a
001010 9508                      	ret
                                 
                                 ; ------------ Operation phase stuff -----------------
                                 
                                 ;----------------------------------------------------------------
                                 ;|                                                              |
                                 ;|                            Zilog                             |
                                 ;|                                                              |
                                 ;|                 ZZZZZZZ    88888      000                    |
                                 ;|                      Z    8     8    0   0                   |
                                 ;|                     Z     8     8   0   0 0                  |
                                 ;|                    Z       88888    0  0  0                  |
                                 ;|                   Z       8     8   0 0   0                  |
                                 ;|                  Z        8     8    0   0                   |
                                 ;|                 ZZZZZZZ    88888      000                    |
                                 ;|                                                              |
                                 ;|          Z80 MICROPROCESSOR Instruction Set Summary          |
                                 ;|                                                              |
                                 ;----------------------------------------------------------------
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;|----------+------+---------------------+----------------------|
                                 ;|ADC A,s   |***V0*|Add with Carry       |A=A+s+CY              |
                                 ;|ADC HL,ss |**?V0*|Add with Carry       |HL=HL+ss+CY           |
                                 ;|ADD A,s   |***V0*|Add                  |A=A+s                 |
                                 ;|ADD HL,ss |--*-0*|Add                  |HL=HL+ss              |
                                 ;|ADD IX,pp |--*-0*|Add                  |IX=IX+pp              |
                                 ;|ADD IY,rr |--*-0*|Add                  |IY=IY+rr              |
                                 ;|AND s     |**1P00|Logical AND          |A=A&s                 |
                                 ;|BIT b,m   |?*1?0-|Test Bit             |m&{2^b}               |
                                 ;|CALL cc,nn|------|Conditional Call     |If cc CALL            |
                                 ;|CALL nn   |------|Unconditional Call   |-[SP]=PC,PC=nn        |
                                 ;|CCF       |--?-0*|Complement Carry Flag|CY=~CY                |
                                 ;|CP s      |***V1*|Compare              |A-s                   |
                                 ;|CPD       |****1-|Compare and Decrement|A-[HL],HL=HL-1,BC=BC-1|
                                 ;|CPDR      |****1-|Compare, Dec., Repeat|CPD till A=[HL]or BC=0|
                                 ;|CPI       |****1-|Compare and Increment|A-[HL],HL=HL+1,BC=BC-1|
                                 ;|CPIR      |****1-|Compare, Inc., Repeat|CPI till A=[HL]or BC=0|
                                 ;|CPL       |--1-1-|Complement           |A=~A                  |
                                 ;|DAA       |***P-*|Decimal Adjust Acc.  |A=BCD format          |
                                 ;|DEC s     |***V1-|Decrement            |s=s-1                 |
                                 ;|DEC xx    |------|Decrement            |xx=xx-1               |
                                 ;|DEC ss    |------|Decrement            |ss=ss-1               |
                                 ;|DI        |------|Disable Interrupts   |IFF1 = IFF2 = 0       |
                                 ;|DJNZ e    |------|Dec., Jump Non-Zero  |B=B-1 till B=0        |
                                 ;|EI        |------|Enable Interrupts    |IFF1 = IFF2 = 1       |
                                 ;|EX [SP],HL|------|Exchange             |[SP]<->HL             |
                                 ;|EX [SP],xx|------|Exchange             |[SP]<->xx             |
                                 ;|EX AF,AF' |------|Exchange             |AF<->AF'              |
                                 ;|EX DE,HL  |------|Exchange             |DE<->HL               |
                                 ;|EXX       |------|Exchange             |qq<->qq'   (except AF)|
                                 ;|HALT      |------|Halt                 |                      |
                                 ;|IM n      |------|Interrupt Mode       |             (n=0,1,2)|
                                 ;|IN A,[n]  |------|Input                |A=[n]                 |
                                 ;|IN r,[C]  |***P0-|Input                |r=[C]                 |
                                 ;|INC r     |***V0-|Increment            |r=r+1                 |
                                 ;|INC [HL]  |***V0-|Increment            |[HL]=[HL]+1           |
                                 ;|INC xx    |------|Increment            |xx=xx+1               |
                                 ;|INC [xx+d]|***V0-|Increment            |[xx+d]=[xx+d]+1       |
                                 ;|INC ss    |------|Increment            |ss=ss+1               |
                                 ;|IND       |?*??1-|Input and Decrement  |[HL]=[C],HL=HL-1,B=B-1|
                                 ;|INDR      |?1??1-|Input, Dec., Repeat  |IND till B=0          |
                                 ;|INI       |?*??1-|Input and Increment  |[HL]=[C],HL=HL+1,B=B-1|
                                 ;|INIR      |?1??1-|Input, Inc., Repeat  |INI till B=0          |
                                 ;|JP [HL]   |------|Unconditional Jump   |PC=[HL]               |
                                 ;|JP [xx]   |------|Unconditional Jump   |PC=[xx]               |
                                 ;|JP nn     |------|Unconditional Jump   |PC=nn                 |
                                 ;|JP cc,nn  |------|Conditional Jump     |If cc JP              |
                                 ;|JR e      |------|Unconditional Jump   |PC=PC+e               |
                                 ;|JR cc,e   |------|Conditional Jump     |If cc JR(cc=C,NC,NZ,Z)|
                                 ;|LD dst,src|------|Load                 |dst=src               |
                                 ;|LD A,i    |**0*0-|Load                 |A=i            (i=I,R)|
                                 ;|LDD       |--0*0-|Load and Decrement   |[DE]=[HL],HL=HL-1,#   |
                                 ;|LDDR      |--000-|Load, Dec., Repeat   |LDD till BC=0         |
                                 ;|LDI       |--0*0-|Load and Increment   |[DE]=[HL],HL=HL+1,#   |
                                 ;|LDIR      |--000-|Load, Inc., Repeat   |LDI till BC=0         |
                                 ;|NEG       |***V1*|Negate               |A=-A                  |
                                 ;|NOP       |------|No Operation         |                      |
                                 ;|OR s      |**0P00|Logical inclusive OR |A=Avs                 |
                                 ;|OTDR      |?1??1-|Output, Dec., Repeat |OUTD till B=0         |
                                 ;|OTIR      |?1??1-|Output, Inc., Repeat |OUTI till B=0         |
                                 ;|OUT [C],r |------|Output               |[C]=r                 |
                                 ;|OUT [n],A |------|Output               |[n]=A                 |
                                 ;|OUTD      |?*??1-|Output and Decrement |[C]=[HL],HL=HL-1,B=B-1|
                                 ;|OUTI      |?*??1-|Output and Increment |[C]=[HL],HL=HL+1,B=B-1|
                                 ;|POP xx    |------|Pop                  |xx=[SP]+              |
                                 ;|POP qq    |------|Pop                  |qq=[SP]+              |
                                 ;|PUSH xx   |------|Push                 |-[SP]=xx              |
                                 ;|PUSH qq   |------|Push                 |-[SP]=qq              |
                                 ;|RES b,m   |------|Reset bit            |m=m&{~2^b}            |
                                 ;|RET       |------|Return               |PC=[SP]+              |
                                 ;|RET cc    |------|Conditional Return   |If cc RET             |
                                 ;|RETI      |------|Return from Interrupt|PC=[SP]+              |
                                 ;|RETN      |------|Return from NMI      |PC=[SP]+              |
                                 ;|RL m      |**0P0*|Rotate Left          |m={CY,m}<-            |
                                 ;|RLA       |--0-0*|Rotate Left Acc.     |A={CY,A}<-            |
                                 ;|RLC m     |**0P0*|Rotate Left Circular |m=m<-                 |
                                 ;|RLCA      |--0-0*|Rotate Left Circular |A=A<-                 |
                                 ;|RLD       |**0P0-|Rotate Left 4 bits   |{A,[HL]}={A,[HL]}<- ##|
                                 ;|RR m      |**0P0*|Rotate Right         |m=->{CY,m}            |
                                 ;|RRA       |--0-0*|Rotate Right Acc.    |A=->{CY,A}            |
                                 ;|RRC m     |**0P0*|Rotate Right Circular|m=->m                 |
                                 ;|RRCA      |--0-0*|Rotate Right Circular|A=->A                 |
                                 ;|RRD       |**0P0-|Rotate Right 4 bits  |{A,[HL]}=->{A,[HL]} ##|
                                 ;|RST p     |------|Restart              | (p=0H,8H,10H,...,38H)|
                                 ;|SBC A,s   |***V1*|Subtract with Carry  |A=A-s-CY              |
                                 ;|SBC HL,ss |***V1*|Subtract with Carry  |HL=HL-ss-CY           |
                                 ;|SCF       |--0-01|Set Carry Flag       |CY=1                  |
                                 ;|SET b,m   |------|Set bit              |m=mv{2^b}             |
                                 ;|SLA m     |**0P0*|Shift Left Arithmetic|m=m*2                 |
                                 ;|SRA m     |**0P0*|Shift Right Arith.   |m=m/2                 |
                                 ;|SRL m     |**0P0*|Shift Right Logical  |m=->{0,m,CY}          |
                                 ;|SUB s     |***V1*|Subtract             |A=A-s                 |
                                 ;|XOR s     |**0P00|Logical Exclusive OR |A=Axs                 |
                                 ;|----------+------+--------------------------------------------|
                                 ;| F        |-*01? |Flag unaffected/affected/reset/set/unknown  |
                                 ;| S        |S     |Sign flag (Bit 7)                           |
                                 ;| Z        | Z    |Zero flag (Bit 6)                           |
                                 ;| HC       |  H   |Half Carry flag (Bit 4)                     |
                                 ;| P/V      |   P  |Parity/Overflow flag (Bit 2, V=overflow)    |
                                 ;| N        |    N |Add/Subtract flag (Bit 1)                   |
                                 ;| CY       |     C|Carry flag (Bit 0)                          |
                                 ;|-----------------+--------------------------------------------|
                                 ;| n               |Immediate addressing                        |
                                 ;| nn              |Immediate extended addressing               |
                                 ;| e               |Relative addressing (PC=PC+2+offset)        |
                                 ;| [nn]            |Extended addressing                         |
                                 ;| [xx+d]          |Indexed addressing                          |
                                 ;| r               |Register addressing                         |
                                 ;| [rr]            |Register indirect addressing                |
                                 ;|                 |Implied addressing                          |
                                 ;| b               |Bit addressing                              |
                                 ;| p               |Modified page zero addressing (see RST)     |
                                 ;|-----------------+--------------------------------------------|
                                 ;|DEFB n(,...)     |Define Byte(s)                              |
                                 ;|DEFB 'str'(,...) |Define Byte ASCII string(s)                 |
                                 ;|DEFS nn          |Define Storage Block                        |
                                 ;|DEFW nn(,...)    |Define Word(s)                              |
                                 ;|-----------------+--------------------------------------------|
                                 ;| A  B  C  D  E   |Registers (8-bit)                           |
                                 ;| AF  BC  DE  HL  |Register pairs (16-bit)                     |
                                 ;| F               |Flag register (8-bit)                       |
                                 ;| I               |Interrupt page address register (8-bit)     |
                                 ;| IX IY           |Index registers (16-bit)                    |
                                 ;| PC              |Program Counter register (16-bit)           |
                                 ;| R               |Memory Refresh register                     |
                                 ;| SP              |Stack Pointer register (16-bit)             |
                                 ;|-----------------+--------------------------------------------|
                                 ;| b               |One bit (0 to 7)                            |
                                 ;| cc              |Condition (C,M,NC,NZ,P,PE,PO,Z)             |
                                 ;| d               |One-byte expression (-128 to +127)          |
                                 ;| dst             |Destination s, ss, [BC], [DE], [HL], [nn]   |
                                 ;| e               |One-byte expression (-126 to +129)          |
                                 ;| m               |Any register r, [HL] or [xx+d]              |
                                 ;| n               |One-byte expression (0 to 255)              |
                                 ;| nn              |Two-byte expression (0 to 65535)            |
                                 ;| pp              |Register pair BC, DE, IX or SP              |
                                 ;| qq              |Register pair AF, BC, DE or HL              |
                                 ;| qq'             |Alternative register pair AF, BC, DE or HL  |
                                 ;| r               |Register A, B, C, D, E, H or L              |
                                 ;| rr              |Register pair BC, DE, IY or SP              |
                                 ;| s               |Any register r, value n, [HL] or [xx+d]     |
                                 ;| src             |Source s, ss, [BC], [DE], [HL], nn, [nn]    |
                                 ;| ss              |Register pair BC, DE, HL or SP              |
                                 ;| xx              |Index register IX or IY                     |
                                 ;|-----------------+--------------------------------------------|
                                 ;| +  -  *  /  ^   |Add/subtract/multiply/divide/exponent       |
                                 ;| &  ~  v  x      |Logical AND/NOT/inclusive OR/exclusive OR   |
                                 ;| <-  ->          |Rotate left/right                           |
                                 ;| [ ]             |Indirect addressing                         |
                                 ;| [ ]+  -[ ]      |Indirect addressing auto-increment/decrement|
                                 ;| { }             |Combination of operands                     |
                                 ;| #               |Also BC=BC-1,DE=DE-1                        |
                                 ;| ##              |Only lower 4 bits of accumulator A used     |
                                 ;----------------------------------------------------------------
                                 
                                 ;How the flags are supposed to work:
                                 ;7 ZFL_S - Sign flag (=MSBit of result)
                                 ;6 ZFL_Z - Zero flag. Is 1 when the result is 0
                                 ;4 ZFL_H - Half-carry (carry from bit 3 to 4)
                                 ;2 ZFL_P - Parity/2-complement Overflow
                                 ;1 ZFL_N - Subtract - set if last op was a subtract
                                 ;0 ZFL_C - Carry
                                 ;
                                 ;I sure hope I got the mapping between flags and instructions correct...
                                 
                                 .equ ZFL_S = 7
                                 .equ ZFL_Z = 6
                                 .equ ZFL_H = 4
                                 .equ ZFL_P = 2
                                 .equ ZFL_N = 1
                                 .equ ZFL_C = 0
                                 
                                 .equ AVR_T = SREG_T
                                 .equ AVR_H = SREG_H
                                 .equ AVR_S = SREG_S
                                 .equ AVR_V = SREG_V
                                 .equ AVR_N = SREG_N
                                 .equ AVR_Z = SREG_Z
                                 .equ AVR_C = SREG_C
                                 
                                 ; TODO: check Z80 flag settings
                                 
                                 ;------------------------------------------------;
                                 ; Load table value from flash indexed by source reg.
                                 ;
                                 ;	ldpmx	dstreg,tablebase,indexreg
                                 ;
                                 ; (3 words, 5 cycles)
                                 
                                 .macro	ldpmx
                                 	ldi	zh,high(@1*2)	; table must be page aligned
                                 	mov	zl,@2		       
                                 	lpm	@0,z	
                                 .endm
                                 
                                 .macro	do_z80_flags_V
                                 #if EM_Z80
                                 	bmov	z_flags, ZFL_P, temp, AVR_V
                                 #endif
                                 .endm
                                 
                                 .macro	do_z80_flags_H
                                 #if EM_Z80
                                 	bmov	z_flags, ZFL_H, temp, AVR_H
                                 #endif
                                 .endm
                                 
                                 .macro	do_z80_flags_set_N
                                 #if EM_Z80
                                 	ori	z_flags, (1<<ZFL_N)       ; Negation auf 1
                                 #endif
                                 .endm
                                 
                                 .macro	do_z80_flags_set_HN
                                 #if EM_Z80
                                 	ori 	z_flags,(1<<ZFL_N)|(1<<ZFL_H)
                                 #endif
                                 .endm
                                 
                                 .macro	do_z80_flags_clear_N
                                 #if EM_Z80
                                 	andi	z_flags,~(1<<ZFL_N)
                                 #endif
                                 .endm
                                 
                                 .macro	do_z80_flags_clear_HN
                                 #if EM_Z80
                                 	andi	z_flags,~((1<<ZFL_H)|(1<<ZFL_N))
                                 #endif
                                 .endm
                                 
                                 	
                                 .macro	do_z80_flags_copy_HC
                                 #if EM_Z80
                                 	bmov	z_flags, ZFL_H, z_flags, ZFL_C
                                 #endif
                                 .endm
                                 
                                 .macro	do_z80_flags_op_rotate
                                 	; must not change avr carry flag!
                                 #if EM_Z80
                                 	andi   z_flags, ~( (1<<ZFL_H) | (1<<ZFL_N) | (1<<ZFL_C) )
                                 #else
                                 #endif
                                 .endm
                                 
                                 .macro	do_z80_flags_op_and
                                 #if EM_Z80
                                 	ori	z_flags,(1<<ZFL_H)
                                 #endif
                                 .endm
                                 
                                 .macro	do_z80_flags_op_or
                                 #if EM_Z80
                                 			;nothing to do
                                 #endif
                                 .endm
                                 
                                 
                                 ;----------------------------------------------------------------
                                 
                                 .equ do_op_nop = do_x_nop
                                 
                                 do_op_inv:
001011 9701                      	sbiw	z_pcl,1
001012 940e 02b9                 	lcall printregs
001014 940e 0223
001016 6e49
001017 6176
001018 696c
001019 2064
00101a 706f
00101b 6f63
00101c 6564
00101d 2021
00101e 0000                      	printstring "Invalid opcode! "
                                 
                                 haltinv:
00101f cfff                      	rjmp haltinv
                                 
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|HALT      |------|Halt                 |                      |
                                 
                                 
                                 do_op_HALT:
001020 9701                      	sbiw	z_pcl,1
001021 fd32                      	sbrc	intstat,i_halt
001022 9508                      	ret
001023 6034                      	sbr	intstat,(1<<i_halt)
001024 940e 02b9                 	lcall printregs
001026 940e 0223
001028 5043
001029 2055
00102a 6168
00102b 746c
00102c 6465
00102d 2021
00102e 0000                      	printstring "CPU halted! "
00102f 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|OUT [n],A |------|Output               |[n]=A                 |
                                 ;
                                 ;
                                 ;Interface with peripherials goes here :)
                                 do_op_outa: ; out (opl),a
                                 .if PORT_DEBUG
                                 .endif
001030 2f05                      	mov temp,z_a
001031 2f16                      	mov temp2,opl
001032 940e 22b5                 	lcall	portWrite
001034 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|IN A,[n]  |------|Input                |A=[n]                 |
                                 ;
                                 ;
                                 do_op_ina:				; in a,(opl)
                                 .if PORT_DEBUG
                                 .endif
                                 
001035 2f16                      	mov temp2,opl
001036 940e 22b7                 	lcall portRead
001038 2f50                      	mov z_a,temp
                                 
                                 .if PORT_DEBUG
                                 .endif
001039 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|INC r     |***V0-|Increment            |r=r+1                 |
                                 ;|INC [HL]  |***V0-|Increment            |[HL]=[HL]+1           |
                                 ;|INC [xx+d]|***V0-|Increment            |[xx+d]=[xx+d]+1       |
                                 ;|----------|SZHP C|---------- 8080 ----------------------------|
                                 ;|INC r     |**-P0-|Increment            |r=r+1                 |
                                 ;|INC [HL]  |**-P0-|Increment            |[HL]=[HL]+1           |
                                 ;
                                 
                                 do_op_inc:
                                 #if EM_Z80
                                 #if 1
00103a 7041                      	andi	z_flags,(1<<ZFL_C)		; preserve C-, Clear N-flag
00103b 5f6f                      	subi	opl,-1
00103c b70f                      	in	temp,sreg
00103d fd02                      	sbrc	temp,AVR_N
00103e 6840                      	sbr	z_flags,(1<<ZFL_S)
00103f fd01                      	sbrc	temp,AVR_Z
001040 6440                      	sbr	z_flags,(1<<ZFL_Z)
001041 ff05                      	sbrs	temp,AVR_H
001042 6140                      	sbr	z_flags,(1<<ZFL_H)
001043 fd03                      	sbrc	temp,AVR_V
001044 6044                      	sbr	z_flags,(1<<ZFL_P)
                                 #else
                                 #endif
                                 #else /* 8080 */
                                 #endif
001045 9508                      	ret
                                 
                                 #if 0
                                 #endif
                                 
                                 do_op_inca:
                                 #if EM_Z80
001046 7041                      	andi	z_flags,(1<<ZFL_C)		; preserve C-, Clear N-flag
001047 5f5f                      	subi	z_a,-1
001048 b70f                      	in	temp,sreg
001049 fb02
00104a f947                      	bmov	z_flags,ZFL_S, temp,AVR_N
00104b fb01
00104c f946                      	bmov	z_flags,ZFL_Z, temp,AVR_Z
00104d ff05                      	sbrs	temp,AVR_H
00104e 6140                      	sbr	z_flags,(1<<ZFL_H)
00104f fb03
001050 f942                      	bmov	z_flags,ZFL_P, temp,AVR_V
                                 #else /* 8080 */
                                 #endif
001051 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|DEC r     |***V1-|Decrement            |s=s-1                 |
                                 ;|DEC [HL]  |***V1-|Increment            |[HL]=[HL]-1           |
                                 ;|DEC [xx+d]|***V1-|Increment            |[xx+d]=[xx+d]-1       |
                                 ;|----------|SZHP C|---------- 8080 ----------------------------|
                                 ;|DEC r     |**-P -|Increment            |r=r-1                 |
                                 ;|DEC [HL]  |**-P -|Increment            |[HL]=[HL]-1           |
                                 ;
                                 
                                 do_op_dec:
001052 5061                      	subi	opl,1
                                 #if EM_Z80
001053 b70f                      	in	temp,sreg
001054 fb02
001055 f947                      	bmov	z_flags,ZFL_S, temp,AVR_N
001056 fb01
001057 f946                      	bmov	z_flags,ZFL_Z, temp,AVR_Z
001058 fb05
001059 f944                      	bmov	z_flags,ZFL_H, temp,AVR_H
00105a fb03
00105b f942                      	bmov	z_flags,ZFL_P, temp,AVR_V
00105c 6042                      	ori	z_flags,(1<<ZFL_N)		; Set N-flag
                                 #else /* 8080 */
                                 #endif
00105d 9508                      	ret
                                 
                                 
                                 do_op_deca:
                                 #if EM_Z80
00105e 5051                      	subi	z_a,1
00105f b70f                      	in	temp,sreg
001060 fb02
001061 f947                      	bmov	z_flags,ZFL_S, temp,AVR_N
001062 fb01
001063 f946                      	bmov	z_flags,ZFL_Z, temp,AVR_Z
001064 fb05
001065 f944                      	bmov	z_flags,ZFL_H, temp,AVR_H
001066 fb03
001067 f942                      	bmov	z_flags,ZFL_P, temp,AVR_V
001068 6042                      	ori	z_flags,(1<<ZFL_N)		; Set N-flag
                                 #else /* 8080 */
                                 #endif
001069 9508                      	ret
                                 
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|INC xx    |------|Increment            |xx=xx+1               |
                                 ;|INC ss    |------|Increment            |ss=ss+1               |
                                 ;
                                 ; 
                                 do_op_inc16:
00106a 5f6f                      	subi	opl,low(-1)
00106b 4f7f                      	sbci	oph,high(-1)
00106c 9508                      	ret
                                 
                                 do_op_incHL:
00106d 18c6                      	sub	z_l,_255
00106e 08d6                      	sbc	z_h,_255
00106f 9508                      	ret
                                 
                                 do_op_incDE:
001070 18a6                      	sub	z_e,_255
001071 08b6                      	sbc	z_d,_255
001072 9508                      	ret
                                 
                                 do_op_incBC:
001073 1886                      	sub	z_c,_255
001074 0896                      	sbc	z_b,_255
001075 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|DEC xx    |------|Decrement            |xx=xx-1               |
                                 ;|DEC ss    |------|Decrement            |ss=ss-1               |
                                 ;
                                 ; 
                                 do_op_dec16:
001076 5061                      	subi   opl, 1
001077 4070                      	sbci   oph, 0
001078 9508                      	ret
                                 
                                 do_op_decHL:
001079 0cc6                      	add	z_l,_255
00107a 1cd6                      	adc	z_h,_255
00107b 9508                      	ret
                                 
                                 do_op_decDE:
00107c 0ca6                      	add	z_e,_255
00107d 1cb6                      	adc	z_d,_255
00107e 9508                      	ret
                                 
                                 do_op_decBC:
00107f 0c86                      	add	z_c,_255
001080 1c96                      	adc	z_b,_255
001081 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|RLCA      |--0-0*|Rotate Left Circular |A=A<-                 |
                                 ;|----------|SZHP C|---------- 8080 ----------------------------|
                                 ;|RLCA      |---- *|Rotate Left Circular |A=A<-                 |
                                 ;
                                 ;
                                 do_op_rlca:
                                 	;Rotate Left Cyclical. All bits move 1 to the 
                                 	;left, the msb becomes c and lsb.
001082 7e4c                      	do_z80_flags_op_rotate
001083 0f55                      	lsl	z_a
001084 f418                      	brcc	do_op_rlc_noc
001085 e001                      	ldi	temp,1
001086 2b50                      	or	z_a,temp
001087 6041                      	ori	z_flags, (1<<ZFL_C)
                                 do_op_rlc_noc:
001088 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|RRCA      |--0-0*|Rotate Right Circular|A=->A                 |
                                 ;|----------|SZHP C|---------- 8080 ----------------------------|
                                 ;|RRCA      |---- *|Rotate Right Circular|A=->A                 |
                                 ;
                                 ;
                                 do_op_rrca: 
                                 	;Rotate Right Cyclical. All bits move 1 to the 
                                 	;right, the lsb becomes c and msb.
001089 7e4c                      	do_z80_flags_op_rotate
00108a 9556                      	lsr	z_a
00108b f418                      	brcc	do_op_rrc_noc
00108c e800                      	ldi	temp,0x80
00108d 2b50                      	or	z_a,temp
00108e 6041                      	ori	z_flags, (1<<ZFL_C)
                                 do_op_rrc_noc:
00108f 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|RRA       |--0-0*|Rotate Right Acc.    |A=->{CY,A}            |
                                 ;|----------|SZHP C|---------- 8080 ----------------------------|
                                 ;|RRA       |---- *|Rotate Right Acc.    |A=->{CY,A}            |
                                 ;
                                 ; 
                                 do_op_rra: 
                                 	;Rotate Right. All bits move 1 to the right, the lsb 
                                 	;becomes c, c becomes msb.
001090 9488                      	clc				; get z80 carry to avr carry
001091 fd40                      	sbrc    z_flags,ZFL_C
001092 9408                      	sec
001093 7e4c                      	do_z80_flags_op_rotate		; (clear ZFL_C, doesn't change AVR_C)
001094 fb50
001095 f940                      	bmov	z_flags,ZFL_C, z_a,0	; Bit 0 --> CY
001096 9557                      	ror     z_a
001097 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|RLA       |--0-0*|Rotate Left Acc.     |A={CY,A}<-            |
                                 ;|----------|SZHP C|---------- 8080 ----------------------------|
                                 ;|RLA       |---- *|Rotate Left Acc.     |A={CY,A}<-            |
                                 ;
                                 ; 
                                 do_op_rla:
                                 	;Rotate Left. All bits move 1 to the left, the msb 
                                 	;becomes c, c becomes lsb.
001098 9488                      	clc
001099 fd40                      	sbrc z_flags,ZFL_C
00109a 9408                      	 sec
00109b 7e4c                      	do_z80_flags_op_rotate		; (clear ZFL_C, doesn't change AVR_C)
00109c fb57
00109d f940                      	bmov	z_flags,ZFL_C, z_a,7	; Bit 7 --> CY
00109e 1f55                      	rol z_a
00109f 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|ADD A,s   |***V0*|Add                  |A=A+s                 |
                                 ;|----------|SZHP C|---------- 8080 ----------------------------|
                                 ;|ADD A,s   |***P *|Add                  |A=A+s                 |
                                 ;
                                 ;
                                 do_op_adda:
0010a0 0f56                      	add z_a,opl
0010a1 b70f                      	in temp,sreg
0010a2 e4f4
0010a3 2fe5
0010a4 9144                      	ldpmx	z_flags,sz53p_tab,z_a		;S,Z,P flag
0010a5 fb00
0010a6 f940                      	bmov	z_flags,ZFL_C, temp,AVR_C
0010a7 fb05
0010a8 f944                      	bmov	z_flags,ZFL_H, temp,AVR_H
0010a9 fb03
0010aa f942                      	do_z80_flags_V
0010ab 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|ADC A,s   |***V0*|Add with Carry       |A=A+s+CY              |
                                 ;|----------|SZHP C|---------- 8080 ----------------------------|
                                 ;|ADC A,s   |***P *|Add with Carry       |A=A+s+CY              |
                                 ;
                                 ;
                                 do_op_adca:
0010ac 9488                      	clc
0010ad fd40                      	sbrc z_flags,ZFL_C
0010ae 9408                      	 sec
0010af 1f56                      	adc z_a,opl
0010b0 b70f                      	in temp,sreg
0010b1 e4f4
0010b2 2fe5
0010b3 9144                      	ldpmx	z_flags,sz53p_tab,z_a		;S,Z,P
0010b4 fb00
0010b5 f940                      	bmov	z_flags,ZFL_C, temp,AVR_C
0010b6 fb05
0010b7 f944                      	bmov	z_flags,ZFL_H, temp,AVR_H
0010b8 fb03
0010b9 f942                      	do_z80_flags_V
0010ba 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|SUB s     |***V1*|Subtract             |A=A-s                 |
                                 ;|----------|SZHP C|---------- 8080 ----------------------------|
                                 ;|SUB s     |***P *|Subtract             |A=A-s                 |
                                 
                                 ;
                                 do_op_subfa:
0010bb 1b56                      	sub z_a,opl
0010bc b70f                      	in temp,sreg
0010bd e4f4
0010be 2fe5
0010bf 9144                      	ldpmx	z_flags,sz53p_tab,z_a		;S,Z,P
0010c0 fb00
0010c1 f940                      	bmov	z_flags,ZFL_C, temp,AVR_C
0010c2 fb05
0010c3 f944                      	bmov	z_flags,ZFL_H, temp,AVR_H
0010c4 fb03
0010c5 f942                      	do_z80_flags_V
0010c6 6042                      	do_z80_flags_set_N
0010c7 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|CP s      |***V1*|Compare              |A-s                   |
                                 ;|----------|SZHP C|---------- 8080 ----------------------------|
                                 ;|CP s      |***P *|Compare              |A-s                   |
                                 
                                 ;
                                 do_op_cpfa:
0010c8 2f15                      	mov temp2,z_a
0010c9 1b16                      	sub temp2,opl
0010ca b70f                      	in temp,sreg
0010cb e4f4
0010cc 2fe1
0010cd 9144                      	ldpmx	z_flags,sz53p_tab,temp2		;S,Z,P
0010ce fb00
0010cf f940                      	bmov	z_flags,ZFL_C, temp,AVR_C
0010d0 fb05
0010d1 f944                      	bmov	z_flags,ZFL_H, temp,AVR_H
0010d2 fb03
0010d3 f942                      	do_z80_flags_V
0010d4 6042                      	do_z80_flags_set_N
0010d5 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|SBC A,s   |***V1*|Subtract with Carry  |A=A-s-CY              |
                                 ;|----------|SZHP C|---------- 8080 ----------------------------|
                                 ;|SBC A,s   |***P *|Subtract with Carry  |A=A-s-CY              |
                                 ;
                                 ;
                                 do_op_sbcfa:
0010d6 9488                      	clc
0010d7 fd40                      	sbrc z_flags,ZFL_C
0010d8 9408                      	 sec
0010d9 0b56                      	sbc z_a,opl
0010da b70f                      	in temp,sreg
0010db e4f4
0010dc 2fe5
0010dd 9144                      	ldpmx	z_flags,sz53p_tab,z_a		;S,Z,P
0010de fb00
0010df f940                      	bmov	z_flags,ZFL_C, temp,AVR_C
0010e0 fb05
0010e1 f944                      	bmov	z_flags,ZFL_H, temp,AVR_H
0010e2 fb03
0010e3 f942                      	do_z80_flags_V
0010e4 6042                      	do_z80_flags_set_N
0010e5 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|AND s     |**1P00|Logical AND          |A=A&s                 |
                                 ;|----------|SZHP C|---------- 8080 ----------------------------|
                                 ;|AND s     |**-P 0|Logical AND          |A=A&s                 |
                                 ;
                                 ;
                                 do_op_anda:
0010e6 2356                      	and z_a,opl				;
0010e7 e4f4
0010e8 2fe5
0010e9 9144                      	ldpmx	z_flags,sz53p_tab,z_a		;S,Z,P,N,C
0010ea 6140                      	do_z80_flags_op_and
0010eb 9508                      	ret
                                 
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|OR s      |**0P00|Logical inclusive OR |A=Avs                 |
                                 ;|----------|SZHP C|---------- 8080 ----------------------------|
                                 ;|OR s      |**-P00|Logical inclusive OR |A=Avs                 |
                                 ;
                                 ;
                                 do_op_ora:
0010ec 2b56                      	or z_a,opl
0010ed e4f4
0010ee 2fe5
0010ef 9144                      	ldpmx	z_flags,sz53p_tab,z_a		;S,Z,H,P,N,C
                                 	do_z80_flags_op_or
0010f0 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|XOR s     |**0P00|Logical Exclusive OR |A=Axs                 |
                                 ;|----------|SZHP C|---------- 8080 ----------------------------|
                                 ;|XOR s     |**-P 0|Logical Exclusive OR |A=Axs                 |
                                 ;
                                 ;
                                 do_op_xora:
0010f1 2756                      	eor	z_a,opl
0010f2 e4f4
0010f3 2fe5
0010f4 9144                      	ldpmx	z_flags,sz53p_tab,z_a		;S,Z,H,P,N,C
                                 	do_z80_flags_op_or
0010f5 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|ADD HL,ss |--*-0*|Add                  |HL=HL+ss              |
                                 ;|----------|SZHP C|---------- 8080 ----------------------------|
                                 ;|ADD HL,ss |---- *|Add                  |HL=HL+ss              |
                                 ;
                                 ;
                                 do_op_addhl:
0010f6 0ec6                      	add	z_l,opl
0010f7 1ed7                      	adc	z_h,oph
0010f8 b70f                      	in	temp,sreg
0010f9 fb00
0010fa f940                      	bmov	z_flags,ZFL_C, temp,AVR_C
0010fb fb05
0010fc f944                      	do_z80_flags_H
0010fd 7f4d                      	do_z80_flags_clear_N
0010fe 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|LD dst,src|------|Load                 |dst=src               |
                                 ;
                                 ;
                                 do_op_sthl: ;store hl to mem loc in opl:h
0010ff 01db                      	movw	xl,opl
001100 b9bb
001101 b828
001102 b9ab
001103 b838
001104 b8cb
001105 b858
001106 b868                      	mem_write_s z_l
001107 9611                      	adiw	xl,1
001108 b9bb
001109 b828
00110a b9ab
00110b b838
00110c b8db
00110d b858
00110e b868                      	mem_write_s z_h
00110f 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|LD dst,src|------|Load                 |dst=src               |
                                 ;
                                 ; 
                                 do_op_rmem16:
001110 01db                      	movw xl,opl
001111 b9bb
001112 b828
001113 b9ab
001114 b838
001115 b87a
001116 b848
001117 c000
001118 0000
001119 b169
00111a b868
00111b b86a                      	mem_read_d opl
00111c 9611                      	adiw x,1
00111d b9bb
00111e b828
00111f b9ab
001120 b838
001121 b87a
001122 b848
001123 c000
001124 0000
001125 b179
001126 b868
001127 b86a                      	mem_read_d oph
001128 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|LD dst,src|------|Load                 |dst=src               |
                                 ;
                                 ;
                                 do_op_rmem8:
001129 b97b
00112a b828
00112b b96b
00112c b838
00112d b87a
00112e b848
00112f c000
001130 0000
001131 b169
001132 b868
001133 b86a                      	mem_read_ds opl, op
001134 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|DAA       |***P-*|Decimal Adjust Acc.  |                      |
                                 ;|----------|SZHP C|---------- 8080 ----------------------------|
                                 
                                 
                                 ; Description (http://www.z80.info/z80syntx.htm#DAA):
                                 ;  This instruction conditionally adjusts the accumulator for BCD addition
                                 ;  and subtraction operations. For addition (ADD, ADC, INC) or subtraction
                                 ;  (SUB, SBC, DEC, NEC), the following table indicates the operation performed:
                                 ;
                                 ; -------------------------------------------------------------------
                                 ; |       |C Flag |HEX value in|H Flag |HEX val in | Number |C flag |
                                 ; |  Oper |Before |upper digit |Before |lower digit| added  |After  |
                                 ; |       |DAA    |(bit 7-4)   |DAA    |(bit 3-0)  | to A   |DAA    |
                                 ; |-------+-------+------------+-------+-----------+--------+-------|
                                 ; |       |   0   |    0-9     |   0   |    0-9    |   00   |   0   |
                                 ; |  ADD  |   0   |    0-8     |   0   |    A-F    |   06   |   0   |
                                 ; |       |   0   |    0-9     |   1   |    0-3    |   06   |   0   |
                                 ; |  ADC  |   0   |    A-F     |   0   |    0-9    |   60   |   1   |
                                 ; |       |   0   |    9-F     |   0   |    A-F    |   66   |   1   |
                                 ; |  INC  |   0   |    A-F     |   1   |    0-3    |   66   |   1   |
                                 ; |       |   1   |    0-2     |   0   |    0-9    |   60   |   1   |
                                 ; |       |   1   |    0-2     |   0   |    A-F    |   66   |   1   |
                                 ; |       |   1   |    0-3     |   1   |    0-3    |   66   |   1   |
                                 ; |-------+-------+------------+-------+-----------+--------+-------|
                                 ; |  SUB  |   0   |    0-9     |   0   |    0-9    |   00   |   0   |
                                 ; |  SBC  |   0   |    0-8     |   1   |    6-F    |   FA   |   0   |
                                 ; |  DEC  |   1   |    7-F     |   0   |    0-9    |   A0   |   1   |
                                 ; |  NEG  |   1   |    6-F     |   1   |    6-F    |   9A   |   1   |
                                 ; -------------------------------------------------------------------
                                 ;
                                 ; The H flag is affected as follows:
                                 ;
                                 ; ---------------------
                                 ; | N | H | low   |H' |
                                 ; |   |   |nibble |   |  
                                 ; |---+---+-------+---|
                                 ; | 0 | * |  0-9  | 0 | 
                                 ; | 0 | * |  a-f  | 1 | 
                                 ; | 1 | 0 |   *   | 0 | 
                                 ; | 1 | 1 |  6-f  | 0 | 
                                 ; | 1 | 1 |  0-5  | 1 | 
                                 ; ---------------------
                                 ;
                                 ; Ohter flags:
                                 ;     N:   Unaffected.
                                 ;     P/V: Set if Acc. is even parity after operation, reset otherwise.
                                 ;     Z:   Set if Acc. is Zero after operation, reset otherwise.
                                 ;     S:   Set if most significant bit of Acc. is 1 after operation, reset otherwise.
                                 
                                 
                                 
                                 #if 0
                                 #if EM_Z80
                                 #endif
                                 #if EM_Z80
                                 #endif
                                 #else
                                 
                                 do_op_DAA:
001135 e070                      	ldi	oph,0				;oph: what to add
                                 
                                 #if EM_Z80
001136 fd41                      	sbrc	z_flags,ZFL_N			;if add-op	
001137 c021                      	rjmp	op_da_sub			;then
                                 #endif
                                 
                                 op_da_add:
001138 e010                      	ldi	temp2,0				;  new C, H and N flag
001139 2f06                      	mov	temp,opl			;  |
00113a 700f                      	andi	temp,0x0f			;  |
00113b 300a                      	cpi	temp,0x0a			;  if (lower nibble >= 0x0A)
00113c f048                      	brlo	op_da_a10			;  |
00113d 6076                      	ori	oph,0x06			;    add 6
00113e 6110                      	ori	temp2,(1<<ZFL_H)		;    set new H flag
                                 
00113f fd40                      	sbrc	z_flags,ZFL_C			;    |
001140 c002                      	rjmp	op_da_a02			;    if (C flag ...
001141 3960                      	cpi	opl,0x90			;    |... or upper nibble >= 0x90)
001142 f010                      	brlo	op_da_a03			;    |
                                 op_da_a02:				
001143 6670                      	ori	oph,0x60			;      add 0x60
001144 6011                      	ori	temp2,(1<<ZFL_C)		;      set new C flag
                                 op_da_a03:					;    endif
001145 c00d                      	rjmp	op_da_ae
                                 op_da_a10:					;  else (lower nibble is 0x09 or lower)
001146 fd40                      	sbrc	z_flags,ZFL_C			;    |
001147 c002                      	rjmp	op_da_a12			;    if (C flag ...
001148 3a60                      	cpi	opl,0xA0			;    |... or upper nibble >= 0xA0)
001149 f010                      	brlo	op_da_a13			; 
                                 op_da_a12:				
00114a 6670                      	ori	oph,0x60			;      add 0x60
00114b 6011                      	ori	temp2,(1<<ZFL_C)		;      set new C flag
                                 op_da_a13:
00114c ff44                      	sbrs	z_flags,ZFL_H			;    if (H flag)
00114d c005                      	rjmp	op_da_ae			;    |
00114e 6076                      	ori	oph,0x06			;      add 0x06
00114f 2f06                      	mov	temp,opl			;      |
001150 700f                      	andi	temp,0x0f			;      |
001151 3006                      	cpi	temp,0x06			;      if (lower nibble < 0x6)
001152 f400                      	brsh	op_da_ae			;      |
                                 ;	ori	temp2,(1<<ZFL_H)		;        set new H flag
                                 						;      endif
                                 						;    endif
                                 op_da_ae:
001153 0f67                      	add	opl,oph
001154 e4f4
001155 2fe6
001156 9144                      	ldpmx	z_flags, sz53p_tab, opl		; get S,Z,P flag
001157 2b41                      	or	z_flags,temp2			; merge new C and H flag
001158 9508                      	ret
                                 
                                 #if EM_Z80
                                 
                                 op_da_sub:				;Else (sub-op)
001159 e012                      	ldi	temp2,(1<<ZFL_N)		;  new C, H and N flag
00115a 2f06                      	mov	temp,opl			;  |
00115b 700f                      	andi	temp,0x0f			;  |
00115c 300a                      	cpi	temp,0x0a			;  if (lower nibble >= 0x0A)
00115d f040                      	brlo	op_da_s10			;  |
00115e 6076                      	ori	oph,0x06			;    sub 6
                                 
00115f fd40                      	sbrc	z_flags,ZFL_C			;    |
001160 c002                      	rjmp	op_da_s02			;    if (C flag ...
001161 3960                      	cpi	opl,0x90			;    |... or upper nibble >= 0x90)
001162 f010                      	brlo	op_da_s03			;    |
                                 op_da_s02:				
001163 6670                      	ori	oph,0x60			;      sub 0x60
001164 6011                      	ori	temp2,(1<<ZFL_C)		;      set new C flag
                                 op_da_s03:					;    endif
001165 c00e                      	rjmp	op_da_se
                                 op_da_s10:					;  else (lower nibble is 0x09 or lower)
001166 fd40                      	sbrc	z_flags,ZFL_C			;    |
001167 c002                      	rjmp	op_da_s12			;    if (C flag ...
001168 3a60                      	cpi	opl,0xA0			;    |... or upper nibble >= 0xA0)
001169 f010                      	brlo	op_da_s13			; 
                                 op_da_s12:				
00116a 6670                      	ori	oph,0x60			;      sub 0x60
00116b 6011                      	ori	temp2,(1<<ZFL_C)		;      set new C flag
                                 op_da_s13:
00116c ff44                      	sbrs	z_flags,ZFL_H			;    if (H flag)
00116d c006                      	rjmp	op_da_se			;    |
00116e 6076                      	ori	oph,0x06			;      sub 0x06
00116f 2f06                      	mov	temp,opl			;      |
001170 700f                      	andi	temp,0x0f			;      |
001171 3006                      	cpi	temp,0x06			;      if (lower nibble < 0x06)
001172 f408                      	brcc	op_da_se			;      |
001173 6110                      	ori	temp2,(1<<ZFL_H)		;        set new H flag
                                 						;      endif
                                 						;    endif
                                 op_da_se:
001174 1b67                      	sub	opl,oph
001175 e4f4
001176 2fe6
001177 9144                      	ldpmx	z_flags, sz53p_tab, opl		; get S,Z,P flag
001178 2b41                      	or	z_flags,temp2			; merge new C and H flag
001179 9508                      	ret				;Endif
                                 
                                 #endif  /* EM_Z80 */
                                 #endif  /* alternatives */
                                 
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|SCF       |--0-01|Set Carry Flag       |CY=1                  |
                                 ;|----------|SZHP C|---------- 8080 ----------------------------|
                                 ;
                                 ;
                                 do_op_scf:
00117a 7e4d                      	do_z80_flags_clear_HN
00117b 6041                      	ori 	z_flags,(1<<ZFL_C)
00117c 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|CCF       |--?-0*|Complement Carry Flag|CY=~CY, HC=previous CY|
                                 ;|----------|SZHP C|---------- 8080 ----------------------------|
                                 ;|CCF       |---- 1|Set Carry Flag       |CY=1                  |
                                 ;
                                 do_op_ccf:
00117d 7f4d                      	do_z80_flags_clear_N
00117e fb40
00117f f944                      	do_z80_flags_copy_HC
001180 e001                      	ldi temp,(1<<ZFL_C)
001181 2740                      	eor z_flags,temp
001182 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|CPL       |--1-1-|Complement           |A=~A                  |
                                 ;|----------|SZHP C|---------- 8080 ----------------------------|
                                 ;|CPL       |---- -|Complement           |A=~A                  |
                                 ;
                                 ;
                                 do_op_cpl:
001183 9550                      	com z_a
001184 6142                      	do_z80_flags_set_HN
001185 9508                      	ret
                                 
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|PUSH xx   |------|Push                 |-[SP]=xx              |
                                 ;|PUSH qq   |------|Push                 |-[SP]=qq              |
                                 ;
                                 ;
                                 do_op_push16:
001186 01d7                      	movw	xl,z_spl
001187 9711                      	sbiw	x,1
001188 b9bb
001189 b828
00118a b9ab
00118b b838
00118c b97b
00118d b858
00118e b868                      	mem_write_s oph
00118f 9711                      	sbiw	x,1
001190 b9bb
001191 b828
001192 b9ab
001193 b838
001194 b96b
001195 b858
001196 b868                      	mem_write_s opl
001197 017d                      	movw	z_spl,xl
                                 
                                 .if STACK_DBG
                                 .endif
                                 
001198 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|POP xx    |------|Pop                  |xx=[SP]+              |
                                 ;|POP qq    |------|Pop                  |qq=[SP]+              |
                                 ;
                                 ;
                                 do_op_pop16:
001199 01d7                      	movw	x,z_spl
00119a b9bb
00119b b828
00119c b9ab
00119d b838
00119e b87a
00119f b848
0011a0 c000
0011a1 0000
0011a2 b169
0011a3 b868
0011a4 b86a                      	mem_read_d opl
0011a5 9611                      	adiw	x,1
0011a6 b9bb
0011a7 b828
0011a8 b9ab
0011a9 b838
0011aa b87a
0011ab b848
0011ac c000
0011ad 0000
0011ae b179
0011af b868
0011b0 b86a                      	mem_read_d oph
0011b1 9611                      	adiw	x,1
0011b2 017d                      	movw	z_spl,x
                                 
                                 .if STACK_DBG
                                 .endif
0011b3 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|EX [SP],HL|------|Exchange             |[SP]<->HL             |
                                 ;|EX DE,HL  |------|Exchange             |DE<->HL               |
                                 ;-----------------------------Z80--------------------------------
                                 ; 
                                 do_op_exhl:
0011b4 0186                      	movw	temp,z_l
0011b5 016b                      	movw	z_l,opl
0011b6 01b8                      	movw	opl,temp
0011b7 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|DI        |------|Disable Interrupts   |IFF1 = IFF2 = 0       |
                                 ;|EI        |------|Enable Interrupts    |IFF1 = IFF2 = 1       |
                                 ;
                                 
                                 do_op_DI:
                                 #if EM_Z80
0011b8 850e                      	ldd	temp,y+oz_istat
0011b9 7f03                      	andi	temp,~((1<<IFF2) | (1<<IFF1))
0011ba 870e                      	std	y+oz_istat,temp
                                 #endif
0011bb 9508                      	ret
                                 
                                 do_op_EI:
                                 #if EM_Z80
0011bc 850e                      	ldd	temp,y+oz_istat
0011bd 600c                      	ori	temp,(1<<IFF2) | (1<<IFF1)
0011be 870e                      	std	y+oz_istat,temp
                                 #endif
0011bf 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|CALL cc,nn|------|Conditional Call     |If cc CALL            |
                                 ;|JP cc,nn  |------|Conditional Jump     |If cc JP              |
                                 ;|RET cc    |------|Conditional Return   |If cc RET             |
                                 ;
                                 ;
                                 do_op_ifnz:
0011c0 ff46                      	sbrs z_flags, ZFL_Z
0011c1 9508                      	ret
0011c2 910f                      	pop	temp				; nix tun
0011c3 910f                      	pop temp				; direkt zurueck zu main	
0011c4 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|CALL cc,nn|------|Conditional Call     |If cc CALL            |
                                 ;|JP cc,nn  |------|Conditional Jump     |If cc JP              |
                                 ;|RET cc    |------|Conditional Return   |If cc RET             |
                                 ;
                                 ;
                                 do_op_ifz:
0011c5 fd46                      	sbrc z_flags, ZFL_Z
0011c6 9508                      	ret
0011c7 910f                      	pop	temp				; nix tun
0011c8 910f                      	pop temp				; direkt zurueck zu main	
0011c9 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|CALL cc,nn|------|Conditional Call     |If cc CALL            |
                                 ;|JP cc,nn  |------|Conditional Jump     |If cc JP              |
                                 ;|RET cc    |------|Conditional Return   |If cc RET             |
                                 ;
                                 ;
                                 do_op_ifnc:
0011ca ff40                      	sbrs z_flags, ZFL_C
0011cb 9508                      	ret
0011cc 910f                      	pop	temp				; nix tun
0011cd 910f                      	pop temp				; direkt zuruech zu main	
0011ce 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|CALL cc,nn|------|Conditional Call     |If cc CALL            |
                                 ;|JP cc,nn  |------|Conditional Jump     |If cc JP              |
                                 ;|RET cc    |------|Conditional Return   |If cc RET             |
                                 ;
                                 ;
                                 do_op_ifc:
0011cf fd40                      	sbrc z_flags, ZFL_C
0011d0 9508                      	ret
0011d1 910f                      	pop	temp				; nix tun
0011d2 910f                      	pop temp				; direkt zuruech zu main	
0011d3 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|CALL cc,nn|------|Conditional Call     |If cc CALL            |
                                 ;|JP cc,nn  |------|Conditional Jump     |If cc JP              |
                                 ;|RET cc    |------|Conditional Return   |If cc RET             |
                                 ;
                                 ;
                                 do_op_ifpo:
0011d4 ff42                      	sbrs z_flags, ZFL_P
0011d5 9508                      	ret
0011d6 910f                      	pop	temp				; nix tun
0011d7 910f                      	pop temp				; direkt zuruech zu main	
0011d8 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|CALL cc,nn|------|Conditional Call     |If cc CALL            |
                                 ;|JP cc,nn  |------|Conditional Jump     |If cc JP              |
                                 ;|RET cc    |------|Conditional Return   |If cc RET             |
                                 ;
                                 ;
                                 do_op_ifpe:
0011d9 fd42                      	sbrc z_flags, ZFL_P
0011da 9508                      	ret
0011db 910f                      	pop	temp				; nix tun
0011dc 910f                      	pop temp				; direkt zuruech zu main	
0011dd 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|CALL cc,nn|------|Conditional Call     |If cc CALL            |
                                 ;|JP cc,nn  |------|Conditional Jump     |If cc JP              |
                                 ;|RET cc    |------|Conditional Return   |If cc RET             |
                                 ;
                                 ;
                                 do_op_ifp: ;sign positive, aka s=0
0011de ff47                      	sbrs z_flags, ZFL_S
0011df 9508                      	 ret
0011e0 910f                      	pop	temp				; nix tun
0011e1 910f                      	pop temp				; direkt zuruech zu main	
0011e2 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|CALL cc,nn|------|Conditional Call     |If cc CALL            |
                                 ;|JP cc,nn  |------|Conditional Jump     |If cc JP              |
                                 ;|RET cc    |------|Conditional Return   |If cc RET             |
                                 ;
                                 ;
                                 do_op_ifm: ;sign negative, aka s=1
0011e3 fd47                      	sbrc z_flags, ZFL_S
0011e4 9508                      	 ret
0011e5 910f                      	pop	temp				; nix tun
0011e6 910f                      	pop temp				; direkt zuruech zu main	
0011e7 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 
                                 #if EM_Z80
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|DJNZ e    |------|Dec., Jump Non-Zero  |B=B-1 till B=0        |
                                 ;
                                 ;The b register is decremented, and if not zero, the signed value e is added to pc.
                                 ;The jump is measured from the start of the instruction opcode.
                                 ;e = Relative addressing (PC=PC+2+offset)
                                 
                                 #if 1
                                 
                                 				; (Joe G.)
                                 do_op_DJNZ:			; decremt B, jump B=0
0011e8 949a                      	dec	z_b		; B decrementieren
0011e9 f029                      	breq	do_op_DJNZ_Z	; bei B=0
0011ea 5860                      	subi	opl, 0x80	; z_pc + e im Zweierkomplement
0011eb 5880                      	subi	z_pcl,0x80
0011ec 0997                      	sbc	z_pch,_0
0011ed 0f86                      	add	z_pcl,opl
0011ee 1d97                      	adc	z_pch,_0
                                 do_op_DJNZ_Z:
0011ef 9508                      	ret
                                 
                                 #else
                                 #endif
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|EX AF,AF' |------|Exchange             |AF<->AF'              |
                                 
                                 do_op_EXAF:
0011f0 810e                      	ldd	temp,y+oz_f2
0011f1 811f                      	ldd	temp2,y+oz_a2
0011f2 834e                      	std	y+oz_f2,z_flags
0011f3 835f                      	std	y+oz_a2,z_a
0011f4 2f40                      	mov	z_flags,temp
0011f5 2f51                      	mov	z_a,temp2
0011f6 9508                      	ret
                                 
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|EXX       |------|Exchange             |qq<->qq'   (except AF)|
                                 
                                 
                                 #if 1
                                 
                                 do_op_EXX:
0011f7 8108                      	ldd	temp ,y+oz_c2
0011f8 8119                      	ldd	temp2,y+oz_b2
0011f9 8288                      	std	y+oz_c2,z_c
0011fa 8299                      	std	y+oz_b2,z_b
0011fb 0148                      	movw	z_c,temp
                                 
0011fc 810a                      	ldd	temp ,y+oz_e2
0011fd 811b                      	ldd	temp2,y+oz_d2
0011fe 82aa                      	std	y+oz_e2,z_e
0011ff 82bb                      	std	y+oz_d2,z_d
001200 0158                      	movw	z_e,temp
                                 
001201 810c                      	ldd	temp ,y+oz_l2
001202 811d                      	ldd	temp2,y+oz_h2
001203 82cc                      	std	y+oz_l2,z_l
001204 82dd                      	std	y+oz_h2,z_h
001205 0168                      	movw	z_l,temp
001206 9508                      	ret
                                 #else
                                 #endif
                                 
                                 #else
                                 #endif
                                 
                                 #if EM_Z80
                                 
                                 do_op_prefixED:
001207 b99b
001208 b828
001209 b98b
00120a b838
00120b b87a
00120c b848
00120d c000
00120e 0000
00120f b1e9
001210 b868
001211 b86a                      	mem_read_ds zl,z_pc			;zl = memReadByte(z_pc)
001212 9601                      	adiw	z_pcl,1				;++z_pc
001213 e2f0                      	ldi	zh,high(EDjmp)			;
001214 9409                      	ijmp
                                 
                                 
                                 do_op_prefixDD:
001215 98f1                      	cbi	flags,prefixfd
001216 b99b
001217 b828
001218 b98b
001219 b838
00121a b87a
00121b b848
00121c c000
00121d 0000
00121e b1e9
00121f b868
001220 b86a                      	mem_read_ds zl,z_pc			;zl = memReadByte(z_pc)
001221 9601                      	adiw	z_pcl,1				;++z_pc
001222 e1f7                      	ldi	zh,high(DDFDjmp)		;
001223 9409                      	ijmp
                                 
                                 
                                 do_op_prefixFD:
001224 9af1                      	sbi	flags,prefixfd
001225 b99b
001226 b828
001227 b98b
001228 b838
001229 b87a
00122a b848
00122b c000
00122c 0000
00122d b1e9
00122e b868
00122f b86a                      	mem_read_ds zl,z_pc			;zl = memReadByte(z_pc)
001230 9601                      	adiw	z_pcl,1				;++z_pc
001231 e1f7                      	ldi	zh,high(DDFDjmp)		;
001232 9409                      	ijmp
                                 
                                 do_op_prefixCB:
001233 b99b
001234 b828
001235 b98b
001236 b838
001237 b87a
001238 b848
001239 c000
00123a 0000
00123b b1e9
00123c b868
00123d b86a                      	mem_read_ds zl,z_pc			;zl = memReadByte(z_pc)
00123e 9601                      	adiw	z_pcl,1				;++z_pc
00123f e1f9                      	ldi	zh,high(CBjmp)			;
001240 9409                      	ijmp
                                 
                                 
                                 do_op_prefixDDFDCB:
001241 99f1                      	sbic	flags,prefixfd
001242 c003                      	rjmp	opprxcb_fd
001243 85b9                      	ldd	xh,y+oz_xh
001244 85a8                      	ldd	xl,y+oz_xl
001245 c002                      	rjmp	opprxcb_1
                                 opprxcb_fd:
001246 85bb                      	ldd	xh,y+oz_yh
001247 85aa                      	ldd	xl,y+oz_yl
                                 opprxcb_1:
001248 b99b
001249 b828
00124a b98b
00124b b838
00124c b87a
00124d b848
00124e c000
00124f 0000
001250 b109
001251 b868
001252 b86a                      	mem_read_s z_pc				;get displacement
001253 9601                      	adiw z_pcl,1				;++z_pc
001254 2711                      	clr	temp2				;sign extend
001255 2300                      	tst	temp
001256 f40a                      	brpl	PC+2
001257 9510                      	 com	temp2
001258 0fa0                      	add	xl,temp				;add displacement
001259 1fb1                      	adc	xh,temp2
00125a b9bb
00125b b828
00125c b9ab
00125d b838
00125e b87a
00125f b848
001260 c000
001261 0000
001262 b169
001263 b868
001264 b86a                      	mem_read_d opl
                                 
001265 b99b
001266 b828
001267 b98b
001268 b838
001269 b87a
00126a b848
00126b c000
00126c 0000
00126d b1e9
00126e b868
00126f b86a                      	mem_read_ds zl,z_pc			;zl = opcode
001270 9601                      	adiw	z_pcl,1				;++z_pc
001271 e1fd                      	ldi	zh,high(DDFDCBjmp)		;
001272 9509                      	icall
001273 b9bb
001274 b828
001275 b9ab
001276 b838
001277 b96b
001278 b858
001279 b868                      	mem_write_s opl
00127a 9508                      	ret
                                 
                                 
                                 #else		; TODO: geht das so?
                                 #endif
                                 
                                 
                                 
                                 ; ----------------------- Opcode decoding -------------------------
                                 
                                 ; Lookup table for Z80 opcodes. Translates the first byte of the instruction word into three
                                 ; operations: fetch, do something, store.
                                 ; The table is made of 256 words. 
                                 
                                 	opctable opcjmp, PC	;+3*256
                                 	 
001300 9508                      instr 	fetch_nop,	op_nop,		store_nop	;00		;NOP
001301 cf79
00127b dcfb
00127c cd23                      instr 	fetch_DIR16,	op_nop,		store_BC	;01 nn nn	;LD BC,nn
001302 cca3                      instr 	fetch_nop,	op_nop,		store_MBC	;02		;LD (BC),A
                                 ;instr 	fetch_BC,	op_INC16,	store_BC	;03		;INC BC
001303 cd6f                      instr 	fetch_nop,	op_INCBC,	store_nop	;03		;INC BC
001304 cf78
00127d 2d69
00127e ddbb
00127f cd12                      instr 	fetch_B,	op_INC,		store_B		;04		;INC B
001305 cf7a
001280 2d69
001281 ddd0
001282 cd0f                      instr 	fetch_B,	op_DEC,		store_B		;05		;DEC B
001306 cf7c
001283 dce6
001284 cd0d                      instr 	fetch_DIR8,	op_nop,		store_B		;06		;LD B,n
001307 cd7a                      instr 	fetch_nop,	op_RLCA,	store_nop	;07		;RLCA
001308 cee7                      instr 	fetch_nop,	op_EXAF,	store_nop	;08		;EX AF,AF'
001309 cf7b
001285 01b4
001286 ce6f                      instr 	fetch_BC,	op_ADDHL,	store_nop	;09		;ADD HL,BC
00130a cc22                      instr 	fetch_MBC,	op_nop,		store_nop	;0A       	;LD A,(BC)
                                 ;instr 	fetch_BC,	op_DEC16,	store_BC	;0B       	;DEC BC
00130b cd73                      instr 	fetch_nop,	op_DECBC,	store_nop	;0B		;DEC BC
00130c cf7a
001287 2d68
001288 ddb1
001289 cd0a                      instr 	fetch_C,	op_INC,		store_C		;0C       	;INC C
00130d cf7c
00128a 2d68
00128b ddc6
00128c cd07                      instr 	fetch_C,	op_DEC,		store_C		;0D       	;DEC C
00130e cf7e
00128d dcdc
00128e cd05                      instr 	fetch_DIR8,	op_nop,		store_C		;0E nn    	;LD C,n
00130f cd79                      instr 	fetch_nop,	op_RRCA,	store_nop	;0F       	;RRCA
001310 cf7e
00128f dcda
001290 cf57                      instr 	fetch_DIR8,	op_DJNZ,	store_nop	;10 oo    	;DJNZ o
001311 cf7f
001291 dce5
001292 cd0f                      instr 	fetch_DIR16,	op_nop,		store_DE	;11 nn nn	;LD DE,nn
001312 cc9b                      instr 	fetch_nop,	op_nop,		store_MDE	;12		;LD (DE),A
                                 ;instr 	fetch_DE,	op_INC16,	store_DE	;13		;INC DE
001313 cd5c                      instr 	fetch_nop,	op_INCDE,	store_nop	;13		;INC DE
001314 cf7e
001293 2d6b
001294 dda5
001295 cd00                      instr 	fetch_D,	op_INC,		store_D		;14		;INC D
001315 cf80
001296 2d6b
001297 ddba
001298 ccfd                      instr 	fetch_D,	op_DEC,		store_D		;15		;DEC D
001316 cf82
001299 dcd0
00129a ccfb                      instr 	fetch_DIR8,	op_nop,		store_D		;16 nn		;LD D,n
001317 cd80                      instr 	fetch_nop,	op_RLA,		store_nop	;17		;RLA
001318 cf82
00129b dcce
00129c cd36                      instr 	fetch_DIR8,	op_nop,		store_pcrel	;18 oo		;JR o
001319 cf83
00129d 01b5
00129e ce57                      instr 	fetch_DE,	op_ADDHL,	store_nop	;19		;ADD HL,DE
00131a cc1e                      instr 	fetch_MDE,	op_nop,		store_nop	;1A		;LD A,(DE)
                                 ;instr 	fetch_DE,	op_DEC16,	store_DE	;1B		;DEC DE
00131b cd60                      instr 	fetch_nop,	op_DECDE,	store_nop	;1B		;DEC DE
00131c cf82
00129f 2d6a
0012a0 dd99
0012a1 ccf6                      instr 	fetch_E,	op_INC,		store_E		;1C		;INC E
00131d cf84
0012a2 2d6a
0012a3 ddae
0012a4 ccf3                      instr 	fetch_E,	op_DEC,		store_E		;1D		;DEC E
00131e cf86
0012a5 dcc4
0012a6 ccf1                      instr 	fetch_DIR8,	op_nop,		store_E		;1E nn		;LD E,n
00131f cd70                      instr 	fetch_nop,	op_RRA,		store_nop	;1F		;RRA
001320 cf86
0012a7 dcc2
0012a8 df17
0012a9 cd29                      instr 	fetch_DIR8,	op_IFNZ,	store_pcrel	;20 oo		;JR NZ,o
001321 cf88
0012aa dccc
0012ab ccf8                      instr 	fetch_DIR16,	op_nop,		store_HL	;21 nn nn	;LD HL,nn
001322 cf89
0012ac dcca
0012ad ce51                      instr 	fetch_DIR16,	op_STHL,	store_nop	;22 nn nn	;LD (nn),HL
                                 ;instr 	fetch_HL,	op_INC16,	store_HL	;23		;INC HL
001323 cd49                      instr 	fetch_nop,	op_INCHL,	store_nop	;23		;INC HL
001324 cf89
0012ae 2d6d
0012af dd8a
0012b0 cce9                      instr 	fetch_H,	op_INC,		store_H		;24		;INC H
001325 cf8b
0012b1 2d6d
0012b2 dd9f
0012b3 cce6                      instr 	fetch_H,	op_DEC,		store_H		;25		;DEC H
001326 cf8d
0012b4 dcb5
0012b5 cce4                      instr 	fetch_DIR8,	op_nop,		store_H		;26 nn		;LD H,n
001327 cf8e
0012b6 2f65
0012b7 de7d
0012b8 ccd7                      instr 	fetch_A,	op_DAA,		store_A		;27		;DAA
001328 cf90
0012b9 dcb0
0012ba df0a
0012bb cd17                      instr 	fetch_DIR8,	op_IFZ,		store_pcrel	;28 oo		;JR Z,o
001329 cf92
0012bc 01b6
0012bd ce38                      instr 	fetch_HL,	op_ADDHL,	store_nop	;29		;ADD HL,HL
00132a cf93
0012be dcb8
0012bf de50
0012c0 cce3                      instr 	fetch_DIR16,	op_RMEM16,	store_HL	;2A nn nn	;LD HL,(nn)
                                 ;instr 	fetch_HL,	op_DEC16,	store_HL	;2B		;DEC HL
00132b cd4d                      instr 	fetch_nop,	op_DECHL,	store_nop	;2B		;DEC HL
00132c cf94
0012c1 2d6c
0012c2 dd77
0012c3 ccd8                      instr 	fetch_L,	op_INC,		store_L		;2C		;INC L
00132d cf96
0012c4 2d6c
0012c5 dd8c
0012c6 ccd5                      instr 	fetch_L,	op_DEC,		store_L		;2D		;DEC L
00132e cf98
0012c7 dca2
0012c8 ccd3                      instr 	fetch_DIR8,	op_nop,		store_L		;2E nn		;LD L,n
00132f ce53                      instr 	fetch_nop,	op_CPL,		store_nop	;2F		;CPL
001330 cf98
0012c9 dca0
0012ca deff
0012cb cd07                      instr 	fetch_DIR8,	op_IFNC,	store_pcrel	;30 oo		;JR NC,o
001331 cf9a
0012cc dcaa
0012cd cd01                      instr 	fetch_DIR16,	op_nop,		store_SP	;31 nn nn	;LD SP,nn
001332 cf9b
0012ce dca8
0012cf cd39                      instr 	fetch_DIR16,	op_nop,		store_AM	;32 nn nn	;LD (nn),A
001333 cf9c
0012d0 01b7
0012d1 dd98
0012d2 ccfc                      instr 	fetch_SP,	op_INC16,	store_SP	;33		;INC SP
001334 cf9e
0012d3 dc71
0012d4 dd65
0012d5 cce0                      instr 	fetch_MHL,	op_INC,		store_MHL	;34		;INC (HL)
001335 cfa0
0012d6 dc6e
0012d7 dd7a
0012d8 ccdd                      instr 	fetch_MHL,	op_DEC,		store_MHL	;35		;DEC (HL)
001336 cfa2
0012d9 dc90
0012da ccdb                      instr 	fetch_DIR8,	op_nop,		store_MHL	;36 nn		;LD (HL),n
001337 ce42                      instr 	fetch_nop,	op_SCF,		store_nop	;37		;SCF
001338 cfa2
0012db dc8e
0012dc def2
0012dd ccf5                      instr 	fetch_DIR8,	op_IFC,		store_pcrel	;38 oo		;JR C,o
001339 cfa4
0012de 01b7
0012df ce16                      instr 	fetch_SP,	op_ADDHL,	store_nop	;39		;ADD HL,SP
00133a cfa5
0012e0 dc96
0012e1 de47
0012e2 ccad                      instr 	fetch_DIR16,	op_RMEM8,	store_A		;3A nn nn	;LD A,(nn)
00133b cfa7
0012e3 01b7
0012e4 dd91
0012e5 cce9                      instr 	fetch_SP,	op_DEC16,	store_SP	;3B		;DEC SP
00133c cd09                      instr 	fetch_nop,	op_INCA,	store_nop	;3C		;INC A
00133d cd20                      instr 	fetch_nop,	op_DECA,	store_nop	;3D		;DEC A
00133e cfa7
0012e6 dc83
0012e7 cca8                      instr 	fetch_DIR8,	op_nop,		store_A		;3E nn		;LD A,n
00133f ce3d                      instr 	fetch_nop,	op_CCF,		store_nop	;3F		;CCF (Complement Carry Flag, gvd)
001340 9508                      instr 	fetch_nop,	op_nop,		store_nop	;40		;LD B,B
001341 cfa6
0012e8 2d68
0012e9 cca8                      instr 	fetch_C,	op_nop,		store_B		;41		;LD B,C
001342 cfa7
0012ea 2d6b
0012eb cca6                      instr 	fetch_D,	op_nop,		store_B		;42		;LD B,D
001343 cfa8
0012ec 2d6a
0012ed cca4                      instr 	fetch_E,	op_nop,		store_B		;43		;LD B,E
001344 cfa9
0012ee 2d6d
0012ef cca2                      instr 	fetch_H,	op_nop,		store_B		;44		;LD B,H
001345 cfaa
0012f0 2d6c
0012f1 cca0                      instr 	fetch_L,	op_nop,		store_B		;45		;LD B,L
001346 cfab
0012f2 dc52
0012f3 cc9e                      instr 	fetch_MHL,	op_nop,		store_B		;46		;LD B,(HL)
001347 cfac
0012f4 2f65
0012f5 cc9c                      instr 	fetch_A,	op_nop,		store_B		;47		;LD B,A
001348 cfad
0012f6 2d69
0012f7 cc9c                      instr 	fetch_B,	op_nop,		store_C		;48		;LD C,B
001349 9508                      instr 	fetch_nop,	op_nop,		store_nop	;49		;LD C,C
00134a cfad
0012f8 2d6b
0012f9 cc9a                      instr 	fetch_D,	op_nop,		store_C		;4A		;LD C,D
00134b cfae
0012fa 2d6a
0012fb cc98                      instr 	fetch_E,	op_nop,		store_C		;4B		;LD C,E
00134c cfaf
0012fc 2d6d
0012fd cc96                      instr 	fetch_H,	op_nop,		store_C		;4C		;LD C,H
00134d c0b2
001400 2d6c
001401 cb92                      instr 	fetch_L,	op_nop,		store_C		;4D		;LD C,L
00134e c0b3
001402 db42
001403 cb90                      instr 	fetch_MHL,	op_nop,		store_C		;4E		;LD C,(HL)
00134f c0b4
001404 2f65
001405 cb8e                      instr 	fetch_A,	op_nop,		store_C		;4F		;LD C,A
001350 c0b5
001406 2d69
001407 cb8e                      instr 	fetch_B,	op_nop,		store_D		;50		;LD D,B
001351 c0b6
001408 2d68
001409 cb8c                      instr 	fetch_C,	op_nop,		store_D		;51		;LD D,C
001352 9508                      instr 	fetch_nop,	op_nop,		store_nop	;52		;LD D,D
001353 c0b6
00140a 2d6a
00140b cb8a                      instr 	fetch_E,	op_nop,		store_D		;53		;LD D,E
001354 c0b7
00140c 2d6d
00140d cb88                      instr 	fetch_H,	op_nop,		store_D		;54		;LD D,H
001355 c0b8
00140e 2d6c
00140f cb86                      instr 	fetch_L,	op_nop,		store_D		;55		;LD D,L
001356 c0b9
001410 db34
001411 cb84                      instr 	fetch_MHL,	op_nop,		store_D		;56		;LD D,(HL)
001357 c0ba
001412 2f65
001413 cb82                      instr 	fetch_A,	op_nop,		store_D		;57		;LD D,A
001358 c0bb
001414 2d69
001415 cb82                      instr 	fetch_B,	op_nop,		store_E		;58		;LD E,B
001359 c0bc
001416 2d68
001417 cb80                      instr 	fetch_C,	op_nop,		store_E		;59		;LD E,C
00135a c0bd
001418 2d6b
001419 cb7e                      instr 	fetch_D,	op_nop,		store_E		;5A		;LD E,D
00135b 9508                      instr 	fetch_nop,	op_nop,		store_nop	;5B		;LD E,E
00135c c0bd
00141a 2d6d
00141b cb7c                      instr 	fetch_H,	op_nop,		store_E		;5C		;LD E,H
00135d c0be
00141c 2d6c
00141d cb7a                      instr 	fetch_L,	op_nop,		store_E		;5D		;LD E,L
00135e c0bf
00141e db26
00141f cb78                      instr 	fetch_MHL,	op_nop,		store_E		;5E		;LD E,(HL)
00135f c0c0
001420 2f65
001421 cb76                      instr 	fetch_A,	op_nop,		store_E		;5F		;LD E,A
001360 c0c1
001422 2d69
001423 cb76                      instr 	fetch_B,	op_nop,		store_H		;60		;LD H,B
001361 c0c2
001424 2d68
001425 cb74                      instr 	fetch_C,	op_nop,		store_H		;61		;LD H,C
001362 c0c3
001426 2d6b
001427 cb72                      instr 	fetch_D,	op_nop,		store_H		;62		;LD H,D
001363 c0c4
001428 2d6a
001429 cb70                      instr 	fetch_E,	op_nop,		store_H		;63		;LD H,E
001364 9508                      instr 	fetch_nop,	op_nop,		store_nop	;64		;LD H,H
001365 c0c4
00142a 2d6c
00142b cb6e                      instr 	fetch_L,	op_nop,		store_H		;65		;LD H,L
001366 c0c5
00142c db18
00142d cb6c                      instr 	fetch_MHL,	op_nop,		store_H		;66		;LD H,(HL)
001367 c0c6
00142e 2f65
00142f cb6a                      instr 	fetch_A,	op_nop,		store_H		;67		;LD H,A
001368 c0c7
001430 2d69
001431 cb6a                      instr 	fetch_B,	op_nop,		store_L		;68		;LD L,B
001369 c0c8
001432 2d68
001433 cb68                      instr 	fetch_C,	op_nop,		store_L		;69		;LD L,C
00136a c0c9
001434 2d6b
001435 cb66                      instr 	fetch_D,	op_nop,		store_L		;6A		;LD L,D
00136b c0ca
001436 2d6a
001437 cb64                      instr 	fetch_E,	op_nop,		store_L		;6B		;LD L,E
00136c c0cb
001438 2d6d
001439 cb62                      instr 	fetch_H,	op_nop,		store_L		;6C		;LD L,H
00136d 9508                      instr 	fetch_nop,	op_nop,		store_nop	;6D		;LD L,L
00136e c0cb
00143a db0a
00143b cb60                      instr 	fetch_MHL,	op_nop,		store_L		;6E		;LD L,(HL)
00136f c0cc
00143c 2f65
00143d cb5e                      instr 	fetch_A,	op_nop,		store_L		;6F		;LD L,A
001370 c0cd
00143e 2d69
00143f cb76                      instr 	fetch_B,	op_nop,		store_MHL	;70		;LD (HL),B
001371 c0ce
001440 2d68
001441 cb74                      instr 	fetch_C,	op_nop,		store_MHL	;71		;LD (HL),C
001372 c0cf
001442 2d6b
001443 cb72                      instr 	fetch_D,	op_nop,		store_MHL	;72		;LD (HL),D
001373 c0d0
001444 2d6a
001445 cb70                      instr 	fetch_E,	op_nop,		store_MHL	;73		;LD (HL),E
001374 c0d1
001446 2d6d
001447 cb6e                      instr 	fetch_H,	op_nop,		store_MHL	;74		;LD (HL),H
001375 c0d2
001448 2d6c
001449 cb6c                      instr 	fetch_L,	op_nop,		store_MHL	;75		;LD (HL),L
001376 cca9                      instr 	fetch_nop,	op_HALT,	store_nop	;76		;HALT
001377 c0d2
00144a 2f65
00144b cb6a                      instr 	fetch_A,	op_nop,		store_MHL	;77		;LD (HL),A
001378 c0d3
00144c 2d69
00144d cb42                      instr 	fetch_B,	op_nop,		store_A		;78		;LD A,B
001379 c0d4
00144e 2d68
00144f cb40                      instr 	fetch_C,	op_nop,		store_A		;79		;LD A,C
00137a c0d5
001450 2d6b
001451 cb3e                      instr 	fetch_D,	op_nop,		store_A		;7A		;LD A,D
00137b c0d6
001452 2d6a
001453 cb3c                      instr 	fetch_E,	op_nop,		store_A		;7B		;LD A,E
00137c c0d7
001454 2d6d
001455 cb3a                      instr 	fetch_H,	op_nop,		store_A		;7C		;LD A,H
00137d c0d8
001456 2d6c
001457 cb38                      instr 	fetch_L,	op_nop,		store_A		;7D		;LD A,L
00137e c0d9
001458 daec
001459 cb36                      instr 	fetch_MHL,	op_nop,		store_A		;7E		;LD A,(HL)
00137f 9508                      instr 	fetch_nop,	op_nop,		store_nop	;7F		;LD A,A
001380 c0d9
00145a 2d69
00145b cc44                      instr 	fetch_B,	op_ADDA,	store_nop	;80		;ADD A,B
001381 c0da
00145c 2d68
00145d cc42                      instr 	fetch_C,	op_ADDA,	store_nop	;81		;ADD A,C
001382 c0db
00145e 2d6b
00145f cc40                      instr 	fetch_D,	op_ADDA,	store_nop	;82		;ADD A,D
001383 c0dc
001460 2d6a
001461 cc3e                      instr 	fetch_E,	op_ADDA,	store_nop	;83		;ADD A,E
001384 c0dd
001462 2d6d
001463 cc3c                      instr 	fetch_H,	op_ADDA,	store_nop	;84		;ADD A,H
001385 c0de
001464 2d6c
001465 cc3a                      instr 	fetch_L,	op_ADDA,	store_nop	;85		;ADD A,L
001386 c0df
001466 dade
001467 cc38                      instr 	fetch_MHL,	op_ADDA,	store_nop	;86		;ADD A,(HL)
001387 c0e0
001468 2f65
001469 cc36                      instr 	fetch_A,	op_ADDA,	store_nop	;87		;ADD A,A
001388 c0e1
00146a 2d69
00146b cc40                      instr 	fetch_B,	op_ADCA,	store_nop	;88		;ADC A,B
001389 c0e2
00146c 2d68
00146d cc3e                      instr 	fetch_C,	op_ADCA,	store_nop	;89		;ADC A,C
00138a c0e3
00146e 2d6b
00146f cc3c                      instr 	fetch_D,	op_ADCA,	store_nop	;8A		;ADC A,D
00138b c0e4
001470 2d6a
001471 cc3a                      instr 	fetch_E,	op_ADCA,	store_nop	;8B		;ADC A,E
00138c c0e5
001472 2d6d
001473 cc38                      instr 	fetch_H,	op_ADCA,	store_nop	;8C		;ADC A,H
00138d c0e6
001474 2d6c
001475 cc36                      instr 	fetch_L,	op_ADCA,	store_nop	;8D		;ADC A,L
00138e c0e7
001476 dace
001477 cc34                      instr 	fetch_MHL,	op_ADCA,	store_nop	;8E		;ADC A,(HL)
00138f c0e8
001478 2f65
001479 cc32                      instr 	fetch_A,	op_ADCA,	store_nop	;8F		;ADC A,A
001390 c0e9
00147a 2d69
00147b cc3f                      instr 	fetch_B,	op_SUBFA,	store_nop	;90		;SUB A,B
001391 c0ea
00147c 2d68
00147d cc3d                      instr 	fetch_C,	op_SUBFA,	store_nop	;91		;SUB A,C
001392 c0eb
00147e 2d6b
00147f cc3b                      instr 	fetch_D,	op_SUBFA,	store_nop	;92		;SUB A,D
001393 c0ec
001480 2d6a
001481 cc39                      instr 	fetch_E,	op_SUBFA,	store_nop	;93		;SUB A,E
001394 c0ed
001482 2d6d
001483 cc37                      instr 	fetch_H,	op_SUBFA,	store_nop	;94		;SUB A,H
001395 c0ee
001484 2d6c
001485 cc35                      instr 	fetch_L,	op_SUBFA,	store_nop	;95		;SUB A,L
001396 c0ef
001486 dabe
001487 cc33                      instr 	fetch_MHL,	op_SUBFA,	store_nop	;96		;SUB A,(HL)
001397 c0f0
001488 2f65
001489 cc31                      instr 	fetch_A,	op_SUBFA,	store_nop	;97		;SUB A,A
001398 c0f1
00148a 2d69
00148b cc4a                      instr 	fetch_B,	op_SBCFA,	store_nop	;98		;SBC A,B
001399 c0f2
00148c 2d68
00148d cc48                      instr 	fetch_C,	op_SBCFA,	store_nop	;99		;SBC A,C
00139a c0f3
00148e 2d6b
00148f cc46                      instr 	fetch_D,	op_SBCFA,	store_nop	;9A		;SBC A,D
00139b c0f4
001490 2d6a
001491 cc44                      instr 	fetch_E,	op_SBCFA,	store_nop	;9B		;SBC A,E
00139c c0f5
001492 2d6d
001493 cc42                      instr 	fetch_H,	op_SBCFA,	store_nop	;9C		;SBC A,H
00139d c0f6
001494 2d6c
001495 cc40                      instr 	fetch_L,	op_SBCFA,	store_nop	;9D		;SBC A,L
00139e c0f7
001496 daae
001497 cc3e                      instr 	fetch_MHL,	op_SBCFA,	store_nop	;9E		;SBC A,(HL)
00139f c0f8
001498 2f65
001499 cc3c                      instr 	fetch_A,	op_SBCFA,	store_nop	;9F		;SBC A,A
0013a0 c0f9
00149a 2d69
00149b cc4a                      instr 	fetch_B,	op_ANDA,	store_nop	;A0		;AND A,B
0013a1 c0fa
00149c 2d68
00149d cc48                      instr 	fetch_C,	op_ANDA,	store_nop	;A1		;AND A,C
0013a2 c0fb
00149e 2d6b
00149f cc46                      instr 	fetch_D,	op_ANDA,	store_nop	;A2		;AND A,D
0013a3 c0fc
0014a0 2d6a
0014a1 cc44                      instr 	fetch_E,	op_ANDA,	store_nop	;A3		;AND A,E
0013a4 c0fd
0014a2 2d6d
0014a3 cc42                      instr 	fetch_H,	op_ANDA,	store_nop	;A4		;AND A,H
0013a5 c0fe
0014a4 2d6c
0014a5 cc40                      instr 	fetch_L,	op_ANDA,	store_nop	;A5		;AND A,L
0013a6 c0ff
0014a6 da9e
0014a7 cc3e                      instr 	fetch_MHL,	op_ANDA,	store_nop	;A6		;AND A,(HL)
0013a7 c100
0014a8 2f65
0014a9 cc3c                      instr 	fetch_A,	op_ANDA,	store_nop	;A7		;AND A,A
0013a8 c101
0014aa 2d69
0014ab cc45                      instr 	fetch_B,	op_XORA,	store_nop	;A8		;XOR A,B
0013a9 c102
0014ac 2d68
0014ad cc43                      instr 	fetch_C,	op_XORA,	store_nop	;A9		;XOR A,C
0013aa c103
0014ae 2d6b
0014af cc41                      instr 	fetch_D,	op_XORA,	store_nop	;AA		;XOR A,D
0013ab c104
0014b0 2d6a
0014b1 cc3f                      instr 	fetch_E,	op_XORA,	store_nop	;AB		;XOR A,E
0013ac c105
0014b2 2d6d
0014b3 cc3d                      instr 	fetch_H,	op_XORA,	store_nop	;AC		;XOR A,H
0013ad c106
0014b4 2d6c
0014b5 cc3b                      instr 	fetch_L,	op_XORA,	store_nop	;AD		;XOR A,L
0013ae c107
0014b6 da8e
0014b7 cc39                      instr 	fetch_MHL,	op_XORA,	store_nop	;AE		;XOR A,(HL)
0013af c108
0014b8 2f65
0014b9 cc37                      instr 	fetch_A,	op_XORA,	store_nop	;AF		;XOR A,A
0013b0 c109
0014ba 2d69
0014bb cc30                      instr 	fetch_B,	op_ORA,		store_nop	;B0		;OR A,B
0013b1 c10a
0014bc 2d68
0014bd cc2e                      instr 	fetch_C,	op_ORA,		store_nop	;B1		;OR A,C
0013b2 c10b
0014be 2d6b
0014bf cc2c                      instr 	fetch_D,	op_ORA,		store_nop	;B2		;OR A,D
0013b3 c10c
0014c0 2d6a
0014c1 cc2a                      instr 	fetch_E,	op_ORA,		store_nop	;B3		;OR A,E
0013b4 c10d
0014c2 2d6d
0014c3 cc28                      instr 	fetch_H,	op_ORA,		store_nop	;B4		;OR A,H
0013b5 c10e
0014c4 2d6c
0014c5 cc26                      instr 	fetch_L,	op_ORA,		store_nop	;B5		;OR A,L
0013b6 c10f
0014c6 da7e
0014c7 cc24                      instr 	fetch_MHL,	op_ORA,		store_nop	;B6		;OR A,(HL)
0013b7 c110
0014c8 2f65
0014c9 cc22                      instr 	fetch_A,	op_ORA,		store_nop	;B7		;OR A,A
0013b8 c111
0014ca 2d69
0014cb cbfc                      instr 	fetch_B,	op_CPFA,	store_nop	;B8		;CP A,B
0013b9 c112
0014cc 2d68
0014cd cbfa                      instr 	fetch_C,	op_CPFA,	store_nop	;B9		;CP A,C
0013ba c113
0014ce 2d6b
0014cf cbf8                      instr 	fetch_D,	op_CPFA,	store_nop	;BA		;CP A,D
0013bb c114
0014d0 2d6a
0014d1 cbf6                      instr 	fetch_E,	op_CPFA,	store_nop	;BB		;CP A,E
0013bc c115
0014d2 2d6d
0014d3 cbf4                      instr 	fetch_H,	op_CPFA,	store_nop	;BC		;CP A,H
0013bd c116
0014d4 2d6c
0014d5 cbf2                      instr 	fetch_L,	op_CPFA,	store_nop	;BD		;CP A,L
0013be c117
0014d6 da6e
0014d7 cbf0                      instr 	fetch_MHL,	op_CPFA,	store_nop	;BE		;CP A,(HL)
0013bf c118
0014d8 2f65
0014d9 cbee                      instr 	fetch_A,	op_CPFA,	store_nop	;BF		;CP A,A
0013c0 c119
0014da dce5
0014db cafe                      instr 	fetch_nop,	op_IFNZ,	store_RET	;C0		;RET NZ
0013c1 c11a
0014dc dcbc
0014dd cac2                      instr 	fetch_nop,	op_POP16,	store_BC	;C1		;POP BC
0013c2 c11b
0014de da98
0014df dce0
0014e0 caf0                      instr 	fetch_DIR16,	op_IFNZ,	store_PC	;C2 nn nn	;JP NZ,nn
0013c3 c11d
0014e1 da95
0014e2 caee                      instr 	fetch_DIR16,	op_nop,		store_PC	;C3 nn nn	;JP nn
0013c4 c11e
0014e3 da93
0014e4 dcdb
0014e5 cb0f                      instr 	fetch_DIR16,	op_IFNZ,	store_CALL	;C4 nn nn	;CALL NZ,nn
0013c5 c120
0014e6 01b4
0014e7 cc9e                      instr 	fetch_BC,	op_PUSH16,	store_nop	;C5		;PUSH BC
0013c6 c121
0014e8 da81
0014e9 cbb6                      instr 	fetch_DIR8,	op_ADDA,	store_nop	;C6 nn		;ADD A,n
0013c7 c122
0014ea da32
0014eb cb09                      instr 	fetch_RST,	op_nop,		store_CALL	;C7		;RST 0
0013c8 c123
0014ec dcd8
0014ed caec                      instr 	fetch_nop,	op_IFZ,		store_RET	;C8		;RET Z
0013c9 cc10                      instr 	fetch_nop,	op_nop,		store_RET	;C9		;RET
0013ca c123
0014ee da88
0014ef dcd5
0014f0 cae0                      instr 	fetch_DIR16,	op_IFZ,		store_PC	;CA nn nn	;JP Z,nn
0013cb ce67                      instr 	fetch_nop,	op_prefixCB,	store_nop	;CB 		;(CB opcode prefix)
0013cc c124
0014f1 da85
0014f2 dcd2
0014f3 cb01                      instr 	fetch_DIR16,	op_IFZ,		store_CALL	;CC nn nn	;CALL Z,nn
0013cd c126
0014f4 da82
0014f5 caff                      instr 	fetch_DIR16,	op_nop,		store_CALL	;CD nn nn	;CALL nn
0013ce c127
0014f6 da73
0014f7 cbb4                      instr 	fetch_DIR8,	op_ADCA,	store_nop	;CE nn		;ADC A,n
0013cf c11a                      instr 	fetch_RST,	op_nop,		store_CALL	;CF		;RST 8H
0013d0 c127
0014f8 dcd1
0014f9 cae0                      instr 	fetch_nop,	op_IFNC,	store_RET	;D0		;RET NC
0013d1 c128
0014fa dc9e
0014fb caa6                      instr 	fetch_nop,	op_POP16,	store_DE	;D1		;POP DE
0013d2 c129
0014fc da7a
0014fd dccc
0014fe cad2                      instr 	fetch_DIR16,	op_IFNC,	store_PC	;D2 nn nn	;JP NC,nn
0013d3 c12b
0014ff da6a
001500 cb2f                      instr 	fetch_DIR8,	op_OUTA,	store_nop	;D3 nn		;OUT (n),A
0013d4 c12c
001501 da75
001502 dcc7
001503 caf1                      instr 	fetch_DIR16,	op_IFNC,	store_CALL	;D4 nn nn	;CALL NC,nn
0013d5 c12e
001504 01b5
001505 cc80                      instr 	fetch_DE,	op_PUSH16,	store_nop	;D5		;PUSH DE
0013d6 c12f
001506 da63
001507 cbb3                      instr 	fetch_DIR8,	op_SUBFA,	store_nop	;D6 nn		;SUB n
0013d7 c112                      instr 	fetch_RST,	op_nop,		store_CALL	;D7		;RST 10H
0013d8 c12f
001508 dcc6
001509 cad0                      instr 	fetch_nop,	op_IFC,		store_RET	;D8		;RET C
0013d9 ce1d                      instr 	fetch_nop,	op_EXX,		store_nop	;D9		;EXX
0013da c12f
00150a da6c
00150b dcc3
00150c cac4                      instr 	fetch_DIR16,	op_IFC,		store_PC	;DA nn nn	;JP C,nn
0013db c131
00150d da5c
00150e cb26                      instr 	fetch_DIR8,	op_INA,		store_nop	;DB nn		;IN A,(n)
0013dc c132
00150f da67
001510 dcbe
001511 cae3                      instr 	fetch_DIR16,	op_IFC,		store_CALL	;DC nn nn	;CALL C,nn
0013dd ce37                      instr 	fetch_nop,	op_prefixDD,	store_nop	;DD 		;(DD opcode prefix)
0013de c133
001512 da57
001513 cbc2                      instr 	fetch_DIR8,	op_SBCFA,	store_nop	;DE nn		;SBC A,n
0013df c10a                      instr 	fetch_RST,	op_nop,		store_CALL	;DF		;RST 18H
0013e0 c133
001514 dcbf
001515 cac4                      instr 	fetch_nop,	op_IFPO,	store_RET	;E0		;RET PO
0013e1 c134
001516 dc82
001517 ca8c                      instr 	fetch_nop,	op_POP16,	store_HL	;E1		;POP HL
0013e2 c135
001518 da5e
001519 dcba
00151a cab6                      instr 	fetch_DIR16,	op_IFPO,	store_PC	;E2 nn nn	;JP PO,nn
0013e3 c137
00151b da35
00151c dc97
00151d caa0                      instr 	fetch_MSP,	op_EXHL,	store_MSP	;E3		;EX (SP),HL
0013e4 c139
00151e da58
00151f dcb4
001520 cad4                      instr 	fetch_DIR16,	op_IFPO,	store_CALL	;E4 nn nn	;CALL PO,nn
0013e5 c13b
001521 01b6
001522 cc63                      instr 	fetch_HL,	op_PUSH16,	store_nop	;E5		;PUSH HL
0013e6 c13c
001523 da46
001524 cbc1                      instr 	fetch_DIR8,	op_ANDA,	store_nop	;E6 nn		;AND n
0013e7 c102                      instr 	fetch_RST,	op_nop,		store_CALL	;E7		;RST 20H
0013e8 c13c
001525 dcb3
001526 cab3                      instr 	fetch_nop,	op_IFPE,	store_RET	;E8		;RET PE
0013e9 c13d
001527 01b6
001528 caa8                      instr 	fetch_HL,	op_nop,		store_PC	;E9		;JP HL
0013ea c13e
001529 da4d
00152a dcae
00152b caa5                      instr 	fetch_DIR16,	op_IFPE,	store_PC	;EA nn nn	;JP PE,nn
0013eb c140
00152c 01b5
00152d dc86
00152e ca73                      instr 	fetch_DE,	op_EXHL,	store_DE	;EB		;EX DE,HL
0013ec c142
00152f da47
001530 dca8
001531 cac3                      instr 	fetch_DIR16,	op_IFPE,	store_CALL	;EC nn nn	;CALL PE,nn
0013ed ce19                      instr 	fetch_nop,	op_prefixED,	store_nop	;ED		;(ED opcode prefix)
0013ee c143
001532 da37
001533 cbbd                      instr 	fetch_DIR8,	op_XORA,	store_nop	;EE nn		;XOR n
0013ef c0fa                      instr 	fetch_RST,	op_nop,		store_CALL	;EF		;RST 28H
0013f0 c143
001534 dca9
001535 caa4                      instr 	fetch_nop,	op_IFP,		store_RET	;F0		;RET P
0013f1 c144
001536 dc62
001537 ca66                      instr 	fetch_nop,	op_POP16,	store_AF	;F1		;POP AF
0013f2 c145
001538 da3e
001539 dca4
00153a ca96                      instr 	fetch_DIR16,	op_IFP,		store_PC	;F2 nn nn	;JP P,nn
0013f3 cdc4                      instr 	fetch_nop,	op_DI,		store_nop	;F3		;DI
0013f4 c146
00153b da3b
00153c dca1
00153d cab7                      instr 	fetch_DIR16,	op_IFP,		store_CALL	;F4 nn nn	;CALL P,nn
0013f5 c148
00153e 01ba
00153f cc46                      instr 	fetch_AF,	op_PUSH16,	store_nop	;F5		;PUSH AF
0013f6 c149
001540 da29
001541 cbaa                      instr 	fetch_DIR8,	op_ORA,		store_nop	;F6 nn		;OR n
0013f7 c0f2                      instr 	fetch_RST,	op_nop,		store_CALL	;F7		;RST 30H
0013f8 c149
001542 dca0
001543 ca96                      instr 	fetch_nop,	op_IFM,		store_RET	;F8		;RET M
0013f9 c14a
001544 01b6
001545 ca89                      instr 	fetch_HL,	op_nop,		store_SP	;F9		;LD SP,HL
0013fa c14b
001546 da30
001547 dc9b
001548 ca88                      instr 	fetch_DIR16,	op_IFM,		store_PC	;FA nn nn	;JP M,nn
0013fb cdc0                      instr 	fetch_nop,	op_EI,		store_nop	;FB		;EI
0013fc c14c
001549 da2d
00154a dc98
00154b caa9                      instr 	fetch_DIR16,	op_IFM,		store_CALL	;FC nn nn	;CALL M,nn
0013fd ce26                      instr 	fetch_nop,	op_prefixFD,	store_nop	;FD 		;(FD opcode prefix)
0013fe c14d
00154c da1d
00154d cb7a                      instr 	fetch_DIR8,	op_CPFA,	store_nop	;FE nn		;CP n
0013ff c0ea                      instr 	fetch_RST,	op_nop,		store_CALL	;FF		;RST 38H
                                 
                                 
                                 #if EM_Z80
                                 
                                 
                                 
                                 	checkspace PC, 2
                                 
                                 do_op_noni:
00154e 9701                      	sbiw	z_pcl,1				;--z_pc
00154f 9508                      	ret
                                 
                                 	checkspace PC, 16
                                 
                                 do_fetch_dir8_2:
001550 01dc                      	movw	xl,z_pcl
001551 9611                      	adiw	xl,1
001552 b9bb
001553 b828
001554 b9ab
001555 b838
001556 b87a
001557 b848
001558 c000
001559 0000
00155a b169
00155b b868
00155c b86a                      	mem_read_d opl
00155d 9508                      	ret
                                 
                                 	checkspace PC, 5
                                 
                                 do_fetch_xh:
00155e 9bf1                      	sbis	flags,prefixfd
00155f 8569                      	ldd	opl,y+oz_xh
001560 99f1                      	sbic	flags,prefixfd
001561 856b                      	ldd	opl,y+oz_yh
001562 9508                      	ret
                                 
                                 	checkspace PC, 5
                                 
                                 do_fetch_xl:
001563 9bf1                      	sbis	flags,prefixfd
001564 8568                      	ldd	opl,y+oz_xl
001565 99f1                      	sbic	flags,prefixfd
001566 856a                      	ldd	opl,y+oz_yl
001567 9508                      	ret
                                 
                                 
                                 	checkspace PC, 41
                                 
                                 do_fetch_mxx:
001568 99f1                      	sbic	flags,prefixfd
001569 c003                      	rjmp	fetchmxx_fd
00156a 85b9                      	ldd	xh,y+oz_xh
00156b 85a8                      	ldd	xl,y+oz_xl
00156c c002                      	rjmp	fetchmxx1
                                 fetchmxx_fd:
00156d 85bb                      	ldd	xh,y+oz_yh
00156e 85aa                      	ldd	xl,y+oz_yl
                                 fetchmxx1:
00156f b99b
001570 b828
001571 b98b
001572 b838
001573 b87a
001574 b848
001575 c000
001576 0000
001577 b169
001578 b868
001579 b86a                      	mem_read_ds opl, z_pc			;get displacement
00157a 9601                      	adiw z_pcl,1
00157b 2777                      	clr	oph				;sign extend
00157c 2366                      	tst	opl
00157d f40a                      	brpl	fetchmxx2
00157e 9570                      	com	oph
                                 fetchmxx2:
00157f 0fa6                      	add	xl,opl				;add displacement
001580 1fb7                      	adc	xh,oph
001581 b9bb
001582 b828
001583 b9ab
001584 b838
001585 b87a
001586 b848
001587 c000
001588 0000
001589 b169
00158a b868
00158b b86a                      	mem_read_d opl				;get operand
00158c 9508                      	ret					;(Ix+d) still in xl,xh
                                 
                                 
                                 	checkspace PC, 8
                                 
                                 do_fetch_xx:
00158d 99f1                      	sbic	flags,prefixfd
00158e c003                      	rjmp	fetchxx_fd
00158f 8568                      	ldd	opl,y+oz_xl
001590 8579                      	ldd	oph,y+oz_xh
001591 9508                      	ret
                                 fetchxx_fd:
001592 856a                      	ldd	opl,y+oz_yl
001593 857b                      	ldd	oph,y+oz_yh
001594 9508                      	ret
                                 
                                 	checkspace PC, 5
                                 
                                 do_store_xh:
001595 9bf1                      	sbis	flags,prefixfd
001596 8769                      	std	y+oz_xh,opl
001597 99f1                      	sbic	flags,prefixfd
001598 876b                      	std	y+oz_yh,opl
001599 9508                      	ret
                                 
                                 	checkspace PC, 5
                                 
                                 do_store_xl:
00159a 9bf1                      	sbis	flags,prefixfd
00159b 8768                      	std	y+oz_xl,opl
00159c 99f1                      	sbic	flags,prefixfd
00159d 876a                      	std	y+oz_yl,opl
00159e 9508                      	ret
                                 
                                 	checkspace PC, 37
                                 
                                 do_store_mxx:
00159f 99f1                      	sbic	flags,prefixfd
0015a0 c003                      	rjmp	storemxx_fd
0015a1 85b9                      	ldd	xh,y+oz_xh
0015a2 85a8                      	ldd	xl,y+oz_xl
0015a3 c002                      	rjmp	storemxx1
                                 storemxx_fd:
0015a4 85bb                      	ldd	xh,y+oz_yh
0015a5 85aa                      	ldd	xl,y+oz_yl
                                 storemxx1:
0015a6 b99b
0015a7 b828
0015a8 b98b
0015a9 b838
0015aa b87a
0015ab b848
0015ac c000
0015ad 0000
0015ae b109
0015af b868
0015b0 b86a                      	mem_read_s z_pc				;get displacement
0015b1 9601                      	adiw z_pcl,1
0015b2 2711                      	clr	temp2				;sign extend
0015b3 2300                      	tst	temp
0015b4 f40a                      	brpl	storemxx2
0015b5 9510                      	com	temp2
                                 storemxx2:
0015b6 0fa0                      	add	xl,temp				;add displacement
0015b7 1fb1                      	adc	xh,temp2
0015b8 b9bb
0015b9 b828
0015ba b9ab
0015bb b838
0015bc b96b
0015bd b858
0015be b868                      	mem_write_s opl				;store operand
0015bf 9508                      	ret
                                 
                                 	checkspace PC, 10
                                 
                                 do_store_mxx_0:
0015c0 b9bb
0015c1 b828
0015c2 b9ab
0015c3 b838
0015c4 b96b
0015c5 b858
0015c6 b868                      	mem_write_s opl				;store operand
0015c7 9508                      	ret
                                 
                                 	checkspace PC, 38
                                 
                                 do_store_mxx_2:
0015c8 99f1                      	sbic	flags,prefixfd
0015c9 c003                      	rjmp	storemxx2_fd
0015ca 85b9                      	ldd	xh,y+oz_xh
0015cb 85a8                      	ldd	xl,y+oz_xl
0015cc c002                      	rjmp	storemxx21
                                 storemxx2_fd:
0015cd 85bb                      	ldd	xh,y+oz_yh
0015ce 85aa                      	ldd	xl,y+oz_yl
                                 storemxx21:
0015cf b99b
0015d0 b828
0015d1 b98b
0015d2 b838
0015d3 b87a
0015d4 b848
0015d5 c000
0015d6 0000
0015d7 b109
0015d8 b868
0015d9 b86a                      	mem_read_s z_pc				;get displacement
0015da 9601                      	adiw	z_pcl,1
0015db 9601                      	adiw	z_pcl,1
0015dc 2711                      	clr	temp2				;sign extend
0015dd 2300                      	tst	temp
0015de f40a                      	brpl	storemxx22
0015df 9510                      	com	temp2
                                 storemxx22:
0015e0 0fa0                      	add	xl,temp				;add displacement
0015e1 1fb1                      	adc	xh,temp2
0015e2 b9bb
0015e3 b828
0015e4 b9ab
0015e5 b838
0015e6 b96b
0015e7 b858
0015e8 b868                      	mem_write_s opl				;store operand
0015e9 9508                      	ret
                                 
                                 	checkspace PC, 8
                                 
                                 do_store_xx:
0015ea 99f1                      	sbic	flags,prefixfd
0015eb c003                      	rjmp	storexx_fd
0015ec 8768                      	std	y+oz_xl,opl
0015ed 8779                      	std	y+oz_xh,oph
0015ee 9508                      	ret
                                 storexx_fd:
0015ef 876a                      	std	y+oz_yl,opl
0015f0 877b                      	std	y+oz_yh,oph
0015f1 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|LD dst,src|------|Load                 |dst=src               |
                                 ;
                                 
                                 	checkspace PC, 30
                                 
                                 do_op_stxx: 		;store xx to mem loc in opl:h
                                 
0015f2 01db                      	movw	xl,opl
0015f3 9bf1                      	sbis	flags,prefixfd
0015f4 8508                      	ldd	temp,y+oz_xl
0015f5 99f1                      	sbic	flags,prefixfd
0015f6 850a                      	ldd	temp,y+oz_yl
0015f7 b9bb
0015f8 b828
0015f9 b9ab
0015fa b838
0015fb b90b
0015fc b858
0015fd b868                      	mem_write
0015fe 9611                      	adiw xl,1
0015ff 9bf1                      	sbis	flags,prefixfd
001600 8509                      	ldd	temp,y+oz_xh
001601 99f1                      	sbic	flags,prefixfd
001602 850b                      	ldd	temp,y+oz_yh
001603 b9bb
001604 b828
001605 b9ab
001606 b838
001607 b90b
001608 b858
001609 b868                      	mem_write
00160a 9508                      	ret
                                 
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|EX [SP],IX|------|Exchange             |[SP]<->IX             |
                                 ;|EX [SP],IY|------|Exchange             |[SP]<->IY             |
                                 ; 
                                 	checkspace PC, 13
                                 
                                 do_op_EXxx:
00160b 99f1                      	sbic	flags,prefixfd
00160c c005                      	rjmp	opexxx_fd
00160d 8508                      	ldd	temp,y+oz_xl
00160e 8519                      	ldd	temp2,y+oz_xh
00160f 8768                      	std	y+oz_xl,opl
001610 8779                      	std	y+oz_xh,oph
001611 c004                      	rjmp	opexxxe
                                 opexxx_fd:
001612 850a                      	ldd	temp,y+oz_yl
001613 851b                      	ldd	temp2,y+oz_yh
001614 876a                      	std	y+oz_yl,opl
001615 877b                      	std	y+oz_yh,oph
                                 opexxxe:
001616 01b8                      	movw	opl,temp
001617 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|ADD IX,pp |--*-0*|Add                  |IX=IX+pp              |
                                 ;|ADD IY,rr |--*-0*|Add                  |IY=IY+rr              |
                                 ;
                                 
                                 	checkspace PC, 25
                                 
                                 do_op_addxx:
001618 99f1                      	sbic	flags,prefixfd
001619 c007                      	rjmp	opadx_fd
00161a 8508                      	ldd	temp,y+oz_xl
00161b 8519                      	ldd	temp2,y+oz_xh
00161c 0f60                      	add	opl,temp
00161d 1f71                      	adc	oph,temp2
00161e 8768                      	std	y+oz_xl,opl
00161f 8779                      	std	y+oz_xh,oph
001620 c006                      	rjmp	opadx_e
                                 opadx_fd:
001621 850a                      	ldd	temp,y+oz_yl
001622 851b                      	ldd	temp2,y+oz_yh
001623 0f60                      	add	opl,temp
001624 1f71                      	adc	oph,temp2
001625 876a                      	std	y+oz_yl,opl
001626 877b                      	std	y+oz_yh,oph
                                 opadx_e:
001627 b70f                      	in	temp,sreg
001628 fb00
001629 f940                      	bmov	z_flags,ZFL_C, temp,AVR_C
00162a fb05
00162b f944                      	do_z80_flags_H
00162c 7f4d                      	do_z80_flags_clear_N
00162d 9508                      	ret
                                 
                                 
                                 	opctable DDFDjmp, PC	;+256
                                 
001700 ce4d                      instr 	fetch_nop,	op_noni,		store_nop	;00		;
001701 ce4c                      instr 	fetch_nop,	op_noni,	store_nop	;01		;
001702 ce4b                      instr 	fetch_nop,	op_noni,	store_nop	;02		;
001703 ce4a                      instr 	fetch_nop,	op_noni,	store_nop	;03		;
001704 ce49                      instr 	fetch_nop,	op_noni,	store_nop	;04		;
001705 ce48                      instr 	fetch_nop,	op_noni,	store_nop	;05		;
001706 ce47                      instr 	fetch_nop,	op_noni,	store_nop	;06		;
001707 ce46                      instr 	fetch_nop,	op_noni,	store_nop	;07		;
001708 ce45                      instr 	fetch_nop,	op_noni,	store_nop	;08		;
001709 cf24
00162e 01b4
00162f cfe8                      instr 	fetch_BC,	op_ADDxx,	store_nop	;09		;ADD xx,BC
00170a ce43                      instr 	fetch_nop,	op_noni,	store_nop	;0A		;
00170b ce42                      instr 	fetch_nop,	op_noni,	store_nop	;0B		;
00170c ce41                      instr 	fetch_nop,	op_noni,	store_nop	;0C		;
00170d ce40                      instr 	fetch_nop,	op_noni,	store_nop	;0D		;
00170e ce3f                      instr 	fetch_nop,	op_noni,	store_nop	;0E		;
00170f ce3e                      instr 	fetch_nop,	op_noni,	store_nop	;0F		;
001710 ce3d                      instr 	fetch_nop,	op_noni,	store_nop	;10		;
001711 ce3c                      instr 	fetch_nop,	op_noni,	store_nop	;11		;
001712 ce3b                      instr 	fetch_nop,	op_noni,	store_nop	;12		;
001713 ce3a                      instr 	fetch_nop,	op_noni,	store_nop	;13		;
001714 ce39                      instr 	fetch_nop,	op_noni,	store_nop	;14		;
001715 ce38                      instr 	fetch_nop,	op_noni,	store_nop	;15		;
001716 ce37                      instr 	fetch_nop,	op_noni,	store_nop	;16		;
001717 ce36                      instr 	fetch_nop,	op_noni,	store_nop	;17		;
001718 ce35                      instr 	fetch_nop,	op_noni,	store_nop	;18		;
001719 cf16
001630 01b5
001631 cfe6                      instr 	fetch_DE,	op_ADDxx,	store_nop	;19		;ADD xx,DE
00171a ce33                      instr 	fetch_nop,	op_noni,	store_nop	;1A		;
00171b ce32                      instr 	fetch_nop,	op_noni,	store_nop	;1B		;
00171c ce31                      instr 	fetch_nop,	op_noni,	store_nop	;1C		;
00171d ce30                      instr 	fetch_nop,	op_noni,	store_nop	;1D		;
00171e ce2f                      instr 	fetch_nop,	op_noni,	store_nop	;1E		;
00171f ce2e                      instr 	fetch_nop,	op_noni,	store_nop	;1F		;
001720 ce2d                      instr 	fetch_nop,	op_noni,	store_nop	;20		;
001721 cf10
001632 d944
001633 cfb6                      instr 	fetch_DIR16,	op_nop,		store_xx	;21		;LD xx,nn
001722 cf11
001634 d942
001635 cfbc                      instr 	fetch_DIR16,	op_STxx,	store_nop	;22		;LD (nn),xx
001723 cf12
001636 df56
001637 da32
001638 cfb1                      instr 	fetch_xx,	op_INC16,	store_xx	;23		;INC xx
001724 cf14
001639 df24
00163a d9ff
00163b cf59                      instr 	fetch_xH,	op_INC,		store_xH	;24		;INC xh
001725 cf16
00163c df21
00163d da14
00163e cf56                      instr 	fetch_xH,	op_DEC,		store_xH	;25		;DEC xh
001726 cf18
00163f d92a
001640 cf54                      instr 	fetch_DIR8,	op_nop,		store_xH	;26		;LD xh,n
001727 ce26                      instr 	fetch_nop,	op_noni,	store_nop	;27		;
001728 ce25                      instr 	fetch_nop,	op_noni,	store_nop	;28		;
001729 cf17
001641 df4b
001642 cfd5                      instr 	fetch_xx,	op_ADDxx,	store_nop	;29		;ADD xx,xx
00172a cf18
001643 d933
001644 dacb
001645 cfa4                      instr 	fetch_DIR16,	op_RMEM16,	store_xx	;2A		;LD xx,(nn)
00172b cf1a
001646 df46
001647 da2e
001648 cfa1                      instr 	fetch_xx,	op_DEC16,	store_xx	;2B		;DEC xx
00172c cf1c
001649 df19
00164a d9ef
00164b cf4e                      instr 	fetch_xL,	op_INC,		store_xL	;2C		;INC xl
00172d cf1e
00164c df16
00164d da04
00164e cf4b                      instr 	fetch_xL,	op_DEC,		store_xL	;2D		;DEC xl
00172e cf20
00164f d91a
001650 cf49                      instr 	fetch_DIR8,	op_nop,		store_xL	;2E		;LD xl,n
00172f ce1e                      instr 	fetch_nop,	op_noni,	store_nop	;2F		;
001730 ce1d                      instr 	fetch_nop,	op_noni,	store_nop	;30		;
001731 ce1c                      instr 	fetch_nop,	op_noni,	store_nop	;31		;
001732 ce1b                      instr 	fetch_nop,	op_noni,	store_nop	;32		;
001733 ce1a                      instr 	fetch_nop,	op_noni,	store_nop	;33		;
001734 cf1c
001651 df16
001652 d9e7
001653 cf6c                      instr 	fetch_MXX,	op_INC,		store_MXX_0	;34		;INC (xx+d)
001735 cf1e
001654 df13
001655 d9fc
001656 cf69                      instr 	fetch_MXX,	op_DEC,		store_MXX_0	;35		;DEC (xx+d)
001736 cf20
001657 def8
001658 cf6f                      instr 	fetch_DIR8_2,	op_nop,		store_MXX_2	;36		;LD (xx+d),n
001737 ce16                      instr 	fetch_nop,	op_noni,	store_nop	;37		;
001738 ce15                      instr 	fetch_nop,	op_noni,	store_nop	;38		;
001739 cf1f
001659 01b7
00165a cfbd                      instr 	fetch_SP,	op_ADDxx,	store_nop	;39		;ADD xx,SP
00173a ce13                      instr 	fetch_nop,	op_noni,	store_nop	;3A		;
00173b ce12                      instr 	fetch_nop,	op_noni,	store_nop	;3B		;
00173c ce11                      instr 	fetch_nop,	op_noni,	store_nop	;3C		;
00173d ce10                      instr 	fetch_nop,	op_noni,	store_nop	;3D		;
00173e ce0f                      instr 	fetch_nop,	op_noni,	store_nop	;3E		;
00173f ce0e                      instr 	fetch_nop,	op_noni,	store_nop	;3F		;
001740 ce0d                      instr 	fetch_nop,	op_noni,	store_nop	;40		;
001741 ce0c                      instr 	fetch_nop,	op_noni,	store_nop	;41		;
001742 ce0b                      instr 	fetch_nop,	op_noni,	store_nop	;42		;
001743 ce0a                      instr 	fetch_nop,	op_noni,	store_nop	;43		;
001744 cf16
00165b df02
00165c c935                      instr 	fetch_xH,	op_nop,		store_B		;44		;LD B,xh
001745 cf17
00165d df05
00165e c933                      instr 	fetch_xL,	op_nop,		store_B		;45		;LD B,xl
001746 cf18
00165f df08
001660 c931                      instr 	fetch_MXX,	op_nop,		store_B		;46		;LD B,(xx+d)
001747 ce06                      instr 	fetch_nop,	op_noni,	store_nop	;47		;
001748 ce05                      instr 	fetch_nop,	op_noni,	store_nop	;48		;
001749 ce04                      instr 	fetch_nop,	op_noni,	store_nop	;49		;
00174a ce03                      instr 	fetch_nop,	op_noni,	store_nop	;4A		;
00174b ce02                      instr 	fetch_nop,	op_noni,	store_nop	;4B		;
00174c cf14
001661 defc
001662 c931                      instr 	fetch_xH,	op_nop,		store_C		;4C		;LD C,xh
00174d cf15
001663 deff
001664 c92f                      instr 	fetch_xL,	op_nop,		store_C		;4D		;LD C,xl
00174e cf16
001665 df02
001666 c92d                      instr 	fetch_MXX,	op_nop,		store_C		;4E		;LD C,(xx+d)
00174f cdfe                      instr 	fetch_nop,	op_noni,	store_nop	;4F		;
001750 cdfd                      instr 	fetch_nop,	op_noni,	store_nop	;50		;
001751 cdfc                      instr 	fetch_nop,	op_noni,	store_nop	;51		;
001752 cdfb                      instr 	fetch_nop,	op_noni,	store_nop	;52		;
001753 cdfa                      instr 	fetch_nop,	op_noni,	store_nop	;53		;
001754 cf12
001667 def6
001668 c92d                      instr 	fetch_xH,	op_nop,		store_D		;54		;LD D,xh
001755 cf13
001669 def9
00166a c92b                      instr 	fetch_xL,	op_nop,		store_D		;55		;LD D,xl
001756 cf14
00166b defc
00166c c929                      instr 	fetch_MXX,	op_nop,		store_D		;56		;LD D,(xx+d)
001757 cdf6                      instr 	fetch_nop,	op_noni,	store_nop	;57		;
001758 cdf5                      instr 	fetch_nop,	op_noni,	store_nop	;58		;
001759 cdf4                      instr 	fetch_nop,	op_noni,	store_nop	;59		;
00175a cdf3                      instr 	fetch_nop,	op_noni,	store_nop	;5A		;
00175b cdf2                      instr 	fetch_nop,	op_noni,	store_nop	;5B		;
00175c cf10
00166d def0
00166e c929                      instr 	fetch_xH,	op_nop,		store_E		;5C		;LD E,xh
00175d cf11
00166f def3
001670 c927                      instr 	fetch_xL,	op_nop,		store_E		;5D		;LD E,xl
00175e cf12
001671 def6
001672 c925                      instr 	fetch_MXX,	op_nop,		store_E		;5E		;LD E,(xx+d)
00175f cdee                      instr 	fetch_nop,	op_noni,	store_nop	;5F		;
001760 cf12
001673 2d69
001674 cf20                      instr 	fetch_B,	op_nop,		store_xH	;60		;LD xh,B
001761 cf13
001675 2d68
001676 cf1e                      instr 	fetch_C,	op_nop,		store_xH	;61		;LD xh,C
001762 cf14
001677 2d6b
001678 cf1c                      instr 	fetch_D,	op_nop,		store_xH	;62		;LD xh,D
001763 cf15
001679 2d6a
00167a cf1a                      instr 	fetch_E,	op_nop,		store_xH	;63		;LD xh,E
001764 cde9                      instr 	fetch_nop,	op_noni,	store_nop	;64		;LD xh,xh
001765 cf15
00167b dee7
00167c cf18                      instr 	fetch_xL,	op_nop,		store_xH	;65		;LD xh,xl
001766 cf16
00167d deea
00167e c91b                      instr 	fetch_MXX,	op_nop,		store_H		;66		;LD H,(xx+d)
001767 cf17
00167f 2f65
001680 cf14                      instr 	fetch_A,	op_nop,		store_xH	;67		;LD xh,A
001768 cf18
001681 2d69
001682 cf17                      instr 	fetch_B,	op_nop,		store_xL	;68		;LD xl,B
001769 cf19
001683 2d68
001684 cf15                      instr 	fetch_C,	op_nop,		store_xL	;69		;LD xl,C
00176a cf1a
001685 2d6b
001686 cf13                      instr 	fetch_D,	op_nop,		store_xL	;6A		;LD xl,D
00176b cf1b
001687 2d6a
001688 cf11                      instr 	fetch_E,	op_nop,		store_xL	;6B		;LD xl,E
00176c cf1c
001689 ded4
00168a cf0f                      instr 	fetch_xH,	op_nop,		store_xL	;6C		;LD xl,xh
00176d cde0                      instr 	fetch_nop,	op_noni,	store_nop	;6D		;LD xl,xl
00176e cf1c
00168b dedc
00168c c90f                      instr 	fetch_MXX,	op_nop,		store_L		;6E		;LD L,(xx+d)
00176f cf1d
00168d 2f65
00168e cf0b                      instr 	fetch_A,	op_nop,		store_xL	;6F		;LD xl,A
001770 cf1e
00168f 2d69
001690 cf0e                      instr 	fetch_B,	op_nop,		store_MXX	;70		;LD (xx+d),B
001771 cf1f
001691 2d68
001692 cf0c                      instr 	fetch_C,	op_nop,		store_MXX	;71		;LD (xx+d),C
001772 cf20
001693 2d6b
001694 cf0a                      instr 	fetch_D,	op_nop,		store_MXX	;72		;LD (xx+d),D
001773 cf21
001695 2d6a
001696 cf08                      instr 	fetch_E,	op_nop,		store_MXX	;73		;LD (xx+d),E
001774 cf22
001697 2d6d
001698 cf06                      instr 	fetch_H,	op_nop,		store_MXX	;74		;LD (xx+d),H
001775 cf23
001699 2d6c
00169a cf04                      instr 	fetch_L,	op_nop,		store_MXX	;75		;LD (xx+d),L
001776 cdd7                      instr 	fetch_nop,	op_noni,	store_nop	;76		;
001777 cf23
00169b 2f65
00169c cf02                      instr 	fetch_A,	op_nop,		store_MXX	;77		;LD (xx+d),A
001778 cdd5                      instr 	fetch_nop,	op_noni,	store_nop	;78		;
001779 cdd4                      instr 	fetch_nop,	op_noni,	store_nop	;79		;
00177a cdd3                      instr 	fetch_nop,	op_noni,	store_nop	;7A		;
00177b cdd2                      instr 	fetch_nop,	op_noni,	store_nop	;7B		;
00177c cf20
00169d dec0
00169e c8f1                      instr 	fetch_xH,	op_nop,		store_A		;7C		;LD A,xh
00177d cf21
00169f dec3
0016a0 c8ef                      instr 	fetch_xL,	op_nop,		store_A		;7D		;LD A,xl
00177e cf22
0016a1 dec6
0016a2 c8ed                      instr 	fetch_MXX,	op_nop,		store_A		;7E		;LD A,(xx+d)
00177f cdce                      instr 	fetch_nop,	op_noni,	store_nop	;7F		;
001780 cdcd                      instr 	fetch_nop,	op_noni,	store_nop	;80		;
001781 cdcc                      instr 	fetch_nop,	op_noni,	store_nop	;81		;
001782 cdcb                      instr 	fetch_nop,	op_noni,	store_nop	;82		;
001783 cdca                      instr 	fetch_nop,	op_noni,	store_nop	;83		;
001784 cf1e
0016a3 deba
0016a4 c9fb                      instr 	fetch_xH,	op_ADDA,	store_nop	;84		;ADD A,xh
001785 cf1f
0016a5 debd
0016a6 c9f9                      instr 	fetch_xL,	op_ADDA,	store_nop	;85		;ADD A,xl
001786 cf20
0016a7 dec0
0016a8 c9f7                      instr 	fetch_MXX,	op_ADDA,	store_nop	;86		;ADD A,(xx)
001787 cdc6                      instr 	fetch_nop,	op_noni,	store_nop	;87		;
001788 cdc5                      instr 	fetch_nop,	op_noni,	store_nop	;88		;
001789 cdc4                      instr 	fetch_nop,	op_noni,	store_nop	;89		;
00178a cdc3                      instr 	fetch_nop,	op_noni,	store_nop	;8A		;
00178b cdc2                      instr 	fetch_nop,	op_noni,	store_nop	;8B		;
00178c cf1c
0016a9 deb4
0016aa ca01                      instr 	fetch_xH,	op_ADCA,	store_nop	;8C		;ADC A,xh
00178d cf1d
0016ab deb7
0016ac c9ff                      instr 	fetch_xL,	op_ADCA,	store_nop	;8D		;ADC A,xl
00178e cf1e
0016ad deba
0016ae c9fd                      instr 	fetch_MXX,	op_ADCA,	store_nop	;8E		;ADC A,(xx)
00178f cdbe                      instr 	fetch_nop,	op_noni,	store_nop	;8F		;
001790 cdbd                      instr 	fetch_nop,	op_noni,	store_nop	;90		;
001791 cdbc                      instr 	fetch_nop,	op_noni,	store_nop	;91		;
001792 cdbb                      instr 	fetch_nop,	op_noni,	store_nop	;92		;
001793 cdba                      instr 	fetch_nop,	op_noni,	store_nop	;93		;
001794 cf1a
0016af deae
0016b0 ca0a                      instr 	fetch_xH,	op_SUBFA,	store_nop	;94		;SUB A,xh
001795 cf1b
0016b1 deb1
0016b2 ca08                      instr 	fetch_xL,	op_SUBFA,	store_nop	;95		;SUB A,xl
001796 cf1c
0016b3 deb4
0016b4 ca06                      instr 	fetch_MXX,	op_SUBFA,	store_nop	;96		;SUB A,(xx)
001797 cdb6                      instr 	fetch_nop,	op_noni,	store_nop	;97		;
001798 cdb5                      instr 	fetch_nop,	op_noni,	store_nop	;98		;
001799 cdb4                      instr 	fetch_nop,	op_noni,	store_nop	;99		;
00179a cdb3                      instr 	fetch_nop,	op_noni,	store_nop	;9A		;
00179b cdb2                      instr 	fetch_nop,	op_noni,	store_nop	;9B		;
00179c cf18
0016b5 dea8
0016b6 ca1f                      instr 	fetch_xH,	op_SBCFA,	store_nop	;9C		;SBC A,xh
00179d cf19
0016b7 deab
0016b8 ca1d                      instr 	fetch_xL,	op_SBCFA,	store_nop	;9D		;SBC A,xl
00179e cf1a
0016b9 deae
0016ba ca1b                      instr 	fetch_MXX,	op_SBCFA,	store_nop	;9E		;SBC A,(xx)
00179f cdae                      instr 	fetch_nop,	op_noni,	store_nop	;9F		;
0017a0 cdad                      instr 	fetch_nop,	op_noni,	store_nop	;A0		;
0017a1 cdac                      instr 	fetch_nop,	op_noni,	store_nop	;A1		;
0017a2 cdab                      instr 	fetch_nop,	op_noni,	store_nop	;A2		;
0017a3 cdaa                      instr 	fetch_nop,	op_noni,	store_nop	;A3		;
0017a4 cf16
0016bb dea2
0016bc ca29                      instr 	fetch_xH,	op_ANDA,	store_nop	;A4		;AND A,xh
0017a5 cf17
0016bd dea5
0016be ca27                      instr 	fetch_xL,	op_ANDA,	store_nop	;A5		;AND A,xl
0017a6 cf18
0016bf dea8
0016c0 ca25                      instr 	fetch_MXX,	op_ANDA,	store_nop	;A6		;AND A,(xx)
0017a7 cda6                      instr 	fetch_nop,	op_noni,	store_nop	;A7		;
0017a8 cda5                      instr 	fetch_nop,	op_noni,	store_nop	;A8		;
0017a9 cda4                      instr 	fetch_nop,	op_noni,	store_nop	;A9		;
0017aa cda3                      instr 	fetch_nop,	op_noni,	store_nop	;AA		;
0017ab cda2                      instr 	fetch_nop,	op_noni,	store_nop	;AB		;
0017ac cf14
0016c1 de9c
0016c2 ca2e                      instr 	fetch_xH,	op_XORA,	store_nop	;AC		;XOR A,xh
0017ad cf15
0016c3 de9f
0016c4 ca2c                      instr 	fetch_xL,	op_XORA,	store_nop	;AD		;XOR A,xl
0017ae cf16
0016c5 dea2
0016c6 ca2a                      instr 	fetch_MXX,	op_XORA,	store_nop	;AE		;XOR A,(xx)
0017af cd9e                      instr 	fetch_nop,	op_noni,	store_nop	;AF		;
0017b0 cd9d                      instr 	fetch_nop,	op_noni,	store_nop	;B0		;
0017b1 cd9c                      instr 	fetch_nop,	op_noni,	store_nop	;B1		;
0017b2 cd9b                      instr 	fetch_nop,	op_noni,	store_nop	;B2		;
0017b3 cd9a                      instr 	fetch_nop,	op_noni,	store_nop	;B3		;
0017b4 cf12
0016c7 de96
0016c8 ca23                      instr 	fetch_xH,	op_ORA,		store_nop	;B4		;OR A,xh
0017b5 cf13
0016c9 de99
0016ca ca21                      instr 	fetch_xL,	op_ORA,		store_nop	;B5		;OR A,xl
0017b6 cf14
0016cb de9c
0016cc ca1f                      instr 	fetch_MXX,	op_ORA,		store_nop	;B6		;OR A,(xx)
0017b7 cd96                      instr 	fetch_nop,	op_noni,	store_nop	;B7		;
0017b8 cd95                      instr 	fetch_nop,	op_noni,	store_nop	;B8		;
0017b9 cd94                      instr 	fetch_nop,	op_noni,	store_nop	;B9		;
0017ba cd93                      instr 	fetch_nop,	op_noni,	store_nop	;BA		;
0017bb cd92                      instr 	fetch_nop,	op_noni,	store_nop	;BB		;
0017bc cf10
0016cd de90
0016ce c9f9                      instr 	fetch_xH,	op_CPFA,	store_nop	;BC		;CP A,xh
0017bd cf11
0016cf de93
0016d0 c9f7                      instr 	fetch_xL,	op_CPFA,	store_nop	;BD		;CP A,xl
0017be cf12
0016d1 de96
0016d2 c9f5                      instr 	fetch_MXX,	op_CPFA,	store_nop	;BE		;CP A,(xx)
0017bf cd8e                      instr 	fetch_nop,	op_noni,	store_nop	;BF		;
0017c0 cd8d                      instr 	fetch_nop,	op_noni,	store_nop	;C0		;
0017c1 cd8c                      instr 	fetch_nop,	op_noni,	store_nop	;C1		;
0017c2 cd8b                      instr 	fetch_nop,	op_noni,	store_nop	;C2		;
0017c3 cd8a                      instr 	fetch_nop,	op_noni,	store_nop	;C3		;
0017c4 cd89                      instr 	fetch_nop,	op_noni,	store_nop	;C4		;
0017c5 cd88                      instr 	fetch_nop,	op_noni,	store_nop	;C5		;
0017c6 cd87                      instr 	fetch_nop,	op_noni,	store_nop	;C6		;
0017c7 cd86                      instr 	fetch_nop,	op_noni,	store_nop	;C7		;
0017c8 cd85                      instr 	fetch_nop,	op_noni,	store_nop	;C8		;
0017c9 cd84                      instr 	fetch_nop,	op_noni,	store_nop	;C9		;
0017ca cd83                      instr 	fetch_nop,	op_noni,	store_nop	;CA		;
0017cb ca75                      instr 	fetch_nop,	op_prefixDDFDCB,store_nop	;CB		;
0017cc cd81                      instr 	fetch_nop,	op_noni,	store_nop	;CC		;
0017cd cd80                      instr 	fetch_nop,	op_noni,	store_nop	;CD		;
0017ce cd7f                      instr 	fetch_nop,	op_noni,	store_nop	;CE		;
0017cf cd7e                      instr 	fetch_nop,	op_noni,	store_nop	;CF		;
0017d0 cd7d                      instr 	fetch_nop,	op_noni,	store_nop	;D0		;
0017d1 cd7c                      instr 	fetch_nop,	op_noni,	store_nop	;D1		;
0017d2 cd7b                      instr 	fetch_nop,	op_noni,	store_nop	;D2		;
0017d3 cd7a                      instr 	fetch_nop,	op_noni,	store_nop	;D3		;
0017d4 cd79                      instr 	fetch_nop,	op_noni,	store_nop	;D4		;
0017d5 cd78                      instr 	fetch_nop,	op_noni,	store_nop	;D5		;
0017d6 cd77                      instr 	fetch_nop,	op_noni,	store_nop	;D6		;
0017d7 cd76                      instr 	fetch_nop,	op_noni,	store_nop	;D7		;
0017d8 cd75                      instr 	fetch_nop,	op_noni,	store_nop	;D8		;
0017d9 cd74                      instr 	fetch_nop,	op_noni,	store_nop	;D9		;
0017da cd73                      instr 	fetch_nop,	op_noni,	store_nop	;DA		;
0017db cd72                      instr 	fetch_nop,	op_noni,	store_nop	;DB		;
0017dc cd71                      instr 	fetch_nop,	op_noni,	store_nop	;DC		;
0017dd cd70                      instr 	fetch_nop,	op_noni,	store_nop	;DD		;
0017de cd6f                      instr 	fetch_nop,	op_noni,	store_nop	;DE		;
0017df cd6e                      instr 	fetch_nop,	op_noni,	store_nop	;DF		;
0017e0 cd6d                      instr 	fetch_nop,	op_noni,	store_nop	;E0		;
0017e1 cef1
0016d3 dac5
0016d4 cf15                      instr 	fetch_nop,	op_POP16,	store_xx	;E1		;POP xx
0017e2 cd6b                      instr 	fetch_nop,	op_noni,	store_nop	;E2		;
0017e3 cef1
0016d5 d87b
0016d6 df34
0016d7 c8e6                      instr 	fetch_MSP,	op_EXxx,	store_MSP	;E3		;EX (SP),xx
0017e4 cd69                      instr 	fetch_nop,	op_noni,	store_nop	;E4		;
0017e5 cef2
0016d8 deb4
0016d9 caac                      instr 	fetch_xx,	op_PUSH16,	store_nop	;E5		;PUSH xx
0017e6 cd67                      instr 	fetch_nop,	op_noni,	store_nop	;E6		;
0017e7 cd66                      instr 	fetch_nop,	op_noni,	store_nop	;E7		;
0017e8 cd65                      instr 	fetch_nop,	op_noni,	store_nop	;E8		;
0017e9 cef0
0016da deb2
0016db c8f5                      instr 	fetch_xx,	op_nop,		store_PC	;E9		;JP xx
0017ea cd63                      instr 	fetch_nop,	op_noni,	store_nop	;EA		;
0017eb cd62                      instr 	fetch_nop,	op_noni,	store_nop	;EB		;
0017ec cd61                      instr 	fetch_nop,	op_noni,	store_nop	;EC		;
0017ed cd60                      instr 	fetch_nop,	op_noni,	store_nop	;ED		;
0017ee cd5f                      instr 	fetch_nop,	op_noni,	store_nop	;EE		;
0017ef cd5e                      instr 	fetch_nop,	op_noni,	store_nop	;EF		;
0017f0 cd5d                      instr 	fetch_nop,	op_noni,	store_nop	;F0		;
0017f1 cd5c                      instr 	fetch_nop,	op_noni,	store_nop	;F1		;
0017f2 cd5b                      instr 	fetch_nop,	op_noni,	store_nop	;F2		;
0017f3 cd5a                      instr 	fetch_nop,	op_noni,	store_nop	;F3		;
0017f4 cd59                      instr 	fetch_nop,	op_noni,	store_nop	;F4		;
0017f5 cd58                      instr 	fetch_nop,	op_noni,	store_nop	;F5		;
0017f6 cd57                      instr 	fetch_nop,	op_noni,	store_nop	;F6		;
0017f7 cd56                      instr 	fetch_nop,	op_noni,	store_nop	;F7		;
0017f8 cd55                      instr 	fetch_nop,	op_noni,	store_nop	;F8		;
0017f9 cee2
0016dc deb0
0016dd c8f1                      instr 	fetch_xx,	op_nop,		store_SP	;F9		;LD SP,xx
0017fa cd53                      instr 	fetch_nop,	op_noni,	store_nop	;FA		;
0017fb cd52                      instr 	fetch_nop,	op_noni,	store_nop	;FB		;
0017fc cd51                      instr 	fetch_nop,	op_noni,	store_nop	;FC		;
0017fd cd50                      instr 	fetch_nop,	op_noni,	store_nop	;FD		;
0017fe cd4f                      instr 	fetch_nop,	op_noni,	store_nop	;FE		;
0017ff cd4e                      instr 	fetch_nop,	op_noni,	store_nop	;FF		;
                                 
                                 
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|RLC m     |**0P0*|Rotate Left Circular |m=m<-                 |
                                 ;|RRC m     |**0P0*|Rotate Right Circular|m=->m                 |
                                 ;|RL m      |**0P0*|Rotate Left          |m={CY,m}<-            |
                                 ;|RR m      |**0P0*|Rotate Right         |m=->{CY,m}            |
                                 ;|SLA m     |**0P0*|Shift Left Arithmetic|m=m*2                 |
                                 ;|SRA m     |**0P0*|Shift Right Arith.   |m=m/2                 |
                                 ;|SLL m     |**0P0*|Shift Right Logical  |
                                 ;|SRL m     |**0P0*|Shift Right Logical  |m=->{0,m,CY}          |
                                 
                                 
                                 	checkspace PC, 9
                                 
                                 do_op_rlc:
                                 	;Rotate Left Cyclical. All bits move 1 to the 
                                 	;left, the msb becomes c and lsb.
0016de 2700                      	clr	temp
0016df 0f66                      	lsl	opl
0016e0 1d07                      	adc	temp,_0
0016e1 2b60                      	or	opl,temp
0016e2 e4f4
0016e3 2fe6
0016e4 9144                      	ldpmx	z_flags,sz53p_tab,opl		;S,Z,H,P,N	
0016e5 2b40                      	or	z_flags,temp
0016e6 9508                      	ret
                                 
                                 	checkspace PC, 9
                                 
                                 do_op_rrc: 
                                 	;Rotate Right Cyclical. All bits move 1 to the 
                                 	;right, the lsb becomes c and msb.
0016e7 9566                      	lsr	opl
0016e8 f408                      	brcc	PC+2
0016e9 6860                      	ori	opl,0x80
0016ea e4f4
0016eb 2fe6
0016ec 9144                      	ldpmx	z_flags,sz53p_tab,opl		;S,Z,H,P,N	
0016ed fb67
0016ee f940                      	bmov	z_flags,ZFL_C, opl,7
0016ef 9508                      	ret
                                 
                                 
                                 	checkspace PC, 11
                                 
                                 do_op_rl:
                                 	;Rotate Left. All bits move 1 to the left, the msb 
                                 	;becomes c, c becomes lsb.
0016f0 9488                      	clc
0016f1 fd40                      	sbrc	z_flags,ZFL_C
0016f2 9408                      	 sec
0016f3 1f66                      	rol	opl
0016f4 b70f                      	in	temp,sreg
0016f5 e4f4
0016f6 2fe6
0016f7 9144                      	ldpmx	z_flags,sz53p_tab,opl		;S,Z,H,P,N	
0016f8 fb00
0016f9 f940                      	bmov	z_flags,ZFL_C, temp,AVR_C
0016fa 9508                      	ret
                                 
                                 
                                 	checkspace PC, 10
                                 
                                 do_op_rr:
                                 	;Rotate Right. All bits move 1 to the right, the lsb 
                                 	;becomes c, c becomes msb.
                                 
001800 9567                      	ror     opl
001801 b70f                      	in	temp,sreg		;CY
001802 fb40
001803 f967                      	bmov	opl,7, z_flags,ZFL_C		;old CY --> Bit 7
001804 e4f4
001805 2fe6
001806 9144                      	ldpmx	z_flags,sz53p_tab,opl		;S,Z,H,P,N	
001807 fb00
001808 f940                      	bmov	z_flags,ZFL_C, temp,AVR_C	;
001809 9508                      	ret
                                 
                                 	checkspace PC, 9
                                 
                                 do_op_sla:
00180a 0f66                      	lsl	opl
00180b b70f                      	in	temp,sreg
00180c e4f4
00180d 2fe6
00180e 9144                      	ldpmx	z_flags,sz53p_tab,opl		;S,Z,H,P,N	
00180f fb00
001810 f940                      	bmov	z_flags,ZFL_C, temp,AVR_C	;
001811 9508                      	ret
                                 
                                 	checkspace PC, 11
                                 
                                 do_op_sra:
001812 9566                      	lsr	opl
001813 b70f                      	in	temp,sreg
001814 fb66
001815 f967                      	bmov	opl,7, opl,6			;old CY --> Bit 7
001816 e4f4
001817 2fe6
001818 9144                      	ldpmx	z_flags,sz53p_tab,opl		;S,Z,H,P,N	
001819 fb00
00181a f940                      	bmov	z_flags,ZFL_C, temp,AVR_C	;
00181b 9508                      	ret
                                 
                                 	checkspace PC, 9
                                 
                                 do_op_sll:
00181c 9408                      	sec
00181d 1f66                      	rol	opl
00181e b70f                      	in	temp,sreg
00181f e4f4
001820 2fe6
001821 9144                      	ldpmx	z_flags,sz53p_tab,opl		;S,Z,H,P,N	
001822 fb00
001823 f940                      	bmov	z_flags,ZFL_C, temp,AVR_C	;
001824 9508                      	ret
                                 
                                 	checkspace PC, 8
                                 
                                 do_op_srl:
001825 9566                      	lsr	opl
001826 b70f                      	in	temp,sreg
001827 e4f4
001828 2fe6
001829 9144                      	ldpmx	z_flags,sz53p_tab,opl		;S,Z,H,P,N	
00182a fb00
00182b f940                      	bmov	z_flags,ZFL_C, temp,AVR_C	;
00182c 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|BIT b,m   |?*1?0-|Test Bit             |m&{2^b}               |
                                 ;|RES b,m   |------|Reset bit            |m=m&{~2^b}            |
                                 ;|SET b,m   |------|Set bit              |m=mv{2^b}             |
                                 
                                 
                                 	checkspace PC, 2
                                 do_op_BIT7:
00182d e800                      	ldi	temp,0x80
00182e c00d                      	rjmp	opbit
                                 	checkspace PC, 2
                                 do_op_BIT6:
00182f e400                      	ldi	temp,0x40
001830 c00b                      	rjmp	opbit
                                 	checkspace PC, 2
                                 do_op_BIT5:
001831 e200                      	ldi	temp,0x20
001832 c009                      	rjmp	opbit
                                 	checkspace PC, 2
                                 do_op_BIT4:
001833 e100                      	ldi	temp,0x10
001834 c007                      	rjmp	opbit
                                 	checkspace PC, 2
                                 do_op_BIT3:
001835 e008                      	ldi	temp,0x08
001836 c005                      	rjmp	opbit
                                 	checkspace PC, 2
                                 do_op_BIT2:
001837 e004                      	ldi	temp,0x04
001838 c003                      	rjmp	opbit
                                 	checkspace PC, 2
                                 do_op_BIT1:
001839 e002                      	ldi	temp,0x02
00183a c001                      	rjmp	opbit
                                 
                                 	checkspace PC, 7
                                 do_op_BIT0:
00183b e001                      	ldi	temp,0x01
                                 opbit:
00183c 7b4d                      	andi	z_flags,~((1<<ZFL_N)|(1<<ZFL_Z))
00183d 6140                      	ori	z_flags,(1<<ZFL_H)
00183e 2306                      	and	temp,opl
00183f f409                      	brne	opbite
001840 6440                      	ori	z_flags,(1<<ZFL_Z)
                                 opbite:
001841 9508                      	ret
                                 
                                 
                                 .macro m_do_op_RES7
                                 	andi	opl,~0x80
                                 .endm
                                 .equ	do_op_RES7 = 0
                                 ;	andi	opl,~0x80
                                 ;	ret
                                 
                                 .macro m_do_op_RES6
                                 	andi	opl,~0x40
                                 .endm
                                 .equ	do_op_RES6 = 0
                                 ;	andi	opl,~0x40
                                 ;	ret
                                 
                                 .macro m_do_op_RES5
                                 	andi	opl,~0x20
                                 .endm
                                 .equ	do_op_RES5 = 0
                                 ;	andi	opl,~0x20
                                 ;	ret
                                 
                                 .macro m_do_op_RES4
                                 	andi	opl,~0x10
                                 .endm
                                 .equ	do_op_RES4 = 0
                                 ;	andi	opl,~0x10
                                 ;	ret
                                 
                                 .macro m_do_op_RES3
                                 	andi	opl,~0x08
                                 .endm
                                 .equ	do_op_RES3 = 0
                                 ;	andi	opl,~0x08
                                 ;	ret
                                 
                                 .macro m_do_op_RES2
                                 	andi	opl,~0x04
                                 .endm
                                 .equ	do_op_RES2 = 0
                                 ;	andi	opl,~0x04
                                 ;	ret
                                 
                                 .macro m_do_op_RES1
                                 	andi	opl,~0x02
                                 .endm
                                 .equ	do_op_RES1 = 0
                                 ;	andi	opl,~0x02
                                 ;	ret
                                 
                                 .macro m_do_op_RES0
                                 	andi	opl,~0x01
                                 .endm
                                 .equ	do_op_RES0 = 0
                                 ;	andi	opl,~0x01
                                 ;	ret
                                 
                                 .macro m_do_op_SET7
                                 	ori	opl,0x80
                                 .endm
                                 .equ	do_op_SET7 = 0
                                 ;	ori	opl,0x80
                                 ;	ret
                                 
                                 .macro m_do_op_SET6
                                 	ori	opl,0x40
                                 .endm
                                 .equ	do_op_SET6 = 0
                                 ;	ori	opl,0x40
                                 ;	ret
                                 
                                 .macro m_do_op_SET5
                                 	ori	opl,0x20
                                 .endm
                                 .equ	do_op_SET5 = 0
                                 ;	ori	opl,0x20
                                 ;	ret
                                 
                                 .macro m_do_op_SET4
                                 	ori	opl,0x10
                                 .endm
                                 .equ	do_op_SET4 = 0
                                 ;	ori	opl,0x10
                                 ;	ret
                                 
                                 .macro m_do_op_SET3
                                 	ori	opl,0x08
                                 .endm
                                 .equ	do_op_SET3 = 0
                                 ;	ori	opl,0x08
                                 ;	ret
                                 
                                 .macro m_do_op_SET2
                                 	ori	opl,0x04
                                 .endm
                                 .equ	do_op_SET2 = 0
                                 ;	ori	opl,0x04
                                 ;	ret
                                 
                                 .macro m_do_op_SET1
                                 	ori	opl,0x02
                                 .endm
                                 .equ	do_op_SET1 = 0
                                 ;	ori	opl,0x02
                                 ;	ret
                                 
                                 .macro m_do_op_SET0
                                 	ori	opl,0x01
                                 .endm
                                 .equ	do_op_SET0 = 0
                                 ;	ori	opl,0x01
                                 ;	ret
                                 
                                 
                                 ;.macro m_do_store_b 
                                 ;	std	y+oz_b,opl
                                 ;.endm
                                 ;.equ do_store_b = 0
                                 	checkspace PC, 2
                                 do_store2_b:
001842 2e96                      	mov	z_b,opl
001843 9508                      	ret
                                 
                                 	checkspace PC, 2
                                 do_store2_c:
001844 2e86                      	mov	z_c,opl
001845 9508                      	ret
                                 
                                 	checkspace PC, 2
                                 do_store2_d:
001846 2eb6                      	mov	z_d,opl
001847 9508                      	ret
                                 
                                 	checkspace PC, 2
                                 do_store2_e:
001848 2ea6                      	mov	z_e,opl
001849 9508                      	ret
                                 
                                 	checkspace PC, 2
                                 do_store2_h:
00184a 2ed6                      	mov	z_h,opl
00184b 9508                      	ret
                                 
                                 	checkspace PC, 2
                                 do_store2_l:
00184c 2ec6                      	mov	z_l,opl
00184d 9508                      	ret
                                 
                                 	checkspace PC, 2
                                 do_store2_a:
00184e 2f56                      	mov z_a,opl
00184f 9508                      	ret
                                 
                                 	checkspace PC, 4
                                 do_fetch2_mhl:
                                 ;	movw	x,z_l
001850 b8db
001851 b828
001852 b8cb
001853 b838
001854 b87a
001855 b848
001856 c000
001857 0000
001858 b169
001859 b868
00185a b86a                      	mem_read_ds opl, z_hl
00185b 9508                      	ret
                                 
                                 	opctable CBjmp, PC	;+256
                                 
001900 cf5b
00185c 2d69
00185d de80
00185e cfe3                      instr 	fetch_B,	op_RLC,		store2_B	;00		;RLC B
001901 cf5d
00185f 2d68
001860 de7d
001861 cfe2                      instr 	fetch_C,	op_RLC,		store2_C	;01		;RLC C
001902 cf5f
001862 2d6b
001863 de7a
001864 cfe1                      instr 	fetch_D,	op_RLC,		store2_D	;02		;RLC D
001903 cf61
001865 2d6a
001866 de77
001867 cfe0                      instr 	fetch_E,	op_RLC,		store2_E	;03		;RLC E
001904 cf63
001868 2d6d
001869 de74
00186a cfdf                      instr 	fetch_H,	op_RLC,		store2_H	;04		;RLC H
001905 cf65
00186b 2d6c
00186c de71
00186d cfde                      instr 	fetch_L,	op_RLC,		store2_L	;05		;RLC L
001906 cf67
00186e dfe1
00186f de6e
001870 940c 0fb6                 instr 	fetch2_mhl,	op_RLC,		store_MHL	;06		;RLC (HL)
001907 cf6a
001872 2f65
001873 de6a
001874 cfd9                      instr 	fetch_A,	op_RLC,		store2_A	;07		;RLC A
001908 cf6c
001875 2d69
001876 de70
001877 cfca                      instr 	fetch_B,	op_RRC,		store2_B	;08		;RRC B
001909 cf6e
001878 2d68
001879 de6d
00187a cfc9                      instr 	fetch_C,	op_RRC,		store2_C	;09		;RRC C
00190a cf70
00187b 2d6b
00187c de6a
00187d cfc8                      instr 	fetch_D,	op_RRC,		store2_D	;0A		;RRC D
00190b cf72
00187e 2d6a
00187f de67
001880 cfc7                      instr 	fetch_E,	op_RRC,		store2_E	;0B		;RRC E
00190c cf74
001881 2d6d
001882 de64
001883 cfc6                      instr 	fetch_H,	op_RRC,		store2_H	;0C		;RRC H
00190d cf76
001884 2d6c
001885 de61
001886 cfc5                      instr 	fetch_L,	op_RRC,		store2_L	;0D		;RRC L
00190e cf78
001887 dfc8
001888 de5e
001889 940c 0fb6                 instr 	fetch2_mhl,	op_RRC,		store_MHL	;0E		;RRC (HL)
00190f cf7b
00188b 2f65
00188c de5a
00188d cfc0                      instr 	fetch_A,	op_RRC,		store2_A	;0F		;RRC A
001910 cf7d
00188e 2d69
00188f de60
001890 cfb1                      instr 	fetch_B,	op_RL,		store2_B	;10		;RL B
001911 cf7f
001891 2d68
001892 de5d
001893 cfb0                      instr 	fetch_C,	op_RL,		store2_C	;11		;RL C
001912 cf81
001894 2d6b
001895 de5a
001896 cfaf                      instr 	fetch_D,	op_RL,		store2_D	;12		;RL D
001913 cf83
001897 2d6a
001898 de57
001899 cfae                      instr 	fetch_E,	op_RL,		store2_E	;13		;RL E
001914 cf85
00189a 2d6d
00189b de54
00189c cfad                      instr 	fetch_H,	op_RL,		store2_H	;14		;RL H
001915 cf87
00189d 2d6c
00189e de51
00189f cfac                      instr 	fetch_L,	op_RL,		store2_L	;15		;RL L
001916 cf89
0018a0 dfaf
0018a1 de4e
0018a2 940c 0fb6                 instr 	fetch2_mhl,	op_RL,		store_MHL	;16		;RL (HL)
001917 cf8c
0018a4 2f65
0018a5 de4a
0018a6 cfa7                      instr 	fetch_A,	op_RL,		store2_A	;17		;RL A
001918 cf8e
0018a7 2d69
0018a8 df57
0018a9 cf98                      instr 	fetch_B,	op_RR,		store2_B	;18		;RR B
001919 cf90
0018aa 2d68
0018ab df54
0018ac cf97                      instr 	fetch_C,	op_RR,		store2_C	;19		;RR C
00191a cf92
0018ad 2d6b
0018ae df51
0018af cf96                      instr 	fetch_D,	op_RR,		store2_D	;1A		;RR D
00191b cf94
0018b0 2d6a
0018b1 df4e
0018b2 cf95                      instr 	fetch_E,	op_RR,		store2_E	;1B		;RR E
00191c cf96
0018b3 2d6d
0018b4 df4b
0018b5 cf94                      instr 	fetch_H,	op_RR,		store2_H	;1C		;RR H
00191d cf98
0018b6 2d6c
0018b7 df48
0018b8 cf93                      instr 	fetch_L,	op_RR,		store2_L	;1D		;RR L
00191e cf9a
0018b9 df96
0018ba df45
0018bb 940c 0fb6                 instr 	fetch2_mhl,	op_RR,		store_MHL	;1E		;RR (HL)
00191f cf9d
0018bd 2f65
0018be df41
0018bf cf8e                      instr 	fetch_A,	op_RR,		store2_A	;1F		;RR A
001920 cf9f
0018c0 2d69
0018c1 df48
0018c2 cf7f                      instr 	fetch_B,	op_SLA,		store2_B	;20		;SLA B
001921 cfa1
0018c3 2d68
0018c4 df45
0018c5 cf7e                      instr 	fetch_C,	op_SLA,		store2_C	;21		;SLA C
001922 cfa3
0018c6 2d6b
0018c7 df42
0018c8 cf7d                      instr 	fetch_D,	op_SLA,		store2_D	;22		;SLA D
001923 cfa5
0018c9 2d6a
0018ca df3f
0018cb cf7c                      instr 	fetch_E,	op_SLA,		store2_E	;23		;SLA E
001924 cfa7
0018cc 2d6d
0018cd df3c
0018ce cf7b                      instr 	fetch_H,	op_SLA,		store2_H	;24		;SLA H
001925 cfa9
0018cf 2d6c
0018d0 df39
0018d1 cf7a                      instr 	fetch_L,	op_SLA,		store2_L	;25		;SLA L
001926 cfab
0018d2 df7d
0018d3 df36
0018d4 940c 0fb6                 instr 	fetch2_mhl,	op_SLA,		store_MHL	;26		;SLA (HL)
001927 cfae
0018d6 2f65
0018d7 df32
0018d8 cf75                      instr 	fetch_A,	op_SLA,		store2_A	;27		;SLA A
001928 cfb0
0018d9 2d69
0018da df37
0018db cf66                      instr 	fetch_B,	op_SRA,		store2_B	;28		;SRA B
001929 cfb2
0018dc 2d68
0018dd df34
0018de cf65                      instr 	fetch_C,	op_SRA,		store2_C	;29		;SRA C
00192a cfb4
0018df 2d6b
0018e0 df31
0018e1 cf64                      instr 	fetch_D,	op_SRA,		store2_D	;2A		;SRA D
00192b cfb6
0018e2 2d6a
0018e3 df2e
0018e4 cf63                      instr 	fetch_E,	op_SRA,		store2_E	;2B		;SRA E
00192c cfb8
0018e5 2d6d
0018e6 df2b
0018e7 cf62                      instr 	fetch_H,	op_SRA,		store2_H	;2C		;SRA H
00192d cfba
0018e8 2d6c
0018e9 df28
0018ea cf61                      instr 	fetch_L,	op_SRA,		store2_L	;2D		;SRA L
00192e cfbc
0018eb df64
0018ec df25
0018ed 940c 0fb6                 instr 	fetch2_mhl,	op_SRA,		store_MHL	;2E		;SRA (HL)
00192f cfbf
0018ef 2f65
0018f0 df21
0018f1 cf5c                      instr 	fetch_A,	op_SRA,		store2_A	;2F		;SRA A
001930 cfc1
0018f2 2d69
0018f3 df28
0018f4 cf4d                      instr 	fetch_B,	op_SLL,		store2_B	;30		;SLL B
001931 cfc3
0018f5 2d68
0018f6 df25
0018f7 cf4c                      instr 	fetch_C,	op_SLL,		store2_C	;31		;SLL C
001932 cfc5
0018f8 2d6b
0018f9 df22
0018fa cf4b                      instr 	fetch_D,	op_SLL,		store2_D	;32		;SLL D
001933 c0cc
001a00 2d6a
001a01 de1a
001a02 ce45                      instr 	fetch_E,	op_SLL,		store2_E	;33		;SLL E
001934 c0ce
001a03 2d6d
001a04 de17
001a05 ce44                      instr 	fetch_H,	op_SLL,		store2_H	;34		;SLL H
001935 c0d0
001a06 2d6c
001a07 de14
001a08 ce43                      instr 	fetch_L,	op_SLL,		store2_L	;35		;SLL L
001936 c0d2
001a09 de46
001a0a de11
001a0b 940c 0fb6                 instr 	fetch2_mhl,	op_SLL,		store_MHL	;36		;SLL (HL)
001937 c0d5
001a0d 2f65
001a0e de0d
001a0f ce3e                      instr 	fetch_A,	op_SLL,		store2_A	;37		;SLL A
001938 c0d7
001a10 2d69
001a11 de13
001a12 ce2f                      instr 	fetch_B,	op_SRL,		store2_B	;38		;SRL B
001939 c0d9
001a13 2d68
001a14 de10
001a15 ce2e                      instr 	fetch_C,	op_SRL,		store2_C	;39		;SRL C
00193a c0db
001a16 2d6b
001a17 de0d
001a18 ce2d                      instr 	fetch_D,	op_SRL,		store2_D	;3A		;SRL D
00193b c0dd
001a19 2d6a
001a1a de0a
001a1b ce2c                      instr 	fetch_E,	op_SRL,		store2_E	;3B		;SRL E
00193c c0df
001a1c 2d6d
001a1d de07
001a1e ce2b                      instr 	fetch_H,	op_SRL,		store2_H	;3C		;SRL H
00193d c0e1
001a1f 2d6c
001a20 de04
001a21 ce2a                      instr 	fetch_L,	op_SRL,		store2_L	;3D		;SRL L
00193e c0e3
001a22 de2d
001a23 de01
001a24 940c 0fb6                 instr 	fetch2_mhl,	op_SRL,		store_MHL	;3E		;SRL (HL)
00193f c0e6
001a26 2f65
001a27 ddfd
001a28 ce25                      instr 	fetch_A,	op_SRL,		store2_A	;3F		;SRL A
001940 c0e8
001a29 2d69
001a2a ce10                      instr 	fetch_B,	op_BIT0,	store_nop	;40		;BIT 0,B
001941 c0e9
001a2b 2d68
001a2c ce0e                      instr 	fetch_C,	op_BIT0,	store_nop	;41		;BIT 0,C
001942 c0ea
001a2d 2d6b
001a2e ce0c                      instr 	fetch_D,	op_BIT0,	store_nop	;42		;BIT 0,D
001943 c0eb
001a2f 2d6a
001a30 ce0a                      instr 	fetch_E,	op_BIT0,	store_nop	;43		;BIT 0,E
001944 c0ec
001a31 2d6d
001a32 ce08                      instr 	fetch_H,	op_BIT0,	store_nop	;44		;BIT 0,H
001945 c0ed
001a33 2d6c
001a34 ce06                      instr 	fetch_L,	op_BIT0,	store_nop	;45		;BIT 0,L
001946 c0ee
001a35 de1a
001a36 ce04                      instr 	fetch2_mhl,	op_BIT0,	store_nop	;46		;BIT 0,(HL)
001947 c0ef
001a37 2f65
001a38 ce02                      instr 	fetch_A,	op_BIT0,	store_nop	;47		;BIT 0,A   
001948 c0f0
001a39 2d69
001a3a cdfe                      instr 	fetch_B,	op_BIT1,	store_nop	;48		;BIT 1,B
001949 c0f1
001a3b 2d68
001a3c cdfc                      instr 	fetch_C,	op_BIT1,	store_nop	;49		;BIT 1,C
00194a c0f2
001a3d 2d6b
001a3e cdfa                      instr 	fetch_D,	op_BIT1,	store_nop	;4A		;BIT 1,D
00194b c0f3
001a3f 2d6a
001a40 cdf8                      instr 	fetch_E,	op_BIT1,	store_nop	;4B		;BIT 1,E
00194c c0f4
001a41 2d6d
001a42 cdf6                      instr 	fetch_H,	op_BIT1,	store_nop	;4C		;BIT 1,H
00194d c0f5
001a43 2d6c
001a44 cdf4                      instr 	fetch_L,	op_BIT1,	store_nop	;4D		;BIT 1,L
00194e c0f6
001a45 de0a
001a46 cdf2                      instr 	fetch2_mhl,	op_BIT1,	store_nop	;4E		;BIT 1,(HL)
00194f c0f7
001a47 2f65
001a48 cdf0                      instr 	fetch_A,	op_BIT1,	store_nop	;4F		;BIT 1,A
001950 c0f8
001a49 2d69
001a4a cdec                      instr 	fetch_B,	op_BIT2,	store_nop	;50		;BIT 2,B
001951 c0f9
001a4b 2d68
001a4c cdea                      instr 	fetch_C,	op_BIT2,	store_nop	;51		;BIT 2,C
001952 c0fa
001a4d 2d6b
001a4e cde8                      instr 	fetch_D,	op_BIT2,	store_nop	;52		;BIT 2,D
001953 c0fb
001a4f 2d6a
001a50 cde6                      instr 	fetch_E,	op_BIT2,	store_nop	;53		;BIT 2,E
001954 c0fc
001a51 2d6d
001a52 cde4                      instr 	fetch_H,	op_BIT2,	store_nop	;54		;BIT 2,H
001955 c0fd
001a53 2d6c
001a54 cde2                      instr 	fetch_L,	op_BIT2,	store_nop	;55		;BIT 2,L
001956 c0fe
001a55 ddfa
001a56 cde0                      instr 	fetch2_mhl,	op_BIT2,	store_nop	;56		;BIT 2,(HL)
001957 c0ff
001a57 2f65
001a58 cdde                      instr 	fetch_A,	op_BIT2,	store_nop	;57		;BIT 2,A
001958 c100
001a59 2d69
001a5a cdda                      instr 	fetch_B,	op_BIT3,	store_nop	;58		;BIT 3,B
001959 c101
001a5b 2d68
001a5c cdd8                      instr 	fetch_C,	op_BIT3,	store_nop	;59		;BIT 3,C
00195a c102
001a5d 2d6b
001a5e cdd6                      instr 	fetch_D,	op_BIT3,	store_nop	;5A		;BIT 3,D
00195b c103
001a5f 2d6a
001a60 cdd4                      instr 	fetch_E,	op_BIT3,	store_nop	;5B		;BIT 3,E
00195c c104
001a61 2d6d
001a62 cdd2                      instr 	fetch_H,	op_BIT3,	store_nop	;5C		;BIT 3,H
00195d c105
001a63 2d6c
001a64 cdd0                      instr 	fetch_L,	op_BIT3,	store_nop	;5D		;BIT 3,L
00195e c106
001a65 ddea
001a66 cdce                      instr 	fetch2_mhl,	op_BIT3,	store_nop	;5E		;BIT 3,(HL)
00195f c107
001a67 2f65
001a68 cdcc                      instr 	fetch_A,	op_BIT3,	store_nop	;5F		;BIT 3,A
001960 c108
001a69 2d69
001a6a cdc8                      instr 	fetch_B,	op_BIT4,	store_nop	;60		;BIT 4,B
001961 c109
001a6b 2d68
001a6c cdc6                      instr 	fetch_C,	op_BIT4,	store_nop	;61		;BIT 4,C
001962 c10a
001a6d 2d6b
001a6e cdc4                      instr 	fetch_D,	op_BIT4,	store_nop	;62		;BIT 4,D
001963 c10b
001a6f 2d6a
001a70 cdc2                      instr 	fetch_E,	op_BIT4,	store_nop	;63		;BIT 4,E
001964 c10c
001a71 2d6d
001a72 cdc0                      instr 	fetch_H,	op_BIT4,	store_nop	;64		;BIT 4,H
001965 c10d
001a73 2d6c
001a74 cdbe                      instr 	fetch_L,	op_BIT4,	store_nop	;65		;BIT 4,L
001966 c10e
001a75 ddda
001a76 cdbc                      instr 	fetch2_mhl,	op_BIT4,	store_nop	;66		;BIT 4,(HL)
001967 c10f
001a77 2f65
001a78 cdba                      instr 	fetch_A,	op_BIT4,	store_nop	;67		;BIT 4,A
001968 c110
001a79 2d69
001a7a cdb6                      instr 	fetch_B,	op_BIT5,	store_nop	;68		;BIT 5,B
001969 c111
001a7b 2d68
001a7c cdb4                      instr 	fetch_C,	op_BIT5,	store_nop	;69		;BIT 5,C
00196a c112
001a7d 2d6b
001a7e cdb2                      instr 	fetch_D,	op_BIT5,	store_nop	;6A		;BIT 5,D
00196b c113
001a7f 2d6a
001a80 cdb0                      instr 	fetch_E,	op_BIT5,	store_nop	;6B		;BIT 5,E
00196c c114
001a81 2d6d
001a82 cdae                      instr 	fetch_H,	op_BIT5,	store_nop	;6C		;BIT 5,H
00196d c115
001a83 2d6c
001a84 cdac                      instr 	fetch_L,	op_BIT5,	store_nop	;6D		;BIT 5,L
00196e c116
001a85 ddca
001a86 cdaa                      instr 	fetch2_mhl,	op_BIT5,	store_nop	;6E		;BIT 5,(HL)
00196f c117
001a87 2f65
001a88 cda8                      instr 	fetch_A,	op_BIT5,	store_nop	;6F		;BIT 5,A
001970 c118
001a89 2d69
001a8a cda4                      instr 	fetch_B,	op_BIT6,	store_nop	;70		;BIT 6,B
001971 c119
001a8b 2d68
001a8c cda2                      instr 	fetch_C,	op_BIT6,	store_nop	;71		;BIT 6,C
001972 c11a
001a8d 2d6b
001a8e cda0                      instr 	fetch_D,	op_BIT6,	store_nop	;72		;BIT 6,D
001973 c11b
001a8f 2d6a
001a90 cd9e                      instr 	fetch_E,	op_BIT6,	store_nop	;73		;BIT 6,E
001974 c11c
001a91 2d6d
001a92 cd9c                      instr 	fetch_H,	op_BIT6,	store_nop	;74		;BIT 6,H
001975 c11d
001a93 2d6c
001a94 cd9a                      instr 	fetch_L,	op_BIT6,	store_nop	;75		;BIT 6,L
001976 c11e
001a95 ddba
001a96 cd98                      instr 	fetch2_mhl,	op_BIT6,	store_nop	;76		;BIT 6,(HL)
001977 c11f
001a97 2f65
001a98 cd96                      instr 	fetch_A,	op_BIT6,	store_nop	;77		;BIT 6,A
001978 c120
001a99 2d69
001a9a cd92                      instr 	fetch_B,	op_BIT7,	store_nop	;78		;BIT 7,B
001979 c121
001a9b 2d68
001a9c cd90                      instr 	fetch_C,	op_BIT7,	store_nop	;79		;BIT 7,C
00197a c122
001a9d 2d6b
001a9e cd8e                      instr 	fetch_D,	op_BIT7,	store_nop	;7A		;BIT 7,D
00197b c123
001a9f 2d6a
001aa0 cd8c                      instr 	fetch_E,	op_BIT7,	store_nop	;7B		;BIT 7,E
00197c c124
001aa1 2d6d
001aa2 cd8a                      instr 	fetch_H,	op_BIT7,	store_nop	;7C		;BIT 7,H
00197d c125
001aa3 2d6c
001aa4 cd88                      instr 	fetch_L,	op_BIT7,	store_nop	;7D		;BIT 7,L
00197e c126
001aa5 ddaa
001aa6 cd86                      instr 	fetch2_mhl,	op_BIT7,	store_nop	;7E		;BIT 7,(HL)
00197f c127
001aa7 2f65
001aa8 cd84                      instr 	fetch_A,	op_BIT7,	store_nop	;7F		;BIT 7,A
001980 c128
001aa9 2d69
001aaa 7f6e
001aab cd96                      instr 	fetch_B,	op_RES0,	store2_B	;80		;RES 0,B
001981 c12a
001aac 2d68
001aad 7f6e
001aae cd95                      instr 	fetch_C,	op_RES0,	store2_C	;81		;RES 0,C
001982 c12c
001aaf 2d6b
001ab0 7f6e
001ab1 cd94                      instr 	fetch_D,	op_RES0,	store2_D	;82		;RES 0,D
001983 c12e
001ab2 2d6a
001ab3 7f6e
001ab4 cd93                      instr 	fetch_E,	op_RES0,	store2_E	;83		;RES 0,E
001984 c130
001ab5 2d6d
001ab6 7f6e
001ab7 cd92                      instr 	fetch_H,	op_RES0,	store2_H	;84		;RES 0,H
001985 c132
001ab8 2d6c
001ab9 7f6e
001aba cd91                      instr 	fetch_L,	op_RES0,	store2_L	;85		;RES 0,L
001986 c134
001abb dd94
001abc 7f6e
001abd 940c 0fb6                 instr 	fetch2_mhl,	op_RES0,	store_MHL	;86		;RES 0,(HL)
001987 c137
001abf 2f65
001ac0 7f6e
001ac1 cd8c                      instr 	fetch_A,	op_RES0,	store2_A	;87		;RES 0,A
001988 c139
001ac2 2d69
001ac3 7f6d
001ac4 cd7d                      instr 	fetch_B,	op_RES1,	store2_B	;88		;RES 1,B
001989 c13b
001ac5 2d68
001ac6 7f6d
001ac7 cd7c                      instr 	fetch_C,	op_RES1,	store2_C	;89		;RES 1,C
00198a c13d
001ac8 2d6b
001ac9 7f6d
001aca cd7b                      instr 	fetch_D,	op_RES1,	store2_D	;8A		;RES 1,D
00198b c13f
001acb 2d6a
001acc 7f6d
001acd cd7a                      instr 	fetch_E,	op_RES1,	store2_E	;8B		;RES 1,E
00198c c141
001ace 2d6d
001acf 7f6d
001ad0 cd79                      instr 	fetch_H,	op_RES1,	store2_H	;8C		;RES 1,H
00198d c143
001ad1 2d6c
001ad2 7f6d
001ad3 cd78                      instr 	fetch_L,	op_RES1,	store2_L	;8D		;RES 1,L
00198e c145
001ad4 dd7b
001ad5 7f6d
001ad6 940c 0fb6                 instr 	fetch2_mhl,	op_RES1,	store_MHL	;8E		;RES 1,(HL)
00198f c148
001ad8 2f65
001ad9 7f6d
001ada cd73                      instr 	fetch_A,	op_RES1,	store2_A	;8F		;RES 1,A
001990 c14a
001adb 2d69
001adc 7f6b
001add cd64                      instr 	fetch_B,	op_RES2,	store2_B	;90		;RES 2,B
001991 c14c
001ade 2d68
001adf 7f6b
001ae0 cd63                      instr 	fetch_C,	op_RES2,	store2_C	;91		;RES 2,C
001992 c14e
001ae1 2d6b
001ae2 7f6b
001ae3 cd62                      instr 	fetch_D,	op_RES2,	store2_D	;92		;RES 2,D
001993 c150
001ae4 2d6a
001ae5 7f6b
001ae6 cd61                      instr 	fetch_E,	op_RES2,	store2_E	;93		;RES 2,E
001994 c152
001ae7 2d6d
001ae8 7f6b
001ae9 cd60                      instr 	fetch_H,	op_RES2,	store2_H	;94		;RES 2,H
001995 c154
001aea 2d6c
001aeb 7f6b
001aec cd5f                      instr 	fetch_L,	op_RES2,	store2_L	;95		;RES 2,L
001996 c156
001aed dd62
001aee 7f6b
001aef 940c 0fb6                 instr 	fetch2_mhl,	op_RES2,	store_MHL	;96		;RES 2,(HL)
001997 c159
001af1 2f65
001af2 7f6b
001af3 cd5a                      instr 	fetch_A,	op_RES2,	store2_A	;97		;RES 2,A
001998 c15b
001af4 2d69
001af5 7f67
001af6 cd4b                      instr 	fetch_B,	op_RES3,	store2_B	;98		;RES 3,B
001999 c15d
001af7 2d68
001af8 7f67
001af9 cd4a                      instr 	fetch_C,	op_RES3,	store2_C	;99		;RES 3,C
00199a c15f
001afa 2d6b
001afb 7f67
001afc cd49                      instr 	fetch_D,	op_RES3,	store2_D	;9A		;RES 3,D
00199b c161
001afd 2d6a
001afe 7f67
001aff cd48                      instr 	fetch_E,	op_RES3,	store2_E	;9B		;RES 3,E
00199c c163
001b00 2d6d
001b01 7f67
001b02 cd47                      instr 	fetch_H,	op_RES3,	store2_H	;9C		;RES 3,H
00199d c165
001b03 2d6c
001b04 7f67
001b05 cd46                      instr 	fetch_L,	op_RES3,	store2_L	;9D		;RES 3,L
00199e c167
001b06 dd49
001b07 7f67
001b08 940c 0fb6                 instr 	fetch2_mhl,	op_RES3,	store_MHL	;9E		;RES 3,(HL)
00199f c16a
001b0a 2f65
001b0b 7f67
001b0c cd41                      instr 	fetch_A,	op_RES3,	store2_A	;9F		;RES 3,A
0019a0 c16c
001b0d 2d69
001b0e 7e6f
001b0f cd32                      instr 	fetch_B,	op_RES4,	store2_B	;A0		;RES 4,B
0019a1 c16e
001b10 2d68
001b11 7e6f
001b12 cd31                      instr 	fetch_C,	op_RES4,	store2_C	;A1		;RES 4,C
0019a2 c170
001b13 2d6b
001b14 7e6f
001b15 cd30                      instr 	fetch_D,	op_RES4,	store2_D	;A2		;RES 4,D
0019a3 c172
001b16 2d6a
001b17 7e6f
001b18 cd2f                      instr 	fetch_E,	op_RES4,	store2_E	;A3		;RES 4,E
0019a4 c174
001b19 2d6d
001b1a 7e6f
001b1b cd2e                      instr 	fetch_H,	op_RES4,	store2_H	;A4		;RES 4,H
0019a5 c176
001b1c 2d6c
001b1d 7e6f
001b1e cd2d                      instr 	fetch_L,	op_RES4,	store2_L	;A5		;RES 4,L
0019a6 c178
001b1f dd30
001b20 7e6f
001b21 940c 0fb6                 instr 	fetch2_mhl,	op_RES4,	store_MHL	;A6		;RES 4,(HL)
0019a7 c17b
001b23 2f65
001b24 7e6f
001b25 cd28                      instr 	fetch_A,	op_RES4,	store2_A	;A7		;RES 4,A
0019a8 c17d
001b26 2d69
001b27 7d6f
001b28 cd19                      instr 	fetch_B,	op_RES5,	store2_B	;A8		;RES 5,B
0019a9 c17f
001b29 2d68
001b2a 7d6f
001b2b cd18                      instr 	fetch_C,	op_RES5,	store2_C	;A9		;RES 5,C
0019aa c181
001b2c 2d6b
001b2d 7d6f
001b2e cd17                      instr 	fetch_D,	op_RES5,	store2_D	;AA		;RES 5,D
0019ab c183
001b2f 2d6a
001b30 7d6f
001b31 cd16                      instr 	fetch_E,	op_RES5,	store2_E	;AB		;RES 5,E
0019ac c185
001b32 2d6d
001b33 7d6f
001b34 cd15                      instr 	fetch_H,	op_RES5,	store2_H	;AC		;RES 5,H
0019ad c187
001b35 2d6c
001b36 7d6f
001b37 cd14                      instr 	fetch_L,	op_RES5,	store2_L	;AD		;RES 5,L
0019ae c189
001b38 dd17
001b39 7d6f
001b3a 940c 0fb6                 instr 	fetch2_mhl,	op_RES5,	store_MHL	;AE		;RES 5,(HL)
0019af c18c
001b3c 2f65
001b3d 7d6f
001b3e cd0f                      instr 	fetch_A,	op_RES5,	store2_A	;AF		;RES 5,A
0019b0 c18e
001b3f 2d69
001b40 7b6f
001b41 cd00                      instr 	fetch_B,	op_RES6,	store2_B	;B0		;RES 6,B
0019b1 c190
001b42 2d68
001b43 7b6f
001b44 ccff                      instr 	fetch_C,	op_RES6,	store2_C	;B1		;RES 6,C
0019b2 c192
001b45 2d6b
001b46 7b6f
001b47 ccfe                      instr 	fetch_D,	op_RES6,	store2_D	;B2		;RES 6,D
0019b3 c194
001b48 2d6a
001b49 7b6f
001b4a ccfd                      instr 	fetch_E,	op_RES6,	store2_E	;B3		;RES 6,E
0019b4 c196
001b4b 2d6d
001b4c 7b6f
001b4d ccfc                      instr 	fetch_H,	op_RES6,	store2_H	;B4		;RES 6,H
0019b5 c198
001b4e 2d6c
001b4f 7b6f
001b50 ccfb                      instr 	fetch_L,	op_RES6,	store2_L	;B5		;RES 6,L
0019b6 c19a
001b51 dcfe
001b52 7b6f
001b53 940c 0fb6                 instr 	fetch2_mhl,	op_RES6,	store_MHL	;B6		;RES 6,(HL)
0019b7 c19d
001b55 2f65
001b56 7b6f
001b57 ccf6                      instr 	fetch_A,	op_RES6,	store2_A	;B7		;RES 6,A
0019b8 c19f
001b58 2d69
001b59 776f
001b5a cce7                      instr 	fetch_B,	op_RES7,	store2_B	;B8		;RES 7,B
0019b9 c1a1
001b5b 2d68
001b5c 776f
001b5d cce6                      instr 	fetch_C,	op_RES7,	store2_C	;B9		;RES 7,C
0019ba c1a3
001b5e 2d6b
001b5f 776f
001b60 cce5                      instr 	fetch_D,	op_RES7,	store2_D	;BA		;RES 7,D
0019bb c1a5
001b61 2d6a
001b62 776f
001b63 cce4                      instr 	fetch_E,	op_RES7,	store2_E	;BB		;RES 7,E
0019bc c1a7
001b64 2d6d
001b65 776f
001b66 cce3                      instr 	fetch_H,	op_RES7,	store2_H	;BC		;RES 7,H
0019bd c1a9
001b67 2d6c
001b68 776f
001b69 cce2                      instr 	fetch_L,	op_RES7,	store2_L	;BD		;RES 7,L
0019be c1ab
001b6a dce5
001b6b 776f
001b6c 940c 0fb6                 instr 	fetch2_mhl,	op_RES7,	store_MHL	;BE		;RES 7,(HL)
0019bf c1ae
001b6e 2f65
001b6f 776f
001b70 ccdd                      instr 	fetch_A,	op_RES7,	store2_A	;BF		;RES 7,A
0019c0 c1b0
001b71 2d69
001b72 6061
001b73 ccce                      instr 	fetch_B,	op_SET0,	store2_B	;C0		;SET 0,B
0019c1 c1b2
001b74 2d68
001b75 6061
001b76 cccd                      instr 	fetch_C,	op_SET0,	store2_C	;C1		;SET 0,C
0019c2 c1b4
001b77 2d6b
001b78 6061
001b79 cccc                      instr 	fetch_D,	op_SET0,	store2_D	;C2		;SET 0,D
0019c3 c1b6
001b7a 2d6a
001b7b 6061
001b7c cccb                      instr 	fetch_E,	op_SET0,	store2_E	;C3		;SET 0,E
0019c4 c1b8
001b7d 2d6d
001b7e 6061
001b7f ccca                      instr 	fetch_H,	op_SET0,	store2_H	;C4		;SET 0,H
0019c5 c1ba
001b80 2d6c
001b81 6061
001b82 ccc9                      instr 	fetch_L,	op_SET0,	store2_L	;C5		;SET 0,L
0019c6 c1bc
001b83 dccc
001b84 6061
001b85 940c 0fb6                 instr 	fetch2_mhl,	op_SET0,	store_MHL	;C6		;SET 0,(HL)
0019c7 c1bf
001b87 2f65
001b88 6061
001b89 ccc4                      instr 	fetch_A,	op_SET0,	store2_A	;C7		;SET 0,A
0019c8 c1c1
001b8a 2d69
001b8b 6062
001b8c ccb5                      instr 	fetch_B,	op_SET1,	store2_B	;C8		;SET 1,B
0019c9 c1c3
001b8d 2d68
001b8e 6062
001b8f ccb4                      instr 	fetch_C,	op_SET1,	store2_C	;C9		;SET 1,C
0019ca c1c5
001b90 2d6b
001b91 6062
001b92 ccb3                      instr 	fetch_D,	op_SET1,	store2_D	;CA		;SET 1,D
0019cb c1c7
001b93 2d6a
001b94 6062
001b95 ccb2                      instr 	fetch_E,	op_SET1,	store2_E	;CB		;SET 1,E
0019cc c1c9
001b96 2d6d
001b97 6062
001b98 ccb1                      instr 	fetch_H,	op_SET1,	store2_H	;CC		;SET 1,H
0019cd c1cb
001b99 2d6c
001b9a 6062
001b9b ccb0                      instr 	fetch_L,	op_SET1,	store2_L	;CD		;SET 1,L
0019ce c1cd
001b9c dcb3
001b9d 6062
001b9e 940c 0fb6                 instr 	fetch2_mhl,	op_SET1,	store_MHL	;CE		;SET 1,(HL)
0019cf c1d0
001ba0 2f65
001ba1 6062
001ba2 ccab                      instr 	fetch_A,	op_SET1,	store2_A	;CF		;SET 1,A
0019d0 c1d2
001ba3 2d69
001ba4 6064
001ba5 cc9c                      instr 	fetch_B,	op_SET2,	store2_B	;D0		;SET 2,B
0019d1 c1d4
001ba6 2d68
001ba7 6064
001ba8 cc9b                      instr 	fetch_C,	op_SET2,	store2_C	;D1		;SET 2,C
0019d2 c1d6
001ba9 2d6b
001baa 6064
001bab cc9a                      instr 	fetch_D,	op_SET2,	store2_D	;D2		;SET 2,D
0019d3 c1d8
001bac 2d6a
001bad 6064
001bae cc99                      instr 	fetch_E,	op_SET2,	store2_E	;D3		;SET 2,E
0019d4 c1da
001baf 2d6d
001bb0 6064
001bb1 cc98                      instr 	fetch_H,	op_SET2,	store2_H	;D4		;SET 2,H
0019d5 c1dc
001bb2 2d6c
001bb3 6064
001bb4 cc97                      instr 	fetch_L,	op_SET2,	store2_L	;D5		;SET 2,L
0019d6 c1de
001bb5 dc9a
001bb6 6064
001bb7 940c 0fb6                 instr 	fetch2_mhl,	op_SET2,	store_MHL	;D6		;SET 2,(HL)
0019d7 c1e1
001bb9 2f65
001bba 6064
001bbb cc92                      instr 	fetch_A,	op_SET2,	store2_A	;D7		;SET 2,A
0019d8 c1e3
001bbc 2d69
001bbd 6068
001bbe cc83                      instr 	fetch_B,	op_SET3,	store2_B	;D8		;SET 3,B
0019d9 c1e5
001bbf 2d68
001bc0 6068
001bc1 cc82                      instr 	fetch_C,	op_SET3,	store2_C	;D9		;SET 3,C
0019da c1e7
001bc2 2d6b
001bc3 6068
001bc4 cc81                      instr 	fetch_D,	op_SET3,	store2_D	;DA		;SET 3,D
0019db c1e9
001bc5 2d6a
001bc6 6068
001bc7 cc80                      instr 	fetch_E,	op_SET3,	store2_E	;DB		;SET 3,E
0019dc c1eb
001bc8 2d6d
001bc9 6068
001bca cc7f                      instr 	fetch_H,	op_SET3,	store2_H	;DC		;SET 3,H
0019dd c1ed
001bcb 2d6c
001bcc 6068
001bcd cc7e                      instr 	fetch_L,	op_SET3,	store2_L	;DD		;SET 3,L
0019de c1ef
001bce dc81
001bcf 6068
001bd0 940c 0fb6                 instr 	fetch2_mhl,	op_SET3,	store_MHL	;DE		;SET 3,(HL)
0019df c1f2
001bd2 2f65
001bd3 6068
001bd4 cc79                      instr 	fetch_A,	op_SET3,	store2_A	;DF		;SET 3,A
0019e0 c1f4
001bd5 2d69
001bd6 6160
001bd7 cc6a                      instr 	fetch_B,	op_SET4,	store2_B	;E0		;SET 4,B
0019e1 c1f6
001bd8 2d68
001bd9 6160
001bda cc69                      instr 	fetch_C,	op_SET4,	store2_C	;E1		;SET 4,C
0019e2 c1f8
001bdb 2d6b
001bdc 6160
001bdd cc68                      instr 	fetch_D,	op_SET4,	store2_D	;E2		;SET 4,D
0019e3 c1fa
001bde 2d6a
001bdf 6160
001be0 cc67                      instr 	fetch_E,	op_SET4,	store2_E	;E3		;SET 4,E
0019e4 c1fc
001be1 2d6d
001be2 6160
001be3 cc66                      instr 	fetch_H,	op_SET4,	store2_H	;E4		;SET 4,H
0019e5 c1fe
001be4 2d6c
001be5 6160
001be6 cc65                      instr 	fetch_L,	op_SET4,	store2_L	;E5		;SET 4,L
0019e6 c200
001be7 dc68
001be8 6160
001be9 940c 0fb6                 instr 	fetch2_mhl,	op_SET4,	store_MHL	;E6		;SET 4,(HL)
0019e7 c203
001beb 2f65
001bec 6160
001bed cc60                      instr 	fetch_A,	op_SET4,	store2_A	;E7		;SET 4,A
0019e8 c205
001bee 2d69
001bef 6260
001bf0 cc51                      instr 	fetch_B,	op_SET5,	store2_B	;E8		;SET 5,B
0019e9 c207
001bf1 2d68
001bf2 6260
001bf3 cc50                      instr 	fetch_C,	op_SET5,	store2_C	;E9		;SET 5,C
0019ea c209
001bf4 2d6b
001bf5 6260
001bf6 cc4f                      instr 	fetch_D,	op_SET5,	store2_D	;EA		;SET 5,D
0019eb c20b
001bf7 2d6a
001bf8 6260
001bf9 cc4e                      instr 	fetch_E,	op_SET5,	store2_E	;EB		;SET 5,E
0019ec c20d
001bfa 2d6d
001bfb 6260
001bfc cc4d                      instr 	fetch_H,	op_SET5,	store2_H	;EC		;SET 5,H
0019ed c20f
001bfd 2d6c
001bfe 6260
001bff cc4c                      instr 	fetch_L,	op_SET5,	store2_L	;ED		;SET 5,L
0019ee c211
001c00 dc4f
001c01 6260
001c02 940c 0fb6                 instr 	fetch2_mhl,	op_SET5,	store_MHL	;EE		;SET 5,(HL)
0019ef c214
001c04 2f65
001c05 6260
001c06 cc47                      instr 	fetch_A,	op_SET5,	store2_A	;EF		;SET 5,A
0019f0 c216
001c07 2d69
001c08 6460
001c09 cc38                      instr 	fetch_B,	op_SET6,	store2_B	;F0		;SET 6,B
0019f1 c218
001c0a 2d68
001c0b 6460
001c0c cc37                      instr 	fetch_C,	op_SET6,	store2_C	;F1		;SET 6,C
0019f2 c21a
001c0d 2d6b
001c0e 6460
001c0f cc36                      instr 	fetch_D,	op_SET6,	store2_D	;F2		;SET 6,D
0019f3 c21c
001c10 2d6a
001c11 6460
001c12 cc35                      instr 	fetch_E,	op_SET6,	store2_E	;F3		;SET 6,E
0019f4 c21e
001c13 2d6d
001c14 6460
001c15 cc34                      instr 	fetch_H,	op_SET6,	store2_H	;F4		;SET 6,H
0019f5 c220
001c16 2d6c
001c17 6460
001c18 cc33                      instr 	fetch_L,	op_SET6,	store2_L	;F5		;SET 6,L
0019f6 c222
001c19 dc36
001c1a 6460
001c1b 940c 0fb6                 instr 	fetch2_mhl,	op_SET6,	store_MHL	;F6		;SET 6,(HL)
0019f7 c225
001c1d 2f65
001c1e 6460
001c1f cc2e                      instr 	fetch_A,	op_SET6,	store2_A	;F7		;SET 6,A
0019f8 c227
001c20 2d69
001c21 6860
001c22 cc1f                      instr 	fetch_B,	op_SET7,	store2_B	;F8		;SET 7,B
0019f9 c229
001c23 2d68
001c24 6860
001c25 cc1e                      instr 	fetch_C,	op_SET7,	store2_C	;F9		;SET 7,C
0019fa c22b
001c26 2d6b
001c27 6860
001c28 cc1d                      instr 	fetch_D,	op_SET7,	store2_D	;FA		;SET 7,D
0019fb c22d
001c29 2d6a
001c2a 6860
001c2b cc1c                      instr 	fetch_E,	op_SET7,	store2_E	;FB		;SET 7,E
0019fc c22f
001c2c 2d6d
001c2d 6860
001c2e cc1b                      instr 	fetch_H,	op_SET7,	store2_H	;FC		;SET 7,H
0019fd c231
001c2f 2d6c
001c30 6860
001c31 cc1a                      instr 	fetch_L,	op_SET7,	store2_L	;FD		;SET 7,L
0019fe c233
001c32 dc1d
001c33 6860
001c34 940c 0fb6                 instr 	fetch2_mhl,	op_SET7,	store_MHL	;FE		;SET 7,(HL)
0019ff c236
001c36 2f65
001c37 6860
001c38 cc15                      instr 	fetch_A,	op_SET7,	store2_A	;FF		;SET 7,A
                                 
                                 
                                 	opctable DDFDCBjmp, PC ;+256
                                 
001d00 cf38
001c39 daa4
001c3a cc07                      instr 	fetch_nop,	op_RLC,		store2_B	;00		;RLC (Ix+d),B
001d01 cf39
001c3b daa2
001c3c cc07                      instr 	fetch_nop,	op_RLC,		store2_C	;01		;RLC (Ix+d),C
001d02 cf3a
001c3d daa0
001c3e cc07                      instr 	fetch_nop,	op_RLC,		store2_D	;02		;RLC (Ix+d),D
001d03 cf3b
001c3f da9e
001c40 cc07                      instr 	fetch_nop,	op_RLC,		store2_E	;03		;RLC (Ix+d),E
001d04 cf3c
001c41 da9c
001c42 cc07                      instr 	fetch_nop,	op_RLC,		store2_H	;04		;RLC (Ix+d),H
001d05 cf3d
001c43 da9a
001c44 cc07                      instr 	fetch_nop,	op_RLC,		store2_L	;05		;RLC (Ix+d),L
001d06 c9d7                      instr 	fetch_nop,	op_RLC,		store_nop	;06		;RLC (Ix+d)  
001d07 cf3d
001c45 da98
001c46 cc07                      instr 	fetch_nop,	op_RLC,		store2_A	;07		;RLC (Ix+d),A
001d08 cf3e
001c47 da9f
001c48 cbf9                      instr 	fetch_nop,	op_RRC,		store2_B	;08		;RRC (Ix+d),B
001d09 cf3f
001c49 da9d
001c4a cbf9                      instr 	fetch_nop,	op_RRC,		store2_C	;09		;RRC (Ix+d),C
001d0a cf40
001c4b da9b
001c4c cbf9                      instr 	fetch_nop,	op_RRC,		store2_D	;0A		;RRC (Ix+d),D
001d0b cf41
001c4d da99
001c4e cbf9                      instr 	fetch_nop,	op_RRC,		store2_E	;0B		;RRC (Ix+d),E
001d0c cf42
001c4f da97
001c50 cbf9                      instr 	fetch_nop,	op_RRC,		store2_H	;0C		;RRC (Ix+d),H
001d0d cf43
001c51 da95
001c52 cbf9                      instr 	fetch_nop,	op_RRC,		store2_L	;0D		;RRC (Ix+d),L
001d0e c9d8                      instr 	fetch_nop,	op_RRC,		store_nop	;0E		;RRC (Ix+d)  
001d0f cf43
001c53 da93
001c54 cbf9                      instr 	fetch_nop,	op_RRC,		store2_A	;0F		;RRC (Ix+d),A
001d10 cf44
001c55 da9a
001c56 cbeb                      instr 	fetch_nop,	op_RL,		store2_B	;10		;RL  (Ix+d),B
001d11 cf45
001c57 da98
001c58 cbeb                      instr 	fetch_nop,	op_RL,		store2_C	;11		;RL  (Ix+d),C
001d12 cf46
001c59 da96
001c5a cbeb                      instr 	fetch_nop,	op_RL,		store2_D	;12		;RL  (Ix+d),D
001d13 cf47
001c5b da94
001c5c cbeb                      instr 	fetch_nop,	op_RL,		store2_E	;13		;RL  (Ix+d),E
001d14 cf48
001c5d da92
001c5e cbeb                      instr 	fetch_nop,	op_RL,		store2_H	;14		;RL  (Ix+d),H
001d15 cf49
001c5f da90
001c60 cbeb                      instr 	fetch_nop,	op_RL,		store2_L	;15		;RL  (Ix+d),L
001d16 c9d9                      instr 	fetch_nop,	op_RL,		store_nop	;16		;RL  (Ix+d)  
001d17 cf49
001c61 da8e
001c62 cbeb                      instr 	fetch_nop,	op_RL,		store2_A	;17		;RL  (Ix+d),A
001d18 cf4a
001c63 db9c
001c64 cbdd                      instr 	fetch_nop,	op_RR,		store2_B	;18		;RR  (Ix+d),B
001d19 cf4b
001c65 db9a
001c66 cbdd                      instr 	fetch_nop,	op_RR,		store2_C	;19		;RR  (Ix+d),C
001d1a cf4c
001c67 db98
001c68 cbdd                      instr 	fetch_nop,	op_RR,		store2_D	;1A		;RR  (Ix+d),D
001d1b cf4d
001c69 db96
001c6a cbdd                      instr 	fetch_nop,	op_RR,		store2_E	;1B		;RR  (Ix+d),E
001d1c cf4e
001c6b db94
001c6c cbdd                      instr 	fetch_nop,	op_RR,		store2_H	;1C		;RR  (Ix+d),H
001d1d cf4f
001c6d db92
001c6e cbdd                      instr 	fetch_nop,	op_RR,		store2_L	;1D		;RR  (Ix+d),L
001d1e cae1                      instr 	fetch_nop,	op_RR,		store_nop	;1E		;RR  (Ix+d)  
001d1f cf4f
001c6f db90
001c70 cbdd                      instr 	fetch_nop,	op_RR,		store2_A	;1F		;RR  (Ix+d),A
001d20 cf50
001c71 db98
001c72 cbcf                      instr 	fetch_nop,	op_SLA,		store2_B	;20		;SLA (Ix+d),B
001d21 cf51
001c73 db96
001c74 cbcf                      instr 	fetch_nop,	op_SLA,		store2_C	;21		;SLA (Ix+d),C
001d22 cf52
001c75 db94
001c76 cbcf                      instr 	fetch_nop,	op_SLA,		store2_D	;22		;SLA (Ix+d),D
001d23 cf53
001c77 db92
001c78 cbcf                      instr 	fetch_nop,	op_SLA,		store2_E	;23		;SLA (Ix+d),E
001d24 cf54
001c79 db90
001c7a cbcf                      instr 	fetch_nop,	op_SLA,		store2_H	;24		;SLA (Ix+d),H
001d25 cf55
001c7b db8e
001c7c cbcf                      instr 	fetch_nop,	op_SLA,		store2_L	;25		;SLA (Ix+d),L
001d26 cae3                      instr 	fetch_nop,	op_SLA,		store_nop	;26		;SLA (Ix+d)  
001d27 cf55
001c7d db8c
001c7e cbcf                      instr 	fetch_nop,	op_SLA,		store2_A	;27		;SLA (Ix+d),A
001d28 cf56
001c7f db92
001c80 cbc1                      instr 	fetch_nop,	op_SRA,		store2_B	;28		;SRA (Ix+d),B
001d29 cf57
001c81 db90
001c82 cbc1                      instr 	fetch_nop,	op_SRA,		store2_C	;29		;SRA (Ix+d),C
001d2a cf58
001c83 db8e
001c84 cbc1                      instr 	fetch_nop,	op_SRA,		store2_D	;2A		;SRA (Ix+d),D
001d2b cf59
001c85 db8c
001c86 cbc1                      instr 	fetch_nop,	op_SRA,		store2_E	;2B		;SRA (Ix+d),E
001d2c cf5a
001c87 db8a
001c88 cbc1                      instr 	fetch_nop,	op_SRA,		store2_H	;2C		;SRA (Ix+d),H
001d2d cf5b
001c89 db88
001c8a cbc1                      instr 	fetch_nop,	op_SRA,		store2_L	;2D		;SRA (Ix+d),L
001d2e cae3                      instr 	fetch_nop,	op_SRA,		store_nop	;2E		;SRA (Ix+d)  
001d2f cf5b
001c8b db86
001c8c cbc1                      instr 	fetch_nop,	op_SRA,		store2_A	;2F		;SRA (Ix+d),A
001d30 cf5c
001c8d db8e
001c8e cbb3                      instr 	fetch_nop,	op_SLL,		store2_B	;30		;SLL (Ix+d),B
001d31 cf5d
001c8f db8c
001c90 cbb3                      instr 	fetch_nop,	op_SLL,		store2_C	;31		;SLL (Ix+d),C
001d32 cf5e
001c91 db8a
001c92 cbb3                      instr 	fetch_nop,	op_SLL,		store2_D	;32		;SLL (Ix+d),D
001d33 cf5f
001c93 db88
001c94 cbb3                      instr 	fetch_nop,	op_SLL,		store2_E	;33		;SLL (Ix+d),E
001d34 cf60
001c95 db86
001c96 cbb3                      instr 	fetch_nop,	op_SLL,		store2_H	;34		;SLL (Ix+d),H
001d35 cf61
001c97 db84
001c98 cbb3                      instr 	fetch_nop,	op_SLL,		store2_L	;35		;SLL (Ix+d),L
001d36 cae5                      instr 	fetch_nop,	op_SLL,		store_nop	;36		;SLL (Ix+d)  
001d37 cf61
001c99 db82
001c9a cbb3                      instr 	fetch_nop,	op_SLL,		store2_A	;37		;SLL (Ix+d),A
001d38 cf62
001c9b db89
001c9c cba5                      instr 	fetch_nop,	op_SRL,		store2_B	;38		;SRL (Ix+d),B
001d39 cf63
001c9d db87
001c9e cba5                      instr 	fetch_nop,	op_SRL,		store2_C	;39		;SRL (Ix+d),C
001d3a cf64
001c9f db85
001ca0 cba5                      instr 	fetch_nop,	op_SRL,		store2_D	;3A		;SRL (Ix+d),D
001d3b cf65
001ca1 db83
001ca2 cba5                      instr 	fetch_nop,	op_SRL,		store2_E	;3B		;SRL (Ix+d),E
001d3c cf66
001ca3 db81
001ca4 cba5                      instr 	fetch_nop,	op_SRL,		store2_H	;3C		;SRL (Ix+d),H
001d3d cf67
001ca5 db7f
001ca6 cba5                      instr 	fetch_nop,	op_SRL,		store2_L	;3D		;SRL (Ix+d),L
001d3e cae6                      instr 	fetch_nop,	op_SRL,		store_nop	;3E		;SRL (Ix+d)  
001d3f cf67
001ca7 db7d
001ca8 cba5                      instr 	fetch_nop,	op_SRL,		store2_A	;3F		;SRL (Ix+d),A
001d40 cafa                      instr 	fetch_nop,	op_BIT0,	store_nop	;40		;BIT 0,(Ix+d),B
001d41 caf9                      instr 	fetch_nop,	op_BIT0,	store_nop	;41		;BIT 0,(Ix+d),C
001d42 caf8                      instr 	fetch_nop,	op_BIT0,	store_nop	;42		;BIT 0,(Ix+d),D
001d43 caf7                      instr 	fetch_nop,	op_BIT0,	store_nop	;43		;BIT 0,(Ix+d),E
001d44 caf6                      instr 	fetch_nop,	op_BIT0,	store_nop	;44		;BIT 0,(Ix+d),H
001d45 caf5                      instr 	fetch_nop,	op_BIT0,	store_nop	;45		;BIT 0,(Ix+d),L
001d46 caf4                      instr 	fetch_nop,	op_BIT0,	store_nop	;46		;BIT 0,(Ix+d)
001d47 caf3                      instr 	fetch_nop,	op_BIT0,	store_nop	;47		;BIT 0,(Ix+d),A   
001d48 caf0                      instr 	fetch_nop,	op_BIT1,	store_nop	;48		;BIT 1,(Ix+d),B
001d49 caef                      instr 	fetch_nop,	op_BIT1,	store_nop	;49		;BIT 1,(Ix+d),C
001d4a caee                      instr 	fetch_nop,	op_BIT1,	store_nop	;4A		;BIT 1,(Ix+d),D
001d4b caed                      instr 	fetch_nop,	op_BIT1,	store_nop	;4B		;BIT 1,(Ix+d),E
001d4c caec                      instr 	fetch_nop,	op_BIT1,	store_nop	;4C		;BIT 1,(Ix+d),H
001d4d caeb                      instr 	fetch_nop,	op_BIT1,	store_nop	;4D		;BIT 1,(Ix+d),L
001d4e caea                      instr 	fetch_nop,	op_BIT1,	store_nop	;4E		;BIT 1,(Ix+d)
001d4f cae9                      instr 	fetch_nop,	op_BIT1,	store_nop	;4F		;BIT 1,(Ix+d),A
001d50 cae6                      instr 	fetch_nop,	op_BIT2,	store_nop	;50		;BIT 2,(Ix+d),B
001d51 cae5                      instr 	fetch_nop,	op_BIT2,	store_nop	;51		;BIT 2,(Ix+d),C
001d52 cae4                      instr 	fetch_nop,	op_BIT2,	store_nop	;52		;BIT 2,(Ix+d),D
001d53 cae3                      instr 	fetch_nop,	op_BIT2,	store_nop	;53		;BIT 2,(Ix+d),E
001d54 cae2                      instr 	fetch_nop,	op_BIT2,	store_nop	;54		;BIT 2,(Ix+d),H
001d55 cae1                      instr 	fetch_nop,	op_BIT2,	store_nop	;55		;BIT 2,(Ix+d),L
001d56 cae0                      instr 	fetch_nop,	op_BIT2,	store_nop	;56		;BIT 2,(Ix+d)
001d57 cadf                      instr 	fetch_nop,	op_BIT2,	store_nop	;57		;BIT 2,(Ix+d),A
001d58 cadc                      instr 	fetch_nop,	op_BIT3,	store_nop	;58		;BIT 3,(Ix+d),B
001d59 cadb                      instr 	fetch_nop,	op_BIT3,	store_nop	;59		;BIT 3,(Ix+d),C
001d5a cada                      instr 	fetch_nop,	op_BIT3,	store_nop	;5A		;BIT 3,(Ix+d),D
001d5b cad9                      instr 	fetch_nop,	op_BIT3,	store_nop	;5B		;BIT 3,(Ix+d),E
001d5c cad8                      instr 	fetch_nop,	op_BIT3,	store_nop	;5C		;BIT 3,(Ix+d),H
001d5d cad7                      instr 	fetch_nop,	op_BIT3,	store_nop	;5D		;BIT 3,(Ix+d),L
001d5e cad6                      instr 	fetch_nop,	op_BIT3,	store_nop	;5E		;BIT 3,(Ix+d)
001d5f cad5                      instr 	fetch_nop,	op_BIT3,	store_nop	;5F		;BIT 3,(Ix+d),A
001d60 cad2                      instr 	fetch_nop,	op_BIT4,	store_nop	;60		;BIT 4,(Ix+d),B
001d61 cad1                      instr 	fetch_nop,	op_BIT4,	store_nop	;61		;BIT 4,(Ix+d),C
001d62 cad0                      instr 	fetch_nop,	op_BIT4,	store_nop	;62		;BIT 4,(Ix+d),D
001d63 cacf                      instr 	fetch_nop,	op_BIT4,	store_nop	;63		;BIT 4,(Ix+d),E
001d64 cace                      instr 	fetch_nop,	op_BIT4,	store_nop	;64		;BIT 4,(Ix+d),H
001d65 cacd                      instr 	fetch_nop,	op_BIT4,	store_nop	;65		;BIT 4,(Ix+d),L
001d66 cacc                      instr 	fetch_nop,	op_BIT4,	store_nop	;66		;BIT 4,(Ix+d)
001d67 cacb                      instr 	fetch_nop,	op_BIT4,	store_nop	;67		;BIT 4,(Ix+d),A
001d68 cac8                      instr 	fetch_nop,	op_BIT5,	store_nop	;68		;BIT 5,(Ix+d),B
001d69 cac7                      instr 	fetch_nop,	op_BIT5,	store_nop	;69		;BIT 5,(Ix+d),C
001d6a cac6                      instr 	fetch_nop,	op_BIT5,	store_nop	;6A		;BIT 5,(Ix+d),D
001d6b cac5                      instr 	fetch_nop,	op_BIT5,	store_nop	;6B		;BIT 5,(Ix+d),E
001d6c cac4                      instr 	fetch_nop,	op_BIT5,	store_nop	;6C		;BIT 5,(Ix+d),H
001d6d cac3                      instr 	fetch_nop,	op_BIT5,	store_nop	;6D		;BIT 5,(Ix+d),L
001d6e cac2                      instr 	fetch_nop,	op_BIT5,	store_nop	;6E		;BIT 5,(Ix+d)
001d6f cac1                      instr 	fetch_nop,	op_BIT5,	store_nop	;6F		;BIT 5,(Ix+d),A
001d70 cabe                      instr 	fetch_nop,	op_BIT6,	store_nop	;70		;BIT 6,(Ix+d),B
001d71 cabd                      instr 	fetch_nop,	op_BIT6,	store_nop	;71		;BIT 6,(Ix+d),C
001d72 cabc                      instr 	fetch_nop,	op_BIT6,	store_nop	;72		;BIT 6,(Ix+d),D
001d73 cabb                      instr 	fetch_nop,	op_BIT6,	store_nop	;73		;BIT 6,(Ix+d),E
001d74 caba                      instr 	fetch_nop,	op_BIT6,	store_nop	;74		;BIT 6,(Ix+d),H
001d75 cab9                      instr 	fetch_nop,	op_BIT6,	store_nop	;75		;BIT 6,(Ix+d),L
001d76 cab8                      instr 	fetch_nop,	op_BIT6,	store_nop	;76		;BIT 6,(Ix+d)
001d77 cab7                      instr 	fetch_nop,	op_BIT6,	store_nop	;77		;BIT 6,(Ix+d),A
001d78 cab4                      instr 	fetch_nop,	op_BIT7,	store_nop	;78		;BIT 7,(Ix+d),B
001d79 cab3                      instr 	fetch_nop,	op_BIT7,	store_nop	;79		;BIT 7,(Ix+d),C
001d7a cab2                      instr 	fetch_nop,	op_BIT7,	store_nop	;7A		;BIT 7,(Ix+d),D
001d7b cab1                      instr 	fetch_nop,	op_BIT7,	store_nop	;7B		;BIT 7,(Ix+d),E
001d7c cab0                      instr 	fetch_nop,	op_BIT7,	store_nop	;7C		;BIT 7,(Ix+d),H
001d7d caaf                      instr 	fetch_nop,	op_BIT7,	store_nop	;7D		;BIT 7,(Ix+d),L
001d7e caae                      instr 	fetch_nop,	op_BIT7,	store_nop	;7E		;BIT 7,(Ix+d)
001d7f caad                      instr 	fetch_nop,	op_BIT7,	store_nop	;7F		;BIT 7,(Ix+d),A
001d80 cf28
001ca9 7f6e
001caa cb97                      instr 	fetch_nop,	op_RES0,	store2_B	;80		;RES 0,(Ix+d),B
001d81 cf29
001cab 7f6e
001cac cb97                      instr 	fetch_nop,	op_RES0,	store2_C	;81		;RES 0,(Ix+d),C
001d82 cf2a
001cad 7f6e
001cae cb97                      instr 	fetch_nop,	op_RES0,	store2_D	;82		;RES 0,(Ix+d),D
001d83 cf2b
001caf 7f6e
001cb0 cb97                      instr 	fetch_nop,	op_RES0,	store2_E	;83		;RES 0,(Ix+d),E
001d84 cf2c
001cb1 7f6e
001cb2 cb97                      instr 	fetch_nop,	op_RES0,	store2_H	;84		;RES 0,(Ix+d),H
001d85 cf2d
001cb3 7f6e
001cb4 cb97                      instr 	fetch_nop,	op_RES0,	store2_L	;85		;RES 0,(Ix+d),L
001d86 cf2e
001cb5 7f6e
001cb6 9508                      instr 	fetch_nop,	op_RES0,	store_nop	;86		;RES 0,(Ix+d)
001d87 cf2f
001cb7 7f6e
001cb8 cb95                      instr 	fetch_nop,	op_RES0,	store2_A	;87		;RES 0,(Ix+d),A
001d88 cf30
001cb9 7f6d
001cba cb87                      instr 	fetch_nop,	op_RES1,	store2_B	;88		;RES 1,(Ix+d),B
001d89 cf31
001cbb 7f6d
001cbc cb87                      instr 	fetch_nop,	op_RES1,	store2_C	;89		;RES 1,(Ix+d),C
001d8a cf32
001cbd 7f6d
001cbe cb87                      instr 	fetch_nop,	op_RES1,	store2_D	;8A		;RES 1,(Ix+d),D
001d8b cf33
001cbf 7f6d
001cc0 cb87                      instr 	fetch_nop,	op_RES1,	store2_E	;8B		;RES 1,(Ix+d),E
001d8c cf34
001cc1 7f6d
001cc2 cb87                      instr 	fetch_nop,	op_RES1,	store2_H	;8C		;RES 1,(Ix+d),H
001d8d cf35
001cc3 7f6d
001cc4 cb87                      instr 	fetch_nop,	op_RES1,	store2_L	;8D		;RES 1,(Ix+d),L
001d8e cf36
001cc5 7f6d
001cc6 9508                      instr 	fetch_nop,	op_RES1,	store_nop	;8E		;RES 1,(Ix+d)
001d8f cf37
001cc7 7f6d
001cc8 cb85                      instr 	fetch_nop,	op_RES1,	store2_A	;8F		;RES 1,(Ix+d),A
001d90 cf38
001cc9 7f6b
001cca cb77                      instr 	fetch_nop,	op_RES2,	store2_B	;90		;RES 2,(Ix+d),B
001d91 cf39
001ccb 7f6b
001ccc cb77                      instr 	fetch_nop,	op_RES2,	store2_C	;91		;RES 2,(Ix+d),C
001d92 cf3a
001ccd 7f6b
001cce cb77                      instr 	fetch_nop,	op_RES2,	store2_D	;92		;RES 2,(Ix+d),D
001d93 cf3b
001ccf 7f6b
001cd0 cb77                      instr 	fetch_nop,	op_RES2,	store2_E	;93		;RES 2,(Ix+d),E
001d94 cf3c
001cd1 7f6b
001cd2 cb77                      instr 	fetch_nop,	op_RES2,	store2_H	;94		;RES 2,(Ix+d),H
001d95 cf3d
001cd3 7f6b
001cd4 cb77                      instr 	fetch_nop,	op_RES2,	store2_L	;95		;RES 2,(Ix+d),L
001d96 cf3e
001cd5 7f6b
001cd6 9508                      instr 	fetch_nop,	op_RES2,	store_nop	;96		;RES 2,(Ix+d)
001d97 cf3f
001cd7 7f6b
001cd8 cb75                      instr 	fetch_nop,	op_RES2,	store2_A	;97		;RES 2,(Ix+d),A
001d98 cf40
001cd9 7f67
001cda cb67                      instr 	fetch_nop,	op_RES3,	store2_B	;98		;RES 3,(Ix+d),B
001d99 cf41
001cdb 7f67
001cdc cb67                      instr 	fetch_nop,	op_RES3,	store2_C	;99		;RES 3,(Ix+d),C
001d9a cf42
001cdd 7f67
001cde cb67                      instr 	fetch_nop,	op_RES3,	store2_D	;9A		;RES 3,(Ix+d),D
001d9b cf43
001cdf 7f67
001ce0 cb67                      instr 	fetch_nop,	op_RES3,	store2_E	;9B		;RES 3,(Ix+d),E
001d9c cf44
001ce1 7f67
001ce2 cb67                      instr 	fetch_nop,	op_RES3,	store2_H	;9C		;RES 3,(Ix+d),H
001d9d cf45
001ce3 7f67
001ce4 cb67                      instr 	fetch_nop,	op_RES3,	store2_L	;9D		;RES 3,(Ix+d),L
001d9e cf46
001ce5 7f67
001ce6 9508                      instr 	fetch_nop,	op_RES3,	store_nop	;9E		;RES 3,(Ix+d)
001d9f cf47
001ce7 7f67
001ce8 cb65                      instr 	fetch_nop,	op_RES3,	store2_A	;9F		;RES 3,(Ix+d),A
001da0 cf48
001ce9 7e6f
001cea cb57                      instr 	fetch_nop,	op_RES4,	store2_B	;A0		;RES 4,(Ix+d),B
001da1 cf49
001ceb 7e6f
001cec cb57                      instr 	fetch_nop,	op_RES4,	store2_C	;A1		;RES 4,(Ix+d),C
001da2 cf4a
001ced 7e6f
001cee cb57                      instr 	fetch_nop,	op_RES4,	store2_D	;A2		;RES 4,(Ix+d),D
001da3 cf4b
001cef 7e6f
001cf0 cb57                      instr 	fetch_nop,	op_RES4,	store2_E	;A3		;RES 4,(Ix+d),E
001da4 cf4c
001cf1 7e6f
001cf2 cb57                      instr 	fetch_nop,	op_RES4,	store2_H	;A4		;RES 4,(Ix+d),H
001da5 cf4d
001cf3 7e6f
001cf4 cb57                      instr 	fetch_nop,	op_RES4,	store2_L	;A5		;RES 4,(Ix+d),L
001da6 cf4e
001cf5 7e6f
001cf6 9508                      instr 	fetch_nop,	op_RES4,	store_nop	;A6		;RES 4,(Ix+d)
001da7 cf4f
001cf7 7e6f
001cf8 cb55                      instr 	fetch_nop,	op_RES4,	store2_A	;A7		;RES 4,(Ix+d),A
001da8 cf50
001cf9 7d6f
001cfa cb47                      instr 	fetch_nop,	op_RES5,	store2_B	;A8		;RES 5,(Ix+d),B
001da9 cf51
001cfb 7d6f
001cfc cb47                      instr 	fetch_nop,	op_RES5,	store2_C	;A9		;RES 5,(Ix+d),C
001daa c055
001e00 7d6f
001e01 ca44                      instr 	fetch_nop,	op_RES5,	store2_D	;AA		;RES 5,(Ix+d),D
001dab c056
001e02 7d6f
001e03 ca44                      instr 	fetch_nop,	op_RES5,	store2_E	;AB		;RES 5,(Ix+d),E
001dac c057
001e04 7d6f
001e05 ca44                      instr 	fetch_nop,	op_RES5,	store2_H	;AC		;RES 5,(Ix+d),H
001dad c058
001e06 7d6f
001e07 ca44                      instr 	fetch_nop,	op_RES5,	store2_L	;AD		;RES 5,(Ix+d),L
001dae c059
001e08 7d6f
001e09 9508                      instr 	fetch_nop,	op_RES5,	store_nop	;AE		;RES 5,(Ix+d)
001daf c05a
001e0a 7d6f
001e0b ca42                      instr 	fetch_nop,	op_RES5,	store2_A	;AF		;RES 5,(Ix+d),A
001db0 c05b
001e0c 7b6f
001e0d ca34                      instr 	fetch_nop,	op_RES6,	store2_B	;B0		;RES 6,(Ix+d),B
001db1 c05c
001e0e 7b6f
001e0f ca34                      instr 	fetch_nop,	op_RES6,	store2_C	;B1		;RES 6,(Ix+d),C
001db2 c05d
001e10 7b6f
001e11 ca34                      instr 	fetch_nop,	op_RES6,	store2_D	;B2		;RES 6,(Ix+d),D
001db3 c05e
001e12 7b6f
001e13 ca34                      instr 	fetch_nop,	op_RES6,	store2_E	;B3		;RES 6,(Ix+d),E
001db4 c05f
001e14 7b6f
001e15 ca34                      instr 	fetch_nop,	op_RES6,	store2_H	;B4		;RES 6,(Ix+d),H
001db5 c060
001e16 7b6f
001e17 ca34                      instr 	fetch_nop,	op_RES6,	store2_L	;B5		;RES 6,(Ix+d),L
001db6 c061
001e18 7b6f
001e19 9508                      instr 	fetch_nop,	op_RES6,	store_nop	;B6		;RES 6,(Ix+d)
001db7 c062
001e1a 7b6f
001e1b ca32                      instr 	fetch_nop,	op_RES6,	store2_A	;B7		;RES 6,(Ix+d),A
001db8 c063
001e1c 776f
001e1d ca24                      instr 	fetch_nop,	op_RES7,	store2_B	;B8		;RES 7,(Ix+d),B
001db9 c064
001e1e 776f
001e1f ca24                      instr 	fetch_nop,	op_RES7,	store2_C	;B9		;RES 7,(Ix+d),C
001dba c065
001e20 776f
001e21 ca24                      instr 	fetch_nop,	op_RES7,	store2_D	;BA		;RES 7,(Ix+d),D
001dbb c066
001e22 776f
001e23 ca24                      instr 	fetch_nop,	op_RES7,	store2_E	;BB		;RES 7,(Ix+d),E
001dbc c067
001e24 776f
001e25 ca24                      instr 	fetch_nop,	op_RES7,	store2_H	;BC		;RES 7,(Ix+d),H
001dbd c068
001e26 776f
001e27 ca24                      instr 	fetch_nop,	op_RES7,	store2_L	;BD		;RES 7,(Ix+d),L
001dbe c069
001e28 776f
001e29 9508                      instr 	fetch_nop,	op_RES7,	store_nop	;BE		;RES 7,(Ix+d)
001dbf c06a
001e2a 776f
001e2b ca22                      instr 	fetch_nop,	op_RES7,	store2_A	;BF		;RES 7,(Ix+d),A
001dc0 c06b
001e2c 6061
001e2d ca14                      instr 	fetch_nop,	op_SET0,	store2_B	;C0		;SET 0,(Ix+d),B
001dc1 c06c
001e2e 6061
001e2f ca14                      instr 	fetch_nop,	op_SET0,	store2_C	;C1		;SET 0,(Ix+d),C
001dc2 c06d
001e30 6061
001e31 ca14                      instr 	fetch_nop,	op_SET0,	store2_D	;C2		;SET 0,(Ix+d),D
001dc3 c06e
001e32 6061
001e33 ca14                      instr 	fetch_nop,	op_SET0,	store2_E	;C3		;SET 0,(Ix+d),E
001dc4 c06f
001e34 6061
001e35 ca14                      instr 	fetch_nop,	op_SET0,	store2_H	;C4		;SET 0,(Ix+d),H
001dc5 c070
001e36 6061
001e37 ca14                      instr 	fetch_nop,	op_SET0,	store2_L	;C5		;SET 0,(Ix+d),L
001dc6 c071
001e38 6061
001e39 9508                      instr 	fetch_nop,	op_SET0,	store_nop	;C6		;SET 0,(Ix+d)
001dc7 c072
001e3a 6061
001e3b ca12                      instr 	fetch_nop,	op_SET0,	store2_A	;C7		;SET 0,(Ix+d),A
001dc8 c073
001e3c 6062
001e3d ca04                      instr 	fetch_nop,	op_SET1,	store2_B	;C8		;SET 1,(Ix+d),B
001dc9 c074
001e3e 6062
001e3f ca04                      instr 	fetch_nop,	op_SET1,	store2_C	;C9		;SET 1,(Ix+d),C
001dca c075
001e40 6062
001e41 ca04                      instr 	fetch_nop,	op_SET1,	store2_D	;CA		;SET 1,(Ix+d),D
001dcb c076
001e42 6062
001e43 ca04                      instr 	fetch_nop,	op_SET1,	store2_E	;CB		;SET 1,(Ix+d),E
001dcc c077
001e44 6062
001e45 ca04                      instr 	fetch_nop,	op_SET1,	store2_H	;CC		;SET 1,(Ix+d),H
001dcd c078
001e46 6062
001e47 ca04                      instr 	fetch_nop,	op_SET1,	store2_L	;CD		;SET 1,(Ix+d),L
001dce c079
001e48 6062
001e49 9508                      instr 	fetch_nop,	op_SET1,	store_nop	;CE		;SET 1,(Ix+d)
001dcf c07a
001e4a 6062
001e4b ca02                      instr 	fetch_nop,	op_SET1,	store2_A	;CF		;SET 1,(Ix+d),A
001dd0 c07b
001e4c 6064
001e4d c9f4                      instr 	fetch_nop,	op_SET2,	store2_B	;D0		;SET 2,(Ix+d),B
001dd1 c07c
001e4e 6064
001e4f c9f4                      instr 	fetch_nop,	op_SET2,	store2_C	;D1		;SET 2,(Ix+d),C
001dd2 c07d
001e50 6064
001e51 c9f4                      instr 	fetch_nop,	op_SET2,	store2_D	;D2		;SET 2,(Ix+d),D
001dd3 c07e
001e52 6064
001e53 c9f4                      instr 	fetch_nop,	op_SET2,	store2_E	;D3		;SET 2,(Ix+d),E
001dd4 c07f
001e54 6064
001e55 c9f4                      instr 	fetch_nop,	op_SET2,	store2_H	;D4		;SET 2,(Ix+d),H
001dd5 c080
001e56 6064
001e57 c9f4                      instr 	fetch_nop,	op_SET2,	store2_L	;D5		;SET 2,(Ix+d),L
001dd6 c081
001e58 6064
001e59 9508                      instr 	fetch_nop,	op_SET2,	store_nop	;D6		;SET 2,(Ix+d)
001dd7 c082
001e5a 6064
001e5b c9f2                      instr 	fetch_nop,	op_SET2,	store2_A	;D7		;SET 2,(Ix+d),A
001dd8 c083
001e5c 6068
001e5d c9e4                      instr 	fetch_nop,	op_SET3,	store2_B	;D8		;SET 3,(Ix+d),B
001dd9 c084
001e5e 6068
001e5f c9e4                      instr 	fetch_nop,	op_SET3,	store2_C	;D9		;SET 3,(Ix+d),C
001dda c085
001e60 6068
001e61 c9e4                      instr 	fetch_nop,	op_SET3,	store2_D	;DA		;SET 3,(Ix+d),D
001ddb c086
001e62 6068
001e63 c9e4                      instr 	fetch_nop,	op_SET3,	store2_E	;DB		;SET 3,(Ix+d),E
001ddc c087
001e64 6068
001e65 c9e4                      instr 	fetch_nop,	op_SET3,	store2_H	;DC		;SET 3,(Ix+d),H
001ddd c088
001e66 6068
001e67 c9e4                      instr 	fetch_nop,	op_SET3,	store2_L	;DD		;SET 3,(Ix+d),L
001dde c089
001e68 6068
001e69 9508                      instr 	fetch_nop,	op_SET3,	store_nop	;DE		;SET 3,(Ix+d)
001ddf c08a
001e6a 6068
001e6b c9e2                      instr 	fetch_nop,	op_SET3,	store2_A	;DF		;SET 3,(Ix+d),A
001de0 c08b
001e6c 6160
001e6d c9d4                      instr 	fetch_nop,	op_SET4,	store2_B	;E0		;SET 4,(Ix+d),B
001de1 c08c
001e6e 6160
001e6f c9d4                      instr 	fetch_nop,	op_SET4,	store2_C	;E1		;SET 4,(Ix+d),C
001de2 c08d
001e70 6160
001e71 c9d4                      instr 	fetch_nop,	op_SET4,	store2_D	;E2		;SET 4,(Ix+d),D
001de3 c08e
001e72 6160
001e73 c9d4                      instr 	fetch_nop,	op_SET4,	store2_E	;E3		;SET 4,(Ix+d),E
001de4 c08f
001e74 6160
001e75 c9d4                      instr 	fetch_nop,	op_SET4,	store2_H	;E4		;SET 4,(Ix+d),H
001de5 c090
001e76 6160
001e77 c9d4                      instr 	fetch_nop,	op_SET4,	store2_L	;E5		;SET 4,(Ix+d),L
001de6 c091
001e78 6160
001e79 9508                      instr 	fetch_nop,	op_SET4,	store_nop	;E6		;SET 4,(Ix+d)
001de7 c092
001e7a 6160
001e7b c9d2                      instr 	fetch_nop,	op_SET4,	store2_A	;E7		;SET 4,(Ix+d),A
001de8 c093
001e7c 6260
001e7d c9c4                      instr 	fetch_nop,	op_SET5,	store2_B	;E8		;SET 5,(Ix+d),B
001de9 c094
001e7e 6260
001e7f c9c4                      instr 	fetch_nop,	op_SET5,	store2_C	;E9		;SET 5,(Ix+d),C
001dea c095
001e80 6260
001e81 c9c4                      instr 	fetch_nop,	op_SET5,	store2_D	;EA		;SET 5,(Ix+d),D
001deb c096
001e82 6260
001e83 c9c4                      instr 	fetch_nop,	op_SET5,	store2_E	;EB		;SET 5,(Ix+d),E
001dec c097
001e84 6260
001e85 c9c4                      instr 	fetch_nop,	op_SET5,	store2_H	;EC		;SET 5,(Ix+d),H
001ded c098
001e86 6260
001e87 c9c4                      instr 	fetch_nop,	op_SET5,	store2_L	;ED		;SET 5,(Ix+d),L
001dee c099
001e88 6260
001e89 9508                      instr 	fetch_nop,	op_SET5,	store_nop	;EE		;SET 5,(Ix+d)
001def c09a
001e8a 6260
001e8b c9c2                      instr 	fetch_nop,	op_SET5,	store2_A	;EF		;SET 5,(Ix+d),A
001df0 c09b
001e8c 6460
001e8d c9b4                      instr 	fetch_nop,	op_SET6,	store2_B	;F0		;SET 6,(Ix+d),B
001df1 c09c
001e8e 6460
001e8f c9b4                      instr 	fetch_nop,	op_SET6,	store2_C	;F1		;SET 6,(Ix+d),C
001df2 c09d
001e90 6460
001e91 c9b4                      instr 	fetch_nop,	op_SET6,	store2_D	;F2		;SET 6,(Ix+d),D
001df3 c09e
001e92 6460
001e93 c9b4                      instr 	fetch_nop,	op_SET6,	store2_E	;F3		;SET 6,(Ix+d),E
001df4 c09f
001e94 6460
001e95 c9b4                      instr 	fetch_nop,	op_SET6,	store2_H	;F4		;SET 6,(Ix+d),H
001df5 c0a0
001e96 6460
001e97 c9b4                      instr 	fetch_nop,	op_SET6,	store2_L	;F5		;SET 6,(Ix+d),L
001df6 c0a1
001e98 6460
001e99 9508                      instr 	fetch_nop,	op_SET6,	store_nop	;F6		;SET 6,(Ix+d)
001df7 c0a2
001e9a 6460
001e9b c9b2                      instr 	fetch_nop,	op_SET6,	store2_A	;F7		;SET 6,(Ix+d),A
001df8 c0a3
001e9c 6860
001e9d c9a4                      instr 	fetch_nop,	op_SET7,	store2_B	;F8		;SET 7,(Ix+d),B
001df9 c0a4
001e9e 6860
001e9f c9a4                      instr 	fetch_nop,	op_SET7,	store2_C	;F9		;SET 7,(Ix+d),C
001dfa c0a5
001ea0 6860
001ea1 c9a4                      instr 	fetch_nop,	op_SET7,	store2_D	;FA		;SET 7,(Ix+d),D
001dfb c0a6
001ea2 6860
001ea3 c9a4                      instr 	fetch_nop,	op_SET7,	store2_E	;FB		;SET 7,(Ix+d),E
001dfc c0a7
001ea4 6860
001ea5 c9a4                      instr 	fetch_nop,	op_SET7,	store2_H	;FC		;SET 7,(Ix+d),H
001dfd c0a8
001ea6 6860
001ea7 c9a4                      instr 	fetch_nop,	op_SET7,	store2_L	;FD		;SET 7,(Ix+d),L
001dfe c0a9
001ea8 6860
001ea9 9508                      instr 	fetch_nop,	op_SET7,	store_nop	;FE		;SET 7,(Ix+d)
001dff c0aa
001eaa 6860
001eab c9a2                      instr 	fetch_nop,	op_SET7,	store2_A	;FF		;SET 7,(Ix+d),A
                                 
                                 .macro m_do_fetch_0
                                 	ldi	opl,0
                                 .endm
                                 .equ do_fetch_0 = 0
                                 ;	ldi	opl,0
                                 ;	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|IN r,[C]  |***P0-|Input                |r=[C]                 |
                                 ;
                                 
                                 do_op_in:			; in opl,(opl)
                                 .if PORT_DEBUG
                                 .endif
                                 
001eac 2f16                      	mov	temp2,opl
001ead 940e 22b7                 	lcall	portRead
001eaf 2f60                      	mov	opl,temp
001eb0 fb40                      	bst	z_flags,ZFL_C			;save Carry
001eb1 e4f4
001eb2 2fe0
001eb3 9144                      	ldpmx	z_flags,sz53p_tab,temp		;S,Z,P
001eb4 f940                      	bld	z_flags,ZFL_C
                                 
                                 .if PORT_DEBUG
                                 .endif
001eb5 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|OUT [C],r |------|Output               |[C]=r                 |
                                 ;
                                 
                                 do_op_out: 			; out (c),opl
                                 .if PORT_DEBUG
                                 .endif
001eb6 2f06                      	mov	temp,opl
001eb7 2d18                      	mov	temp2,z_c
001eb8 940e 22b5                 	lcall	portWrite
001eba 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|LD dst,src|------|Load                 |dst=src               |
                                 ;
                                 
                                 do_op_stbc: 		;store bc to mem loc in opl:h
001ebb 01db                      	movw xl,opl
001ebc b9bb
001ebd b828
001ebe b9ab
001ebf b838
001ec0 b88b
001ec1 b858
001ec2 b868                      	mem_write_s z_c
001ec3 9611                      	adiw xl,1
001ec4 b9bb
001ec5 b828
001ec6 b9ab
001ec7 b838
001ec8 b89b
001ec9 b858
001eca b868                      	mem_write_s z_b
001ecb 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|LD dst,src|------|Load                 |dst=src               |
                                 ;
                                 ;
                                 do_op_stde: 		;store de to mem loc in opl:h
001ecc 01db                      	movw xl,opl
001ecd b9bb
001ece b828
001ecf b9ab
001ed0 b838
001ed1 b8ab
001ed2 b858
001ed3 b868                      	mem_write_s z_e
001ed4 9611                      	adiw xl,1
001ed5 b9bb
001ed6 b828
001ed7 b9ab
001ed8 b838
001ed9 b8bb
001eda b858
001edb b868                      	mem_write_s z_d
001edc 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|LD dst,src|------|Load                 |dst=src               |
                                 ;
                                 ;
                                 do_op_stsp: 		;store sp to mem loc in opl:h
001edd 01db                      	movw xl,opl
001ede b9bb
001edf b828
001ee0 b9ab
001ee1 b838
001ee2 b8eb
001ee3 b858
001ee4 b868                      	mem_write_s z_spl
001ee5 9611                      	adiw xl,1
001ee6 b9bb
001ee7 b828
001ee8 b9ab
001ee9 b838
001eea b8fb
001eeb b858
001eec b868                      	mem_write_s z_sph
001eed 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|ADC HL,ss |***V0*|Add with Carry       |HL=HL+ss+CY           |
                                 ;
                                 
                                 do_op_ADCHL:
001eee 9546                      	lsr	z_flags				; ZFL_C --> Carry
001eef e040                      	ldi	z_flags,0			; clear N
001ef0 1ec6                      	adc	z_l,opl
001ef1 b70f                      	in	temp,sreg			; save lower Z 
001ef2 1ed7                      	adc	z_h,oph
001ef3 b71f                      	in	temp2,sreg
                                 
001ef4 2301                      	and	temp,temp2			; 16bit Z
001ef5 fb10
001ef6 f940                      	bmov	z_flags,ZFL_C, temp2,AVR_C
001ef7 fb13
001ef8 f942                      	bmov	z_flags,ZFL_P, temp2,AVR_V
001ef9 fb15
001efa f944                      	bmov	z_flags,ZFL_H, temp2,AVR_H
001efb fb01
001efc f946                      	bmov	z_flags,ZFL_Z, temp,AVR_Z
001efd fb12
001efe f947                      	bmov	z_flags,ZFL_S, temp2,AVR_N
001eff 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|SBC HL,ss |***V1*|Subtract with carry  |HL=HL-ss-CY           |
                                 ;
                                 
                                 	checkspace PC, 24
                                 
                                 do_op_sbchl:
001f00 9546                      	lsr	z_flags				; get Z80 carry
001f01 9418                      	sez					; set z
001f02 0ac6                      	sbc	z_l,opl
001f03 0ad7                      	sbc	z_h,oph
001f04 b70f                      	in temp,sreg
001f05 e042                      	ldi	z_flags,(1<<ZFL_N)		; set N
001f06 fb00
001f07 f940                      	bmov	z_flags,ZFL_C, temp,AVR_C
001f08 fb03
001f09 f942                      	bmov	z_flags,ZFL_P, temp,AVR_V
001f0a fb05
001f0b f944                      	bmov	z_flags,ZFL_H, temp,AVR_H
001f0c fb01
001f0d f946                      	bmov	z_flags,ZFL_Z, temp,AVR_Z
001f0e fb02
001f0f f947                      	bmov	z_flags,ZFL_S, temp,AVR_N
001f10 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|NEG       |***V1*|Negate A             |A=0-A                 |
                                 
                                 ;
                                 do_op_NEG:
001f11 e000                      	ldi	temp,0
001f12 1b05                      	sub 	temp,z_a
001f13 2f50                      	mov	z_a,temp
001f14 b70f                      	in 	temp,sreg
001f15 e4f4
001f16 2fe5
001f17 9144                      	ldpmx	z_flags,sz53p_tab,z_a		;S,Z,P
001f18 fb00
001f19 f940                      	bmov	z_flags,ZFL_C, temp,AVR_C
001f1a fb05
001f1b f944                      	bmov	z_flags,ZFL_H, temp,AVR_H
001f1c fb03
001f1d f942                      	do_z80_flags_V
001f1e 6042                      	do_z80_flags_set_N
001f1f 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|RETI      |------|Return from Interrupt|PC=[SP]+              |
                                 ;|RETN      |------|Return from NMI      |  Copy IFF2 to IFF1   |
                                 
                                 
                                 do_op_RETI:
                                 do_op_RETN:
001f20 850e                      	ldd	temp,y+oz_istat
001f21 fb03
001f22 f902                      	bmov	temp,IFF1, temp,IFF2
001f23 870e                      	std	y+oz_istat,temp
001f24 940c 0fda                 	ljmp	do_store_ret
                                 
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|IM n      |------|Interrupt Mode       |             (n=0,1,2)|
                                 
                                 do_op_IM0:
001f26 850e                      	ldd	temp,y+oz_istat
001f27 7f0c                      	andi	temp, ~IM_MASK
001f28 870e                      	std	y+oz_istat,temp
001f29 9508                      	ret
                                 
                                 do_op_IM1:
001f2a 850e                      	ldd	temp,y+oz_istat
001f2b 7f0c                      	andi	temp,~IM_MASK
001f2c 6001                      	ori	temp,IM1
001f2d 870e                      	std	y+oz_istat,temp
001f2e 9508                      	ret
                                 
                                 do_op_IM2:
001f2f 850e                      	ldd	temp,y+oz_istat
001f30 7f0c                      	andi	temp, ~IM_MASK
001f31 6002                      	ori	temp,IM2
001f32 870e                      	std	y+oz_istat,temp
001f33 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|LD A,i    |**0*0-|Load                 |(i=I,R)  IFF2 --> P   |
                                 ;|LD i,A    |------|Load                 |(i=I,R)               |
                                 
                                 do_op_ldai:
001f34 855c                      	ldd	z_a,y+oz_i
001f35 c001                      	rjmp	op_ldar1
                                 
                                 do_op_ldar:
001f36 855d                      	ldd	z_a,y+oz_r
                                 op_ldar1:
001f37 fb40                      	bst	z_flags,ZFL_C			;save C
001f38 e4f4
001f39 2fe5
001f3a 9144                      	ldpmx	z_flags,sz53p_tab,z_a		;S,Z,H,P,N	
001f3b f940                      	bld	z_flags,ZFL_C			;
001f3c 850e                      	ldd	temp,y+oz_istat
001f3d fb03
001f3e f942                      	bmov	z_flags,ZFL_P, temp,IFF2
001f3f 9508                      	ret
                                 
                                 do_op_ldia:
001f40 875c                      	std	y+oz_i,z_a
001f41 9508                      	ret
                                 
                                 do_op_ldra:
001f42 875d                      	std	y+oz_r,z_a
001f43 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|RLD       |**0P0-|Rotate Left 4 bits   |{A,[HL]}={A,[HL]}<- ##|
                                 ;|RRD       |**0P0-|Rotate Right 4 bits  |{A,[HL]}=->{A,[HL]} ##|
                                 
                                 do_op_rld:
001f44 9562                      	swap	opl
001f45 2f76                      	mov	oph,opl
001f46 7f60                      	andi	opl,0xf0
001f47 707f                      	andi	oph,0x0f
001f48 2f05                      	mov	temp,z_a
001f49 700f                      	andi	temp,0x0f
001f4a 2b60                      	or	opl,temp
001f4b 2f05                      	mov	temp,z_a
001f4c 7f00                      	andi	temp,0xf0
001f4d 2b07                      	or	temp,oph
001f4e 2f50                      	mov	z_a,temp
001f4f fb40                      	bst	z_flags,ZFL_C			;save C
001f50 e4f4
001f51 2fe5
001f52 9144                      	ldpmx	z_flags,sz53p_tab,z_a		;S,Z,H,P,N	
001f53 f940                      	bld	z_flags,ZFL_C			;
001f54 9508                      	ret
                                 
                                 do_op_rrd:
001f55 2f76                      	mov	oph,opl
001f56 7f60                      	andi	opl,0xf0
001f57 707f                      	andi	oph,0x0f
001f58 2f05                      	mov	temp,z_a
001f59 700f                      	andi	temp,0x0f
001f5a 2b60                      	or	opl,temp
001f5b 9562                      	swap	opl
001f5c 2f05                      	mov	temp,z_a
001f5d 7f00                      	andi	temp,0xf0
001f5e 2b07                      	or	temp,oph
001f5f 2f50                      	mov	z_a,temp
001f60 fb40                      	bst	z_flags,ZFL_C			;save C
001f61 e4f4
001f62 2fe5
001f63 9144                      	ldpmx	z_flags,sz53p_tab,z_a		;S,Z,H,P,N	
001f64 f940                      	bld	z_flags,ZFL_C			;
001f65 9508                      	ret
                                 
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|LDD       |--0*0-|Load and Decrement   |[DE]=[HL],HL=HL-1,#   |
                                 ;|LDDR      |--000-|Load, Dec., Repeat   |LDD till BC=0         |
                                 ;|LDI       |--0*0-|Load and Increment   |[DE]=[HL],HL=HL+1,#   |
                                 ;|LDIR      |--000-|Load, Inc., Repeat   |LDI till BC=0         |
                                 ;
                                 
                                 	checkspace PC, 13
                                 
                                 op_LDxx_common:
                                 ;	movw	x,z_l			;
                                 ;	lcall	dram_read		; temp = (HL)
001f66 b8db
001f67 b828
001f68 b8cb
001f69 b838
001f6a b87a
001f6b b848
001f6c c000
001f6d 0000
001f6e b109
001f6f b868
001f70 b86a                      	mem_read_ds temp, z_hl
                                 ;	movw	x,z_e			;
                                 ;	lcall	dram_write		; (DE) = temp
001f71 b8bb
001f72 b828
001f73 b8ab
001f74 b838
001f75 b90b
001f76 b858
001f77 b868                      	mem_write_ds z_de, temp
                                 
001f78 7e49                      	cbr	z_flags,(1<<ZFL_H) | (1<<ZFL_P) | (1<<ZFL_N)
                                 
001f79 01d4                      	movw	x,z_c
001f7a 9711                      	sbiw	x,1			;BC--
001f7b 014d                      	movw	z_c,x
001f7c f009                      	breq	PC+2
001f7d 6044                      	 sbr	z_flags,(1<<ZFL_P)
001f7e 9508                      	ret
                                 
                                 	checkspace PC, 6
                                 
                                 do_op_LDI:
001f7f dfe6                      	rcall	op_LDxx_common
001f80 18a6                      	sub	z_e,_255		;-low(-1)	DE++
001f81 08b6                      	sbc	z_d,_255		;-high(-1)
001f82 18c6                      	sub	z_l,_255		;-low(-1)	HL++
001f83 08d6                      	sbc	z_h,_255		;-high(-1)
001f84 9508                      	ret
                                 
                                 	checkspace PC, 6
                                 
                                 do_op_LDD:
001f85 dfe0                      	rcall	op_LDxx_common
001f86 0ca6                      	add	z_e,_255		;+low(-1)	DE--
001f87 1cb6                      	adc	z_d,_255		;+high(-1)
001f88 0cc6                      	add	z_l,_255		;+low(-1)	HL--
001f89 1cd6                      	adc	z_h,_255		;+high(-1)
001f8a 9508                      	ret
                                 
                                 	checkspace PC, 5
                                 
                                 do_op_LDIR:
001f8b dff3                      	rcall	do_op_LDI
                                 #if 1
001f8c fd42                      	sbrc	z_flags,ZFL_P
001f8d cffd                      	 rjmp	do_op_LDIR
001f8e 9508                      	ret
                                 #else
                                 #endif
                                 
                                 	checkspace PC, 5
                                 
                                 do_op_LDDR:
001f8f dff5                      	rcall	do_op_LDD
                                 #if 1
001f90 fd42                      	sbrc	z_flags,ZFL_P
001f91 cffd                      	 rjmp	do_op_LDDR
001f92 9508                      	ret
                                 #else
                                 #endif
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|CPD       |****1-|Compare and Decrement|A-[HL],HL=HL-1,BC=BC-1|
                                 ;|CPDR      |****1-|Compare, Dec., Repeat|CPD till A=[HL]or BC=0|
                                 ;|CPI       |****1-|Compare and Increment|A-[HL],HL=HL+1,BC=BC-1|
                                 ;|CPIR      |****1-|Compare, Inc., Repeat|CPI till A=[HL]or BC=0|
                                 
                                 
                                 	checkspace PC, 21
                                 
                                 op_CPxx_common:
001f93 01d6                      	movw	x,z_l			; HL
                                 	
001f94 01f4                      	movw	z,z_c			;BC
                                 
001f95 724b                      	cbr	z_flags,(1<<ZFL_S)|(1<<ZFL_Z)|(1<<ZFL_H)|(1<<ZFL_P)
001f96 6042                      	sbr	z_flags,(1<<ZFL_N)
001f97 940e 07e7                 	lcall	dram_read		; temp = (HL)
                                 
001f99 1750                      	cp	z_a,temp		; A - (HL)
                                 
001f9a f40a                      	brpl	PC+2
001f9b 6840                      	 sbr	z_flags,(1<<ZFL_S)
001f9c f409                      	brne	PC+2
001f9d 6440                      	 sbr	z_flags,(1<<ZFL_Z)
001f9e f40d                      	brhc	PC+2
001f9f 6140                      	 sbr	z_flags,(1<<ZFL_H)
                                 
001fa0 9731                      	sbiw	z,1			; BC--
001fa1 f009                      	breq	PC+2
001fa2 6044                      	 sbr	z_flags,(1<<ZFL_P)
001fa3 014f                      	movw	z_c,z			;BC
001fa4 9508                      	ret
                                 
                                 	checkspace PC, 5
                                 
                                 do_op_CPI:
001fa5 dfed                      	rcall	op_CPxx_common
001fa6 9611                      	adiw	x,1			; HL++
001fa7 016d                      	movw	z_l,x			; HL
001fa8 9508                      	ret
                                 
                                 
                                 	checkspace PC, 5
                                 
                                 do_op_CPD:
001fa9 dfe9                      	rcall	op_CPxx_common
001faa 9711                      	sbiw	x,1			; HL--
001fab 016d                      	movw	z_l,x			; HL
001fac 9508                      	ret
                                 
                                 	checkspace PC, 7
                                 
                                 do_op_CPIR:
001fad dff7                      	rcall	do_op_CPI
001fae fd46                      	sbrc	z_flags,ZFL_Z
001faf 9508                      	 ret
001fb0 ff42                      	sbrs	z_flags,ZFL_P
001fb1 9508                      	 ret
001fb2 9702                      	sbiw	z_pcl,2
001fb3 9508                      	ret
                                 
                                 	checkspace PC, 7
                                 
                                 do_op_CPDR:
001fb4 dff4                      	rcall	do_op_CPD
001fb5 fd46                      	sbrc	z_flags,ZFL_Z
001fb6 9508                      	 ret
001fb7 ff42                      	sbrs	z_flags,ZFL_P
001fb8 9508                      	 ret
001fb9 9702                      	sbiw	z_pcl,2
001fba 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|INI       |?*??1-|Input and Increment  |[HL]=[C],HL=HL+1,B=B-1|
                                 ;|IND       |?*??1-|Input and Decrement  |[HL]=[C],HL=HL-1,B=B-1|
                                 ;|INIR      |?1??1-|Input, Inc., Repeat  |INI till B=0          |
                                 ;|INDR      |?1??1-|Input, Dec., Repeat  |IND till B=0          |
                                 
                                 	checkspace PC, 12
                                 
                                 op_INxx_common:
001fbb 7b4f                      	cbr	z_flags,(1<<ZFL_Z)
001fbc 6042                      	sbr	z_flags,(1<<ZFL_N)
001fbd 2d18                      	mov	temp2,z_c		;C
001fbe 940e 22b7                 	lcall	portRead
001fc0 01d6                      	movw	x,z_l			;HL
001fc1 940e 07f3                 	lcall	dram_write
001fc3 949a                      	dec	z_b			;B
001fc4 f409                      	brne	PC+2
001fc5 6440                      	 sbr	z_flags,(1<<ZFL_Z)
001fc6 9508                      	ret
                                 
                                 	checkspace PC, 4
                                 
                                 do_op_INI:
001fc7 dff3                      	rcall	op_INxx_common
001fc8 9611                      	adiw	x,1
001fc9 016d                      	movw	z_l,x			;HL
001fca 9508                      	ret
                                 
                                 	checkspace PC, 4
                                 
                                 do_op_IND:
001fcb dfef                      	rcall	op_INxx_common
001fcc 9711                      	sbiw	x,1
001fcd 016d                      	movw	z_l,x			;HL
001fce 9508                      	ret
                                 
                                 	checkspace PC, 5
                                 
                                 do_op_INIR:
001fcf dff7                      	rcall	do_op_INI
001fd0 fd46                      	sbrc	z_flags,ZFL_Z
001fd1 9508                      	 ret
001fd2 9702                      	sbiw	z_pcl,2
001fd3 9508                      	ret
                                 
                                 	checkspace PC, 5
                                 
                                 do_op_INDR:
001fd4 dff6                      	rcall	do_op_IND
001fd5 fd46                      	sbrc	z_flags,ZFL_Z
001fd6 9508                      	 ret
001fd7 9702                      	sbiw	z_pcl,2
001fd8 9508                      	ret
                                 
                                 ;----------------------------------------------------------------
                                 ;|Mnemonic  |SZHPNC|Description          |Notes                 |
                                 ;----------------------------------------------------------------
                                 ;|OUTI      |?*??1-|Output and Increment |[C]=[HL],HL=HL+1,B=B-1|
                                 ;|OUTD      |?*??1-|Output and Decrement |[C]=[HL],HL=HL-1,B=B-1|
                                 ;|OTIR      |?1??1-|Output, Inc., Repeat |OUTI till B=0         |
                                 ;|OTDR      |?1??1-|Output, Dec., Repeat |OUTD till B=0         |
                                 
                                 	checkspace PC, 12
                                 
                                 op_OUTxx_common:
001fd9 01d6                      	movw	x,z_l			;HL
001fda 940e 07e7                 	lcall	dram_read		;temp = (z)
001fdc 2d18                      	mov	temp2,z_c		;C
001fdd 940e 22b5                 	lcall	portWrite
001fdf 7b4f                      	cbr	z_flags,(1<<ZFL_Z)
001fe0 6042                      	sbr	z_flags,(1<<ZFL_N)
001fe1 949a                      	dec	z_b			;B
001fe2 f409                      	brne	PC+2
001fe3 6440                      	 sbr	z_flags,(1<<ZFL_Z)
001fe4 9508                      	ret
                                 
                                 	checkspace PC, 4
                                 
                                 do_op_OUTI:
001fe5 dff3                      	rcall	op_OUTxx_common
001fe6 18c6                      	sub	z_l,_255		;-low(-1)
001fe7 08d6                      	sbc	z_h,_255		;-high(-1)
001fe8 9508                      	ret
                                 
                                 	checkspace PC, 4
                                 
                                 do_op_OUTD:
001fe9 dfef                      	rcall	op_OUTxx_common
001fea 0cc6                      	add	z_l,_255		;+low(-1)
001feb 1cd6                      	adc	z_h,_255		;+high(-1)
001fec 9508                      	ret
                                 
                                 	checkspace PC, 5
                                 
                                 do_op_OTIR:
001fed dff7                      	rcall	do_op_OUTI
001fee fd46                      	sbrc	z_flags,ZFL_Z
001fef 9508                      	 ret
001ff0 9702                      	sbiw	z_pcl,2
001ff1 9508                      	ret
                                 
                                 	checkspace PC, 5
                                 
                                 do_op_OTDR:
001ff2 dff6                      	rcall	do_op_OUTD
001ff3 fd46                      	sbrc	z_flags,ZFL_Z
001ff4 9508                      	 ret
001ff5 9702                      	sbiw	z_pcl,2
001ff6 9508                      	ret
                                 
                                 #if 1
                                 	opctable EDjmp, PC 	;+ 2*256
                                 
002000 9508                      instr 	fetch_nop,	op_nop,		store_nop	;00		;NOP
002001 9508                      instr 	fetch_nop,	op_nop,		store_nop	;01		;NOP
002002 9508                      instr 	fetch_nop,	op_nop,		store_nop	;02		;NOP
002003 9508                      instr 	fetch_nop,	op_nop,		store_nop	;03		;NOP
002004 9508                      instr 	fetch_nop,	op_nop,		store_nop	;04		;NOP
002005 9508                      instr 	fetch_nop,	op_nop,		store_nop	;05		;NOP
002006 9508                      instr 	fetch_nop,	op_nop,		store_nop	;06		;NOP
002007 9508                      instr 	fetch_nop,	op_nop,		store_nop	;07		;NOP
002008 9508                      instr 	fetch_nop,	op_nop,		store_nop	;08		;NOP
002009 9508                      instr 	fetch_nop,	op_nop,		store_nop	;09		;NOP
00200a 9508                      instr 	fetch_nop,	op_nop,		store_nop	;0A		;NOP
00200b 9508                      instr 	fetch_nop,	op_nop,		store_nop	;0B		;NOP
00200c 9508                      instr 	fetch_nop,	op_nop,		store_nop	;0C		;NOP
00200d 9508                      instr 	fetch_nop,	op_nop,		store_nop	;0D		;NOP
00200e 9508                      instr 	fetch_nop,	op_nop,		store_nop	;0E		;NOP
00200f 9508                      instr 	fetch_nop,	op_nop,		store_nop	;0F		;NOP
002010 9508                      instr 	fetch_nop,	op_nop,		store_nop	;10		;NOP
002011 9508                      instr 	fetch_nop,	op_nop,		store_nop	;11		;NOP
002012 9508                      instr 	fetch_nop,	op_nop,		store_nop	;12		;NOP
002013 9508                      instr 	fetch_nop,	op_nop,		store_nop	;13		;NOP
002014 9508                      instr 	fetch_nop,	op_nop,		store_nop	;14		;NOP
002015 9508                      instr 	fetch_nop,	op_nop,		store_nop	;15		;NOP
002016 9508                      instr 	fetch_nop,	op_nop,		store_nop	;16		;NOP
002017 9508                      instr 	fetch_nop,	op_nop,		store_nop	;17		;NOP
002018 9508                      instr 	fetch_nop,	op_nop,		store_nop	;18		;NOP
002019 9508                      instr 	fetch_nop,	op_nop,		store_nop	;19		;NOP
00201a 9508                      instr 	fetch_nop,	op_nop,		store_nop	;1A		;NOP
00201b 9508                      instr 	fetch_nop,	op_nop,		store_nop	;1B		;NOP
00201c 9508                      instr 	fetch_nop,	op_nop,		store_nop	;1C		;NOP
00201d 9508                      instr 	fetch_nop,	op_nop,		store_nop	;1D		;NOP
00201e 9508                      instr 	fetch_nop,	op_nop,		store_nop	;1E		;NOP
00201f 9508                      instr 	fetch_nop,	op_nop,		store_nop	;1F		;NOP
002020 9508                      instr 	fetch_nop,	op_nop,		store_nop	;20		;NOP
002021 9508                      instr 	fetch_nop,	op_nop,		store_nop	;21		;NOP
002022 9508                      instr 	fetch_nop,	op_nop,		store_nop	;22		;NOP
002023 9508                      instr 	fetch_nop,	op_nop,		store_nop	;23		;NOP
002024 9508                      instr 	fetch_nop,	op_nop,		store_nop	;24		;NOP
002025 9508                      instr 	fetch_nop,	op_nop,		store_nop	;25		;NOP
002026 9508                      instr 	fetch_nop,	op_nop,		store_nop	;26		;NOP
002027 9508                      instr 	fetch_nop,	op_nop,		store_nop	;27		;NOP
002028 9508                      instr 	fetch_nop,	op_nop,		store_nop	;28		;NOP
002029 9508                      instr 	fetch_nop,	op_nop,		store_nop	;29		;NOP
00202a 9508                      instr 	fetch_nop,	op_nop,		store_nop	;2A		;NOP
00202b 9508                      instr 	fetch_nop,	op_nop,		store_nop	;2B		;NOP
00202c 9508                      instr 	fetch_nop,	op_nop,		store_nop	;2C		;NOP
00202d 9508                      instr 	fetch_nop,	op_nop,		store_nop	;2D		;NOP
00202e 9508                      instr 	fetch_nop,	op_nop,		store_nop	;2E		;NOP
00202f 9508                      instr 	fetch_nop,	op_nop,		store_nop	;2F		;NOP
002030 9508                      instr 	fetch_nop,	op_nop,		store_nop	;30		;NOP
002031 9508                      instr 	fetch_nop,	op_nop,		store_nop	;31		;NOP
002032 9508                      instr 	fetch_nop,	op_nop,		store_nop	;32		;NOP
002033 9508                      instr 	fetch_nop,	op_nop,		store_nop	;33		;NOP
002034 9508                      instr 	fetch_nop,	op_nop,		store_nop	;34		;NOP
002035 9508                      instr 	fetch_nop,	op_nop,		store_nop	;35		;NOP
002036 9508                      instr 	fetch_nop,	op_nop,		store_nop	;36		;NOP
002037 9508                      instr 	fetch_nop,	op_nop,		store_nop	;37		;NOP
002038 9508                      instr 	fetch_nop,	op_nop,		store_nop	;38		;NOP
002039 9508                      instr 	fetch_nop,	op_nop,		store_nop	;39		;NOP
00203a 9508                      instr 	fetch_nop,	op_nop,		store_nop	;3A		;NOP
00203b 9508                      instr 	fetch_nop,	op_nop,		store_nop	;3B		;NOP
00203c 9508                      instr 	fetch_nop,	op_nop,		store_nop	;3C		;NOP
00203d 9508                      instr 	fetch_nop,	op_nop,		store_nop	;3D		;NOP
00203e 9508                      instr 	fetch_nop,	op_nop,		store_nop	;3E		;NOP
00203f 9508                      instr 	fetch_nop,	op_nop,		store_nop	;3F		;NOP
002040 cfb6
001ff7 2d68
001ff8 deb3
001ff9 c848                      instr 	fetch_C,	op_IN,		store2_B	;40		;IN B,(C)
002041 cfb8
001ffa 2d69
001ffb ceba                      instr 	fetch_B,	op_OUT,		store_nop	;41		;OUT (C),B
002042 cfb9
001ffc 01b4
001ffd cf02                      instr 	fetch_BC,	op_SBCHL,	store_nop	;42		;SBC HL,BC
002043 c0bc
002100 940e 0f77
002102 cdb8                      instr 	fetch_DIR16,	op_STBC,	store_nop	;43		;LD (nn),BC
002044 cecc                      instr 	fetch_nop,	op_NEG,		store_nop	;44		;NEG
002045 ceda                      instr 	fetch_nop,	op_RETN,	store_nop	;45		;RETN
002046 cedf                      instr 	fetch_nop,	op_IM0,		store_nop	;46		;IM 0
002047 cef8                      instr 	fetch_nop,	op_ldia,	store_nop	;47		;LD I,A
002048 c0ba
002103 2d68
002104 dda7
002105 940c 1844                 instr 	fetch_C,	op_IN,		store2_C	;48		;IN C,(C)
002049 c0bd
002107 2d68
002108 cdad                      instr 	fetch_C,	op_OUT,		store_nop	;49		;OUT (C),C
00204a c0be
002109 01b4
00210a cde3                      instr 	fetch_BC,	op_ADCHL,	store_nop	;4A		;ADC HL,BC
00204b c0bf
00210b 940e 0f77
00210d 940e 1110
00210f 940c 0fa0                 instr 	fetch_DIR16,	op_RMEM16,	store_BC	;4B nn nn	;LD BC,(nn)
00204c cec4                      instr 	fetch_nop,	op_NEG,		store_nop	;4C		;NEG
00204d ced2                      instr 	fetch_nop,	op_RETI,	store_nop	;4D		;RETI
00204e ced7                      instr 	fetch_nop,	op_IM0,		store_nop	;4E		;IM 0
00204f cef2                      instr 	fetch_nop,	op_ldra,	store_nop	;4F		;LD R,A
002050 c0c0
002111 2d68
002112 dd99
002113 940c 1846                 instr 	fetch_C,	op_IN,		store2_D	;50		;IN D,(C)
002051 c0c3
002115 2d6b
002116 cd9f                      instr 	fetch_D,	op_OUT,		store_nop	;51		;OUT (C),D
002052 c0c4
002117 01b5
002118 cde7                      instr 	fetch_DE,	op_SBCHL,	store_nop	;52		;SBC HL,DE
002053 c0c5
002119 940e 0f77
00211b cdb0                      instr 	fetch_DIR16,	op_STDE,	store_nop	;53 nn nn	;LD (nn),DE
002054 cebc                      instr 	fetch_nop,	op_NEG,		store_nop	;54		;NEG
002055 ceca                      instr 	fetch_nop,	op_RETN,	store_nop	;55		;RETN
002056 ced3                      instr 	fetch_nop,	op_IM1,		store_nop	;56		;IM 1
002057 cedc                      instr 	fetch_nop,	op_ldai,	store_nop	;57		;LD A,I
002058 c0c3
00211c 2d68
00211d dd8e
00211e 940c 1848                 instr 	fetch_C,	op_IN,		store2_E	;58		;IN E,(C)
002059 c0c6
002120 2d6a
002121 cd94                      instr 	fetch_E,	op_OUT,		store_nop	;59		;OUT (C),E
00205a c0c7
002122 01b5
002123 cdca                      instr 	fetch_DE,	op_ADCHL,	store_nop	;5A		;ADC HL,DE
00205b c0c8
002124 940e 0f77
002126 940e 1110
002128 940c 0fa2                 instr 	fetch_DIR16,	op_RMEM16,	store_DE	;5B nn nn	;LD DE,(nn)
00205c ceb4                      instr 	fetch_nop,	op_NEG,		store_nop	;5C		;NEG
00205d cec2                      instr 	fetch_nop,	op_RETN,	store_nop	;5D		;RETN
00205e ced0                      instr 	fetch_nop,	op_IM2,		store_nop	;5E		;IM 2
00205f ced6                      instr 	fetch_nop,	op_ldar,	store_nop	;5F		;LD A,R
002060 c0c9
00212a 2d68
00212b dd80
00212c 940c 184a                 instr 	fetch_C,	op_IN,		store2_H	;60		;IN H,(C)
002061 c0cc
00212e 2d6d
00212f cd86                      instr 	fetch_H,	op_OUT,		store_nop	;61		;OUT (C),H
002062 c0cd
002130 01b6
002131 cdce                      instr 	fetch_HL,	op_SBCHL,	store_nop	;62		;SBC HL,HL
002063 c0ce
002132 940c 12ac                 instr 	fetch_DIR16,	op_STHL,	store_nop	;63 nn nn	;LD (nn),HL
002064 ceac                      instr 	fetch_nop,	op_NEG,		store_nop	;64		;NEG
002065 ceba                      instr 	fetch_nop,	op_RETN,	store_nop	;65		;RETN
002066 cebf                      instr 	fetch_nop,	op_IM0,		store_nop	;66		;IM 0
002067 c0cc
002134 940e 1850
002136 de1e
002137 940c 0fb6                 instr 	fetch2_mhl,	op_RRD,		store_mhl	;67		;RRD
002068 c0d0
002139 2d68
00213a dd71
00213b 940c 184c                 instr 	fetch_C,	op_IN,		store2_L	;68		;IN L,(C)
002069 c0d3
00213d 2d6c
00213e cd77                      instr 	fetch_L,	op_OUT,		store_nop	;69		;OUT (C),L
00206a c0d4
00213f 01b6
002140 cdad                      instr 	fetch_HL,	op_ADCHL,	store_nop	;6A		;ADC HL,HL
00206b c0d5
002141 940c 12be                 instr 	fetch_DIR16,	op_RMEM16,	store_HL	;6B nn nn	;LD HL,(nn)
00206c cea4                      instr 	fetch_nop,	op_NEG,		store_nop	;6C		;NEG
00206d ceb2                      instr 	fetch_nop,	op_RETN,	store_nop	;6D		;RETN
00206e ceb7                      instr 	fetch_nop,	op_IM0,		store_nop	;6E		;IM 0
00206f c0d3
002143 940e 1850
002145 ddfe
002146 940c 0fb6                 instr 	fetch2_mhl,	op_RLD,		store_mhl	;6F		;RLD
002070 c0d7
002148 2d68
002149 cd62                      instr 	fetch_C,	op_IN,		store_nop	;70		;IN (C)
002071 c0d8
00214a e060
00214b cd6a                      instr 	fetch_0,	op_OUT,		store_nop	;71		;OUT (C),0
002072 c0d9
00214c 01b7
00214d cdb2                      instr 	fetch_SP,	op_SBCHL,	store_nop	;72		;SBC HL,SP
002073 c0da
00214e 940e 0f77
002150 cd8c                      instr 	fetch_DIR16,	op_STSP,	store_nop	;73 nn nn	;LD (nn),SP
002074 ce9c                      instr 	fetch_nop,	op_NEG,		store_nop	;74		;NEG
002075 ceaa                      instr 	fetch_nop,	op_RETN,	store_nop	;75		;RETN
002076 ceb3                      instr 	fetch_nop,	op_IM1,		store_nop	;76		;IM 1
002077 9508                      instr 	fetch_nop,	op_nop,		store_nop	;77		;NOP
002078 c0d8
002151 2d68
002152 dd59
002153 940c 184e                 instr 	fetch_C,	op_IN,		store2_A	;78		;IN A,(C)
002079 c0db
002155 2f65
002156 cd5f                      instr 	fetch_A,	op_OUT,		store_nop	;79		;OUT (C),A
00207a c0dc
002157 01b7
002158 cd95                      instr 	fetch_SP,	op_ADCHL,	store_nop	;7A		;ADC HL,SP
00207b c0dd
002159 940e 0f77
00215b 940e 1110
00215d 940c 0fcf                 instr 	fetch_DIR16,	op_RMEM16,	store_SP	;7B nn nn	;LD SP,(nn)
00207c ce94                      instr 	fetch_nop,	op_NEG,		store_nop	;7C		;NEG
00207d cea2                      instr 	fetch_nop,	op_RETN,	store_nop	;7D		;RETN
00207e ceb0                      instr 	fetch_nop,	op_IM2,		store_nop	;7E		;IM 2
00207f 9508                      instr 	fetch_nop,	op_nop,		store_nop	;7F		;NOP
002080 9508                      instr 	fetch_nop,	op_nop,		store_nop	;80		;NOP
002081 9508                      instr 	fetch_nop,	op_nop,		store_nop	;81		;NOP
002082 9508                      instr 	fetch_nop,	op_nop,		store_nop	;82		;NOP
002083 9508                      instr 	fetch_nop,	op_nop,		store_nop	;83		;NOP
002084 9508                      instr 	fetch_nop,	op_nop,		store_nop	;84		;NOP
002085 9508                      instr 	fetch_nop,	op_nop,		store_nop	;85		;NOP
002086 9508                      instr 	fetch_nop,	op_nop,		store_nop	;86		;NOP
002087 9508                      instr 	fetch_nop,	op_nop,		store_nop	;87		;NOP
002088 9508                      instr 	fetch_nop,	op_nop,		store_nop	;88		;NOP
002089 9508                      instr 	fetch_nop,	op_nop,		store_nop	;89		;NOP
00208a 9508                      instr 	fetch_nop,	op_nop,		store_nop	;8A		;NOP
00208b 9508                      instr 	fetch_nop,	op_nop,		store_nop	;8B		;NOP
00208c 9508                      instr 	fetch_nop,	op_nop,		store_nop	;8C		;NOP
00208d 9508                      instr 	fetch_nop,	op_nop,		store_nop	;8D		;NOP
00208e 9508                      instr 	fetch_nop,	op_nop,		store_nop	;8E		;NOP
00208f 9508                      instr 	fetch_nop,	op_nop,		store_nop	;8F		;NOP
002090 9508                      instr 	fetch_nop,	op_nop,		store_nop	;90		;NOP
002091 9508                      instr 	fetch_nop,	op_nop,		store_nop	;91		;NOP
002092 9508                      instr 	fetch_nop,	op_nop,		store_nop	;92		;NOP
002093 9508                      instr 	fetch_nop,	op_nop,		store_nop	;93		;NOP
002094 9508                      instr 	fetch_nop,	op_nop,		store_nop	;94		;NOP
002095 9508                      instr 	fetch_nop,	op_nop,		store_nop	;95		;NOP
002096 9508                      instr 	fetch_nop,	op_nop,		store_nop	;96		;NOP
002097 9508                      instr 	fetch_nop,	op_nop,		store_nop	;97		;NOP
002098 9508                      instr 	fetch_nop,	op_nop,		store_nop	;98		;NOP
002099 9508                      instr 	fetch_nop,	op_nop,		store_nop	;99		;NOP
00209a 9508                      instr 	fetch_nop,	op_nop,		store_nop	;9A		;NOP
00209b 9508                      instr 	fetch_nop,	op_nop,		store_nop	;9B		;NOP
00209c 9508                      instr 	fetch_nop,	op_nop,		store_nop	;9C		;NOP
00209d 9508                      instr 	fetch_nop,	op_nop,		store_nop	;9D		;NOP
00209e 9508                      instr 	fetch_nop,	op_nop,		store_nop	;9E		;NOP
00209f 9508                      instr 	fetch_nop,	op_nop,		store_nop	;9F		;NOP
0020a0 cede                      instr 	fetch_nop,	op_LDI,		store_nop	;A0		;LDI
0020a1 cf03                      instr 	fetch_nop,	op_CPI,		store_nop	;A1		;CPI
0020a2 cf24                      instr 	fetch_nop,	op_INI,		store_nop	;A2		;INI
0020a3 cf41                      instr 	fetch_nop,	op_OUTI,	store_nop	;A3		;OUTI
0020a4 9508                      instr 	fetch_nop,	op_nop,		store_nop	;A4		;NOP
0020a5 9508                      instr 	fetch_nop,	op_nop,		store_nop	;A5		;NOP
0020a6 9508                      instr 	fetch_nop,	op_nop,		store_nop	;A6		;NOP
0020a7 9508                      instr 	fetch_nop,	op_nop,		store_nop	;A7		;NOP
0020a8 cedc                      instr 	fetch_nop,	op_LDD,		store_nop	;A8		;LDD
0020a9 ceff                      instr 	fetch_nop,	op_CPD,		store_nop	;A9		;CPD
0020aa cf20                      instr 	fetch_nop,	op_IND,		store_nop	;AA		;IND
0020ab cf3d                      instr 	fetch_nop,	op_OUTD,	store_nop	;AB		;OUTD
0020ac 9508                      instr 	fetch_nop,	op_nop,		store_nop	;AC		;NOP
0020ad 9508                      instr 	fetch_nop,	op_nop,		store_nop	;AD		;NOP
0020ae 9508                      instr 	fetch_nop,	op_nop,		store_nop	;AE		;NOP
0020af 9508                      instr 	fetch_nop,	op_nop,		store_nop	;AF		;NOP
0020b0 ceda                      instr 	fetch_nop,	op_LDIR,	store_nop	;B0		;LDIR
0020b1 cefb                      instr 	fetch_nop,	op_CPIR,	store_nop	;B1		;CPIR
0020b2 cf1c                      instr 	fetch_nop,	op_INIR,	store_nop	;B2		;INIR
0020b3 cf39                      instr 	fetch_nop,	op_OTIR,	store_nop	;B3		;OTIR
0020b4 9508                      instr 	fetch_nop,	op_nop,		store_nop	;B4		;NOP
0020b5 9508                      instr 	fetch_nop,	op_nop,		store_nop	;B5		;NOP
0020b6 9508                      instr 	fetch_nop,	op_nop,		store_nop	;B6		;NOP
0020b7 9508                      instr 	fetch_nop,	op_nop,		store_nop	;B7		;NOP
0020b8 ced6                      instr 	fetch_nop,	op_LDDR,	store_nop	;B8		;LDDR
0020b9 cefa                      instr 	fetch_nop,	op_CPDR,	store_nop	;B9		;CPDR
0020ba cf19                      instr 	fetch_nop,	op_INDR,	store_nop	;BA		;INDR
0020bb cf36                      instr 	fetch_nop,	op_OTDR,	store_nop	;BB		;OTDR
0020bc 9508                      instr 	fetch_nop,	op_nop,		store_nop	;BC		;NOP
0020bd 9508                      instr 	fetch_nop,	op_nop,		store_nop	;BD		;NOP
0020be 9508                      instr 	fetch_nop,	op_nop,		store_nop	;BE		;NOP
0020bf 9508                      instr 	fetch_nop,	op_nop,		store_nop	;BF		;NOP
0020c0 9508                      instr 	fetch_nop,	op_nop,		store_nop	;C0		;NOP
0020c1 9508                      instr 	fetch_nop,	op_nop,		store_nop	;C1		;NOP
0020c2 9508                      instr 	fetch_nop,	op_nop,		store_nop	;C2		;NOP
0020c3 9508                      instr 	fetch_nop,	op_nop,		store_nop	;C3		;NOP
0020c4 9508                      instr 	fetch_nop,	op_nop,		store_nop	;C4		;NOP
0020c5 9508                      instr 	fetch_nop,	op_nop,		store_nop	;C5		;NOP
0020c6 9508                      instr 	fetch_nop,	op_nop,		store_nop	;C6		;NOP
0020c7 9508                      instr 	fetch_nop,	op_nop,		store_nop	;C7		;NOP
0020c8 9508                      instr 	fetch_nop,	op_nop,		store_nop	;C8		;NOP
0020c9 9508                      instr 	fetch_nop,	op_nop,		store_nop	;C9		;NOP
0020ca 9508                      instr 	fetch_nop,	op_nop,		store_nop	;CA		;NOP
0020cb 9508                      instr 	fetch_nop,	op_nop,		store_nop	;CB		;NOP
0020cc 9508                      instr 	fetch_nop,	op_nop,		store_nop	;CC		;NOP
0020cd 9508                      instr 	fetch_nop,	op_nop,		store_nop	;CD		;NOP
0020ce 9508                      instr 	fetch_nop,	op_nop,		store_nop	;CE		;NOP
0020cf 9508                      instr 	fetch_nop,	op_nop,		store_nop	;CF		;NOP
0020d0 9508                      instr 	fetch_nop,	op_nop,		store_nop	;D0		;NOP
0020d1 9508                      instr 	fetch_nop,	op_nop,		store_nop	;D1		;NOP
0020d2 9508                      instr 	fetch_nop,	op_nop,		store_nop	;D2		;NOP
0020d3 9508                      instr 	fetch_nop,	op_nop,		store_nop	;D3		;NOP
0020d4 9508                      instr 	fetch_nop,	op_nop,		store_nop	;D4		;NOP
0020d5 9508                      instr 	fetch_nop,	op_nop,		store_nop	;D5		;NOP
0020d6 9508                      instr 	fetch_nop,	op_nop,		store_nop	;D6		;NOP
0020d7 9508                      instr 	fetch_nop,	op_nop,		store_nop	;D7		;NOP
0020d8 9508                      instr 	fetch_nop,	op_nop,		store_nop	;D8		;NOP
0020d9 9508                      instr 	fetch_nop,	op_nop,		store_nop	;D9		;NOP
0020da 9508                      instr 	fetch_nop,	op_nop,		store_nop	;DA		;NOP
0020db 9508                      instr 	fetch_nop,	op_nop,		store_nop	;DB		;NOP
0020dc 9508                      instr 	fetch_nop,	op_nop,		store_nop	;DC		;NOP
0020dd 9508                      instr 	fetch_nop,	op_nop,		store_nop	;DD		;NOP
0020de 9508                      instr 	fetch_nop,	op_nop,		store_nop	;DE		;NOP
0020df 9508                      instr 	fetch_nop,	op_nop,		store_nop	;DF		;NOP
0020e0 9508                      instr 	fetch_nop,	op_nop,		store_nop	;E0		;NOP
0020e1 9508                      instr 	fetch_nop,	op_nop,		store_nop	;E1		;NOP
0020e2 9508                      instr 	fetch_nop,	op_nop,		store_nop	;E2		;NOP
0020e3 9508                      instr 	fetch_nop,	op_nop,		store_nop	;E3		;NOP
0020e4 9508                      instr 	fetch_nop,	op_nop,		store_nop	;E4		;NOP
0020e5 9508                      instr 	fetch_nop,	op_nop,		store_nop	;E5		;NOP
0020e6 9508                      instr 	fetch_nop,	op_nop,		store_nop	;E6		;NOP
0020e7 9508                      instr 	fetch_nop,	op_nop,		store_nop	;E7		;NOP
0020e8 9508                      instr 	fetch_nop,	op_nop,		store_nop	;E8		;NOP
0020e9 9508                      instr 	fetch_nop,	op_nop,		store_nop	;E9		;NOP
0020ea 9508                      instr 	fetch_nop,	op_nop,		store_nop	;EA		;NOP
0020eb 9508                      instr 	fetch_nop,	op_nop,		store_nop	;EB		;NOP
0020ec 9508                      instr 	fetch_nop,	op_nop,		store_nop	;EC		;NOP
0020ed 9508                      instr 	fetch_nop,	op_nop,		store_nop	;ED		;NOP
0020ee 9508                      instr 	fetch_nop,	op_nop,		store_nop	;EE		;NOP
0020ef 9508                      instr 	fetch_nop,	op_nop,		store_nop	;EF		;NOP
0020f0 9508                      instr 	fetch_nop,	op_nop,		store_nop	;F0		;NOP
0020f1 9508                      instr 	fetch_nop,	op_nop,		store_nop	;F1		;NOP
0020f2 9508                      instr 	fetch_nop,	op_nop,		store_nop	;F2		;NOP
0020f3 9508                      instr 	fetch_nop,	op_nop,		store_nop	;F3		;NOP
0020f4 9508                      instr 	fetch_nop,	op_nop,		store_nop	;F4		;NOP
0020f5 9508                      instr 	fetch_nop,	op_nop,		store_nop	;F5		;NOP
0020f6 9508                      instr 	fetch_nop,	op_nop,		store_nop	;F6		;NOP
0020f7 9508                      instr 	fetch_nop,	op_nop,		store_nop	;F7		;NOP
0020f8 9508                      instr 	fetch_nop,	op_nop,		store_nop	;F8		;NOP
0020f9 9508                      instr 	fetch_nop,	op_nop,		store_nop	;F9		;NOP
0020fa 9508                      instr 	fetch_nop,	op_nop,		store_nop	;FA		;NOP
0020fb 9508                      instr 	fetch_nop,	op_nop,		store_nop	;FB		;NOP
0020fc 9508                      instr 	fetch_nop,	op_nop,		store_nop	;FC		;NOP
0020fd 9508                      instr 	fetch_nop,	op_nop,		store_nop	;FD		;NOP
0020fe 9508                      instr 	fetch_nop,	op_nop,		store_nop	;FE		;NOP
0020ff 9508                      instr 	fetch_nop,	op_nop,		store_nop	;FF		;NOP
                                 #endif
                                 
                                 #endif
                                 
                                 ;----------------------------------------------------------------
                                 ; Lookup table, stolen from z80ex, Z80 emulation library.
                                 ; http://z80ex.sourceforge.net/
                                 
                                 ; The S, Z, 5 and 3 bits and the parity of the lookup value 
                                 
                                 	checkspace PC, 256
                                 
                                 	.org (PC+255) & 0xff00
                                 ;	.org opcjmp + 256
                                 ;	.org FLASHEND & 0xff00
                                 
                                 sz53p_tab:
002200 0044
002201 0400
002202 0400
002203 0004                      	.db 0x44,0x00,0x00,0x04,0x00,0x04,0x04,0x00
002204 0c08
002205 080c
002206 080c
002207 0c08                      	.db 0x08,0x0c,0x0c,0x08,0x0c,0x08,0x08,0x0c
002208 0400
002209 0004
00220a 0004
00220b 0400                      	.db 0x00,0x04,0x04,0x00,0x04,0x00,0x00,0x04
00220c 080c
00220d 0c08
00220e 0c08
00220f 080c                      	.db 0x0c,0x08,0x08,0x0c,0x08,0x0c,0x0c,0x08
002210 2420
002211 2024
002212 2024
002213 2420                      	.db 0x20,0x24,0x24,0x20,0x24,0x20,0x20,0x24
002214 282c
002215 2c28
002216 2c28
002217 282c                      	.db 0x2c,0x28,0x28,0x2c,0x28,0x2c,0x2c,0x28
002218 2024
002219 2420
00221a 2420
00221b 2024                      	.db 0x24,0x20,0x20,0x24,0x20,0x24,0x24,0x20
00221c 2c28
00221d 282c
00221e 282c
00221f 2c28                      	.db 0x28,0x2c,0x2c,0x28,0x2c,0x28,0x28,0x2c
002220 0400
002221 0004
002222 0004
002223 0400                      	.db 0x00,0x04,0x04,0x00,0x04,0x00,0x00,0x04
002224 080c
002225 0c08
002226 0c08
002227 080c                      	.db 0x0c,0x08,0x08,0x0c,0x08,0x0c,0x0c,0x08
002228 0004
002229 0400
00222a 0400
00222b 0004                      	.db 0x04,0x00,0x00,0x04,0x00,0x04,0x04,0x00
00222c 0c08
00222d 080c
00222e 080c
00222f 0c08                      	.db 0x08,0x0c,0x0c,0x08,0x0c,0x08,0x08,0x0c
002230 2024
002231 2420
002232 2420
002233 2024                      	.db 0x24,0x20,0x20,0x24,0x20,0x24,0x24,0x20
002234 2c28
002235 282c
002236 282c
002237 2c28                      	.db 0x28,0x2c,0x2c,0x28,0x2c,0x28,0x28,0x2c
002238 2420
002239 2024
00223a 2024
00223b 2420                      	.db 0x20,0x24,0x24,0x20,0x24,0x20,0x20,0x24
00223c 282c
00223d 2c28
00223e 2c28
00223f 282c                      	.db 0x2c,0x28,0x28,0x2c,0x28,0x2c,0x2c,0x28
002240 8480
002241 8084
002242 8084
002243 8480                      	.db 0x80,0x84,0x84,0x80,0x84,0x80,0x80,0x84
002244 888c
002245 8c88
002246 8c88
002247 888c                      	.db 0x8c,0x88,0x88,0x8c,0x88,0x8c,0x8c,0x88
002248 8084
002249 8480
00224a 8480
00224b 8084                      	.db 0x84,0x80,0x80,0x84,0x80,0x84,0x84,0x80
00224c 8c88
00224d 888c
00224e 888c
00224f 8c88                      	.db 0x88,0x8c,0x8c,0x88,0x8c,0x88,0x88,0x8c
002250 a0a4
002251 a4a0
002252 a4a0
002253 a0a4                      	.db 0xa4,0xa0,0xa0,0xa4,0xa0,0xa4,0xa4,0xa0
002254 aca8
002255 a8ac
002256 a8ac
002257 aca8                      	.db 0xa8,0xac,0xac,0xa8,0xac,0xa8,0xa8,0xac
002258 a4a0
002259 a0a4
00225a a0a4
00225b a4a0                      	.db 0xa0,0xa4,0xa4,0xa0,0xa4,0xa0,0xa0,0xa4
00225c a8ac
00225d aca8
00225e aca8
00225f a8ac                      	.db 0xac,0xa8,0xa8,0xac,0xa8,0xac,0xac,0xa8
002260 8084
002261 8480
002262 8480
002263 8084                      	.db 0x84,0x80,0x80,0x84,0x80,0x84,0x84,0x80
002264 8c88
002265 888c
002266 888c
002267 8c88                      	.db 0x88,0x8c,0x8c,0x88,0x8c,0x88,0x88,0x8c
002268 8480
002269 8084
00226a 8084
00226b 8480                      	.db 0x80,0x84,0x84,0x80,0x84,0x80,0x80,0x84
00226c 888c
00226d 8c88
00226e 8c88
00226f 888c                      	.db 0x8c,0x88,0x88,0x8c,0x88,0x8c,0x8c,0x88
002270 a4a0
002271 a0a4
002272 a0a4
002273 a4a0                      	.db 0xa0,0xa4,0xa4,0xa0,0xa4,0xa0,0xa0,0xa4
002274 a8ac
002275 aca8
002276 aca8
002277 a8ac                      	.db 0xac,0xa8,0xa8,0xac,0xa8,0xac,0xac,0xa8
002278 a0a4
002279 a4a0
00227a a4a0
00227b a0a4                      	.db 0xa4,0xa0,0xa0,0xa4,0xa0,0xa4,0xa4,0xa0
00227c aca8
00227d a8ac
00227e a8ac
00227f aca8                      	.db 0xa8,0xac,0xac,0xa8,0xac,0xa8,0xa8,0xac
                                 	
                                 ; vim:set ts=8 noet nowrap
                                 
                                 
                                 	.include "virt_ports.asm"	; Virtual Ports for BIOS
                                 
                                 ;
                                 ;    Copyright (C) 2010-2013 Leo C.
                                 ;
                                 ;    This file is part of avrcpm.
                                 ;
                                 ;    avrcpm is free software: you can redistribute it and/or modify it
                                 ;    under the terms of the GNU General Public License as published by
                                 ;    the Free Software Foundation, either version 3 of the License, or
                                 ;    (at your option) any later version.
                                 ;
                                 ;    avrcpm is distributed in the hope that it will be useful,
                                 ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
                                 ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                                 ;    GNU General Public License for more details.
                                 ;
                                 ;    You should have received a copy of the GNU General Public License
                                 ;    along with avrcpm.  If not, see <http://www.gnu.org/licenses/>.
                                 ;
                                 ;    $Id$
                                 ;
                                 
                                 
                                 ;
                                 ;   Port        Direction  Function
                                 ;hex	dez
                                 ;-------------------------------------------------------------------------
                                 ; 00  	0 	in	- Con status. (deprecated)
                                 ;			  Returns 0xFF if the UART has a byte, 0 otherwise.
                                 ; 01  	1 	in/out	- Console input, aka UDR. / Console Output
                                 ; 02  	2 	out	- Console Output (deprecated)
                                 ; 03  	3	in	- "UART" status: bit 0 = rx (UARTRXRDY)
                                 ;			                 bit 1 = tx (UARTTXRDY)
                                 ; 03	3	out	- "UART" control (tbd)
                                 ; 04  	4	in/out	- "UART" data register, no wait
                                 ;
                                 ;------------------------ Virtual I2C interface --------------------------
                                 ; 05	5	out	- Control Port: 1 = Start read operation
                                 ;					2 = Start write operation
                                 ;					3 = Write 1 byte subaddress, then read
                                 ; 05	5	in	- Status of last Transfer
                                 ; 06	6	in/out	- Number of bytes to transfer, including Slave address
                                 ; 07, 08	7,8	in/out	- Read/Write address low/high
                                 ;
                                 ;------------------------ Debugging --------------------------------------
                                 ; 09		out	- MEM dump: Number of bytes to print
                                 ; 0A, 0B	10, 11	in/out	- MEM dump: Start address
                                 ;
                                 ;------------------------ Version Information ----------------------------
                                 ; 0C	12	out	- 1 = Read VMAJOR
                                 ;			  2 = Read VMINOR
                                 ;			  4 = Read Version String
                                 ;
                                 ;------------------------ Disk I/O ---------------------------------------
                                 ; 0D, 0E	13, 14	in/out	- Set address of Bios Controll Block
                                 ; 0F  	15	in/out	- Disk select
                                 ; 10, 11  16, 17 	in/out	- Track select
                                 ; 12, 13 	18, 19 	in/out	- Sector select
                                 ; 14, 15 	20, 21 	in/out	- Write addr
                                 ;
                                 ; 16  	22 	out	- Trigger disk i/o operations
                                 ;			  Bit 7 = 1: Read sector
                                 ;			  Bit 6 = 1: Write sector
                                 ;			  Bit 5 = 1: BIOS WBOOT
                                 ;			  Bit 4 = 1: BIOS Home
                                 ;			  Only one of bits 4..7  may be set.
                                 ;			  If Write function (bit 6=1):
                                 ;			   Bits 0..2: 0 - write to allocated
                                 ;				      1 - write to directory
                                 ;				      2 - write unallocated
                                 ;				      3 - write to directory
                                 ;
                                 ; 16  	22	in	- Result of last read/write operation.
                                 ;			  0x00 = ok, 0xff = error (--> Bad Sector)
                                 ;
                                 ;
                                 ;------------------------ ADC Interface ----------------------------------
                                 ; 17-19	23,25	in	- ADC Channels 6,7 and 8 (Temp-Sensor)
                                 ;				ADC 6,7 only Devices in 32 pin Case (TQFP/MLF)
                                 ;				8 Bit only
                                 ;				Fixed ADC clock (FCPU/128, 156KHz at 20MHz CPU)
                                 ;				Vref = VCC
                                 ; 20, 21	32, 33	in	- ADC: Measure VCC
                                 ;
                                 ;------------------------ Wall Clock and Timers --------------------------
                                 ; 40  	64-71	in/out	- Timer/Clock control.
                                 ; 41-46
                                 ;
                                 ; 47-4D		in/out	- clock in BCD format: ss, mm, hh,  DD, MM, YYl, YYh
                                 ;
                                 ;------------------------ Debugging --------------------------------------
                                 ; 4F		out	- Debug: start/stop trace, print stack, ...
                                 ;
                                 ;------------------------ ISC16IS740 UART (16 ports) --------------------------------
                                 ; 50	RHR	in	  Receive Holding
                                 ; 50	THR 	out	  Transmit Holding
                                 ; 51	IER 	in/out	  Interrupt Enable
                                 ; 52	IIR	in	  Interrupt Identification
                                 ; 52	FCR	out	  FIFO Control
                                 ; 53	LCR 	in/out	  Line Control
                                 ; 54	MCR 	in/out	  Modem Control
                                 ; 55	LSR 	in	  Line Status
                                 ; 56	MSR 	in	  Modem Status
                                 ; 57	SPR 	in/out	  Scratchpad
                                 ; 56	TCR 	in/out	  Transmission Control
                                 ; 57	TLR	in/out	  Trigger Level
                                 ; 58	TXLVL	in	  Transmit FIFO Level
                                 ; 59	RXLVL	in	  Receive FIFO Level
                                 ; 5F	EFCR	in/out	  Extra Features
                                 ; -- extra registers (access requires LCR[7]=1)
                                 ; 50 	DLL	in/out	  divisor latch LSB
                                 ; 51 	DLH	in/out	  divisor latch MSB
                                 ; -- enhanced registers (access requires LCR=0xBF)
                                 ; 52 	EFR	in/out	  Enhanced Feature
                                 ; 54 	XON1 	in/out	  Xon1 word
                                 ; 55 	XON2  	in/out	  Xon2 word
                                 ; 56 	XOFF1 	in/out	  Xoff1 word
                                 ; 57 	XOFF2 	in/out	  Xoff2 word
                                 ;
                                 ;------------------------ MCP23017 GPIO (22 ports) --------------------------------
                                 ; 60 	IODIRA	== I2C_MCP23017_PORT
                                 ; 61 	IODIRB	
                                 ; 62 	IPOLA	
                                 ; 63 	IPOLB	
                                 ; 62 	GPINTENA	
                                 ; 62 	GPINTENB	
                                 ; 66 	DEFVALA	
                                 ; 67 	DEFVALB	
                                 ; 68 	INTCONA	
                                 ; 69 	INTCONB	
                                 ; 6A 	IOCON	
                                 ; 6B 	IOCON	
                                 ; 6C 	GPPUA	
                                 ; 6D 	GPPUB	
                                 ; 6E 	INTFA	
                                 ; 6F 	INTFB	
                                 ; 70 	INTCAPA	
                                 ; 71 	INTCAPB	
                                 ; 72 	GPIOA	
                                 ; 73 	GPIOB	
                                 ; 74 	OLATA	
                                 ; 75 	OLATB	
                                 
                                 ;------------------------ PCF8574 (8 Ports) ------------------------------------------
                                 ;80-87		in/out	- Port-Expander PCF8574 (max. 8 Chips)
                                 ;88-8F		in/out	- Port-Expander PCF8574A (not implemented yet!)
                                 
                                 
                                 ; ---------------------------------------------- Start of Code Segment
                                 
                                 	.cseg
                                 vport_tbl:
002280 0100                      	.db	00,1		;Port 0, length, 1 deprecated
002281 22ee                      	.dw	conStatus	;	in
002282 22f3                      	.dw	dbgOut		;	out
                                 
002283 0101                      	.db	UARTDR,1	;Port UARTDR, length 1
002284 0183                      	.dw	uartgetc	;	in
002285 01a3                      	.dw	uartputc	;	out
                                 
                                 ;	.db	02,1		;Port 2 (old console output)
                                 ;	.dw	uartgetc	; filler
                                 ;	.dw	uartputc	; deprecated
                                 
002286 0103                      	.db	UARTCSR,1
002287 22d5                      	.dw	uartstat
002288 22d4                      	.dw	vport_out_dummy
                                 
002289 0104                      	.db	04,1
00228a 22e0                      	.dw	uartin
00228b 22e7                      	.dw	uartout
                                 
00228c 090d                      	.db	13,9		; Port 13-21, (length 9)
00228d 0c54                      	.dw	dsk_param_get
00228e 0c4f                      	.dw	dsk_param_set
00228f 0116                      	.db	22,1
002290 0c82                      	.dw	dskErrorRet
002291 0dc3                      	.dw	dskDoIt
                                 
002292 0740                      	.db	TIMERPORT,7
002293 05e0                      	.dw	utimeget
002294 05f4                      	.dw	utimeput
                                 
002295 0747                      	.db	CLOCKPORT,7	;Clock format (bcd): ss, mm, hh,  DD, MM, YYl, YYh
002296 04f3                      	.dw	clockget
002297 0510                      	.dw	clockput
                                 
                                 #if I2C_SUPPORT
002298 0105                      	.db	I2CCTRL,1
002299 0900                      	.dw	vi2c_stat_get
00229a 0983                      	.dw	vi2c_ctrl
                                 
00229b 0306                      	.db	I2CBLEN,3	;
00229c 0903                      	.dw	vi2c_param_get
00229d 090e                      	.dw	vi2c_param_set
                                 
                                 #if I2C_UART_SUPPORT
00229e 1050                      	.db	I2C_SC16IS740_PORT,I2C_SC16IS740_REGS
00229f 09a6                      	.dw	SC16IS740_in
0022a0 09b3                      	.dw	SC16IS740_out
                                 #endif
                                 
                                 /* -MH- */
                                 #if I2C_PCF8574_SUPPORT
0022a1 0780                      	.db	I2C_PCF8574_PORT,I2C_PCF8574_REGS
0022a2 098e                      	.dw	pcf8574_in
0022a3 099a                      	.dw	pcf8574_out
                                 #endif
                                 
                                 ; -MH-
                                 #if I2C_MCP23017_SUPPORT
0022a4 1660                      	.db	I2C_MCP23017_PORT,I2C_MCP23017_REGS   ; 22 byte registers
0022a5 09c2                      	.dw	MCP23017_in
0022a6 09cd                      	.dw	MCP23017_out
                                 #endif
                                 ; -MH-
                                 
                                 ; -MH-
                                 #endif ; I2C_SUPPORT
                                 
                                 #if ADC_SUPPORT
0022a7 0317                      	.db	ADC80,3		;2 Channels ADC80 ADC81 + Temp Sensor
                                 ;	.dw	adc_read8
0022a8 22d4                      	.dw	vport_out_dummy
                                 
0022a9 0220                      	.db	0x20,2		;
                                 ;	.dw	adc_readvcc
0022aa 22d4                      	.dw	vport_out_dummy
                                 #endif
0022ab 014f                      	.db	DEBUGPORT,1
0022ac 22ff                      	.dw	dbg_stat
0022ad 2301                      	.dw	dbg_ctrl
                                 
                                 .if MEMDUMP_DEBUG
0022ae 0309                      	.db	MEMDUMPPORT,3
0022af 2307                      	.dw	dbg_dump_rd
0022b0 2313                      	.dw	dbg_dump
                                 .endif
0022b1 010c                      	.db	0x0C,1
0022b2 233c                      	.dw	version_get
0022b3 2331                      	.dw	version_ctrl
                                 
0022b4 0000                      	.db	0,0		; Stop mark
                                 
                                 ;---------------------------------------------------------------------
                                 
                                 ;Called with port in temp2 and value in temp.
                                 portWrite:
0022b5 9468                      	set
0022b6 c001                      	rjmp	vprw_start
                                 
                                 ;Called with port in temp2. Should return value in temp.
                                 portRead:
0022b7 94e8                      	clt
                                 
                                 vprw_start:
0022b8 93df                      	push	yh
0022b9 93cf                      	push	yl
                                 .if PORT_DEBUG > 1
                                 .endif
0022ba e0e0
0022bb e4f5                      	ldiw	z,vport_tbl*2
                                 
                                 vprw_loop:
0022bc 9005                      	lpm	_tmp0,z+
0022bd 9015                      	lpm	_tmp1,z+	;length
0022be 1417                      	cp	_tmp1,_0
0022bf f081                      	breq	vprw_exit	;no more ports
                                 
0022c0 2f21                      	mov	temp3,temp2
0022c1 1920                      	sub	temp3,_tmp0	;base port
0022c2 f010                      	brcs	vprw_next	;port # too high
0022c3 1521                      	cp	temp3,_tmp1     ;may be in range
0022c4 f010                      	brcs	vprw_found	;
                                 vprw_next:			;port # not in range, test next block.
0022c5 9634                      	adiw	z,4
0022c6 cff5                      	rjmp	vprw_loop
                                 vprw_found:
0022c7 f40e                      	brtc	PC+2		;read or write?
0022c8 9632                      	adiw	z,2		;skip read function pointer
0022c9 9005                      	lpm	_tmp0,z+
0022ca 91f4                      	lpm	zh,z
0022cb 2de0                      	mov	zl,_tmp0
                                 
                                 .if PORT_DEBUG > 1
                                 .else
0022cc 9509                      	icall
0022cd 91cf                      	pop	yl
0022ce 91df                      	pop	yh
0022cf 9508                      	ret
                                 .endif
                                 
                                 vprw_exit:
                                 				; trap for nonexistent port?
                                 .if PORT_DEBUG > 1
                                 .endif
0022d0 ef0f                      	ldi	temp,0xff
0022d1 91cf                      	pop	yl
0022d2 91df                      	pop	yh
0022d3 9508                      	ret
                                 
                                 vport_out_dummy:
0022d4 9508                      	ret
                                 
                                 ;---------------------------------------------------------------------
                                 
                                 uartstat:
0022d5 2700                      	clr	temp
0022d6 9110 0108                 	lds	temp2,rxcount
0022d8 1117                      	cpse	temp2,_0
0022d9 6001                      	 sbr	temp,UARTRXRDY
0022da 9110 010b                 	lds	temp2,txcount
0022dc 3810                      	cpi	temp2,TXBUFSIZE
0022dd f009                      	breq	uartst_1
0022de 6002                      	 sbr	temp,UARTTXRDY
                                 uartst_1:
0022df 9508                      	ret
                                 
                                 uartin:
0022e0 2700                      	clr	temp
0022e1 9110 0108                 	lds	temp2,rxcount
0022e3 1117                      	cpse	temp2,_0
0022e4 940c 0183                 	 ljmp	uartgetc
0022e6 9508                      	ret
                                 
                                 uartout:
0022e7 9110 010b                 	lds	temp2,txcount
0022e9 3810                      	cpi	temp2,TXBUFSIZE
0022ea f011                      	breq	uartout_1
0022eb 940c 01a3                 	ljmp uartputc
                                 uartout_1:
0022ed 9508                      	ret
                                 
                                 
                                 conStatus:
0022ee 9100 0108                 	lds	temp,rxcount
0022f0 1107                      	cpse	temp,_0
0022f1 ef0f                      	 ldi	temp,0xff
0022f2 9508                      	ret
                                 
                                 
                                 ;---------------------------------------------------------------------
                                 
                                 dbgOut:
0022f3 940e 0223
0022f5 000d                      	printnewline
0022f6 940e 0223
0022f8 6544
0022f9 7562
0022fa 3a67
0022fb 0020                      	printstring "Debug: "
0022fc 940e 0212                 	lcall printhex
0022fe 9508                      	ret
                                 
                                 dbg_stat:
0022ff e000                      	ldi	temp,0
002300 9508                      	ret
                                 
                                 dbg_ctrl:
002301 fb00
002302 f931                      	bmov	intstat,i_trace, temp,0
                                 .if SRAM_FILL
002303 fd01                      	sbrc	temp,1
002304 940e 0253                 	lcall	stackusage_print
                                 .endif
002306 9508                      	ret
                                 
                                 ;---------------------------------------------------------------------
                                 
                                 .if MEMDUMP_DEBUG
                                 
                                 	.dseg
                                 
                                 dbg_dump_addr:
000708                           	.byte	2
                                 
                                 
                                 	.cseg
                                 
                                 dbg_dump_rd:
002307 1127                      	cpse	temp3,_0
002308 c002                      	rjmp	dbg_dump_rdad
002309 e000                      	ldi	temp,0
00230a 9508                      	ret
                                 
                                 dbg_dump_rdad:
00230b 952a                      	dec	temp3
00230c f419                      	brne	dbg_dump_rdad1
00230d 9100 0708                 	lds	temp,dbg_dump_addr+0
00230f 9508                      	ret
                                 dbg_dump_rdad1:
002310 9100 0709                 	lds	temp,dbg_dump_addr+1
002312 9508                      	ret
                                 
                                 
                                 dbg_dump:
002313 1127                      	cpse	temp3,_0
002314 c014                      	rjmp	dbg_dump_store
                                 
002315 2f20                      	mov	temp3,temp
002316 91e0 0708
002318 91f0 0709                 	ldsw	z,dbg_dump_addr
                                 
00231a 2322                      	tst	temp3
00231b f011                      	breq	dbg_dumpl_1
                                 dbg_dumpl:
00231c 3120                      	cpi	temp3,16
00231d f028                      	brlo	dbg_dump_u16
                                 dbg_dumpl_1:
00231e 940e 0277                 	lcall	dbg_hexdump_line
002320 5120                      	subi	temp3,16
002321 9670                      	adiw	z,16
002322 cff9                      	rjmp	dbg_dumpl
                                 
                                 dbg_dump_u16:
002323 2322                      	tst	temp3
002324 f019                      	breq	dbg_dump_e
002325 2f12                      	mov	temp2,temp3
002326 940e 029a                 	lcall	dbg_hexdump
                                 dbg_dump_e:
002328 9508                      	ret
                                 
                                 dbg_dump_store:
002329 952a                      	dec	temp3
00232a f419                      	brne	dbg_dump_st1
00232b 9300 0708                 	sts	dbg_dump_addr+0,temp
00232d 9508                      	ret
                                 dbg_dump_st1:
00232e 9300 0709                 	sts	dbg_dump_addr+1,temp
002330 9508                      	ret
                                 
                                 .endif
                                 
                                 ;---------------------------------------------------------------------
                                 
                                 	.dseg
                                 vers_cmd:
00070a                           	.byte	1
                                 vers_pstr:
00070b                           	.byte	2
                                 
                                 	.cseg
                                 version_ctrl:
002331 9300 070a                 	sts	vers_cmd,temp
002333 3004                      	cpi	temp,4
002334 f431                      	brne	vc_e
                                 
002335 e4e4
002336 e0f7                      	ldiw	z,version_string*2
002337 93e0 070b
002339 93f0 070c                 	stsw	vers_pstr,z
                                 vc_e:
00233b 9508                      	ret
                                 
                                 version_get:
00233c 9110 070a                 	lds	temp2,vers_cmd
00233e e000                      	ldi	temp,0
00233f 3010                      	cpi	temp2,0
002340 f0a1                      	breq	vc_g_e
002341 e003                      	ldi	temp,VMAJOR
002342 3011                      	cpi	temp2,1
002343 f089                      	breq	vc_g_e
002344 e005                      	ldi	temp,VMINOR
002345 3012                      	cpi	temp2,2
002346 f071                      	breq	vc_g_e
002347 ef0f                      	ldi	temp,0xFF
002348 3014                      	cpi	temp2,4
002349 f459                      	brne	vc_g_e
                                 
00234a 91e0 070b
00234c 91f0 070c                 	ldsw	z,vers_pstr
00234e 9105                      	lpm	temp,z+
00234f 2300                      	tst	temp
002350 f021                      	breq	vc_g_e
002351 93e0 070b
002353 93f0 070c                 	stsw	vers_pstr,z
                                 
                                 vc_g_e:
002355 9508                      	ret
                                 
                                 
                                 ;---------------------------------------------------------------------
                                 ; vim:set ts=8 noet nowrap
                                 	.include "dram-refresh.asm"
                                 
                                 ;
                                 ;    Copyright (C) 2010 Sprite_tm
                                 ;    Copyright (C) 2010 Leo C.
                                 ;
                                 ;    This file is part of avrcpm.
                                 ;
                                 ;    avrcpm is free software: you can redistribute it and/or modify it
                                 ;    under the terms of the GNU General Public License as published by
                                 ;    the Free Software Foundation, either version 3 of the License, or
                                 ;    (at your option) any later version.
                                 ;
                                 ;    avrcpm is distributed in the hope that it will be useful,
                                 ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
                                 ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                                 ;    GNU General Public License for more details.
                                 ;
                                 ;    You should have received a copy of the GNU General Public License
                                 ;    along with avrcpm.  If not, see <http://www.gnu.org/licenses/>.
                                 ;
                                 ;    $Id: dram-refresh.asm 93 2014-01-03 16:32:32Z rapid $
                                 ;
                                 
                                 
                                 ; ------------------- DRAM Refresh Interrupt --------------------
                                 
                                 	.cseg
                                 	
00000e 940c 2356                 	INTERRUPT OC2Aaddr
                                 	#if S_RAM
002356 9518                      		reti					; only for SRAM	
                                 	#endif
                                 
002357 9b40                      	sbis	P_RAS,ram_ras	;2
002358 9518                      	reti
                                 				;       CAS  RAS  
002359 9841                      	cbi	P_CAS,ram_cas	;2       1|   1|  
                                 				;        1|   1|  
00235a 9840                      	cbi	P_RAS,ram_ras	;2      |0    1|  
                                 				;       |0    1|  
00235b 0000                      	nop			;1      |0   |0   
                                 ;	nop			;1      |0   |0   
00235c 9a40                      	sbi	P_RAS,ram_ras	;2      |0   |0   
                                 				;       |0   |0   
                                 	dram_wait DRAM_WAITSTATES-1 ;   |    |
                                 ;	nop			;1      |0   |0   
00235d 9840                      	cbi	P_RAS,ram_ras	;2      |0    1|  
                                 				;       |0    1|  
00235e 9a41                      	sbi	P_CAS,ram_cas	;2      |0   |0   
                                 				;       |0   |0   
00235f 9a40                      	sbi	P_RAS,ram_ras	;2       1|  |0   
                                 				;        1|   1|  
002360 9518                      	reti			;4  --> 21 cycles
                                 
                                 
                                 ; vim:set ts=8 noet nowrap
                                 
                                 
                                 
                                 	.dseg
00070d                           ramtop:	.byte	0
                                 	
                                 	.cseg
                                 
                                 ; vim:set ts=8 noet nowrap
                                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega328P" register use summary:
x  :  68 y  : 310 z  : 266 r0 : 105 r1 :  33 r2 :  60 r3 :  60 r4 :  33 
r5 :  27 r6 : 146 r7 : 169 r8 :  84 r9 :  64 r10:  73 r11:  64 r12:  86 
r13:  68 r14:  47 r15:  26 r16:1062 r17: 371 r18: 156 r19:  11 r20: 177 
r21: 107 r22: 795 r23:  47 r24:  49 r25:  22 r26: 154 r27: 123 r28:  91 
r29:  81 r30: 294 r31: 232 
Registers used: 35 out of 35 (100.0%)

"ATmega328P" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  69 add   :  57 adiw  :  70 and   :   5 
andi  : 190 asr   :   0 bclr  :   0 bld   :  62 brbc  :   0 brbs  :   0 
brcc  :  18 brcs  :  13 break :   0 breq  :  98 brge  :   2 brhc  :   1 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  23 brlt  :   1 brmi  :   1 
brne  : 131 brpl  :   7 brsh  :  19 brtc  :   4 brts  :   1 brvc  :   0 
brvs  :   0 bset  :   0 bst   :  62 call  :  66 cbi   :  12 cbr   :  14 
clc   :   6 clh   :   0 cli   :  12 cln   :   0 clr   :  43 cls   :   0 
clt   :   2 clv   :   0 clz   :   0 com   :   9 cp    :  34 cpc   :  24 
cpi   : 112 cpse  :   7 dec   :  54 eor   :  10 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   3 ijmp  :   4 in    :  90 inc   :  31 jmp   :  44 
ld    :  50 ldd   : 234 ldi   : 455 lds   : 123 lpm   :  69 lsl   :  21 
lsr   :  30 mov   : 497 movw  : 101 mul   :   6 muls  :   0 mulsu :   0 
neg   :   0 nop   :  34 or    :  17 ori   : 179 out   : 493 pop   : 151 
push  : 143 rcall : 654 ret   : 525 reti  :   7 rjmp  :2001 rol   :  21 
ror   :  19 sbc   :  24 sbci  :  16 sbi   :  13 sbic  :  17 sbis  :  10 
sbiw  :  31 sbr   :  30 sbrc  :  39 sbrs  :  36 sec   :   8 seh   :   0 
sei   :  13 sen   :   0 ser   :   0 ses   :   0 set   :   4 sev   :   0 
sez   :   1 sleep :   0 spm   :   0 st    :  40 std   : 167 sts   : 124 
sub   :  23 subi  :  43 swap  :  11 tst   :  41 wdr   :   1 
Instructions used: 82 out of 113 (72.6%)

"ATmega328P" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x007800  16530   1148  17678   32768  53.9%
[.dseg] 0x000100 0x00070d      0   1549   1549    2048  75.6%
[.eseg] 0x000000 0x000000      0      0      0    1024   0.0%

Assembly complete, 0 errors, 6 warnings
